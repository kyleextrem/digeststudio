{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@portabletext/toolkit/dist/index.js","sources":["file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/toolkit/src/asserters.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/toolkit/src/sortMarksByOccurences.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/toolkit/src/buildMarksTree.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/toolkit/src/nestLists.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/toolkit/src/spanToPlainText.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/toolkit/src/toPlainText.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/toolkit/src/types.ts"],"sourcesContent":["import type {\n  ArbitraryTypedObject,\n  PortableTextBlock,\n  PortableTextListItemBlock,\n  PortableTextSpan,\n  TypedObject,\n} from '@portabletext/types'\n\nimport type {ToolkitNestedPortableTextSpan, ToolkitPortableTextList, ToolkitTextNode} from './types'\n\n/**\n * Strict check to determine if node is a correctly formatted Portable Text span.\n *\n * @param node - Node to check\n * @returns True if valid Portable Text span, otherwise false\n */\nexport function isPortableTextSpan(\n  node: ArbitraryTypedObject | PortableTextSpan,\n): node is PortableTextSpan {\n  return (\n    node._type === 'span' &&\n    'text' in node &&\n    typeof node.text === 'string' &&\n    (typeof node.marks === 'undefined' ||\n      (Array.isArray(node.marks) && node.marks.every((mark) => typeof mark === 'string')))\n  )\n}\n\n/**\n * Strict check to determine if node is a correctly formatted Portable Text block.\n *\n * @param node - Node to check\n * @returns True if valid Portable Text block, otherwise false\n */\nexport function isPortableTextBlock(\n  node: PortableTextBlock | TypedObject,\n): node is PortableTextBlock {\n  return (\n    // A block doesn't _have_ to be named 'block' - to differentiate between\n    // allowed child types and marks, one might name them differently\n    typeof node._type === 'string' &&\n    // Toolkit-types like nested spans are @-prefixed\n    node._type[0] !== '@' &&\n    // `markDefs` isn't _required_ per say, but if it's there, it needs to be an array\n    (!('markDefs' in node) ||\n      !node.markDefs ||\n      (Array.isArray(node.markDefs) &&\n        // Every mark definition needs to have an `_key` to be mappable in child spans\n        node.markDefs.every((def) => typeof def._key === 'string'))) &&\n    // `children` is required and needs to be an array\n    'children' in node &&\n    Array.isArray(node.children) &&\n    // All children are objects with `_type` (usually spans, but can contain other stuff)\n    node.children.every((child) => typeof child === 'object' && '_type' in child)\n  )\n}\n\n/**\n * Strict check to determine if node is a correctly formatted portable list item block.\n *\n * @param block - Block to check\n * @returns True if valid Portable Text list item block, otherwise false\n */\nexport function isPortableTextListItemBlock(\n  block: PortableTextBlock | TypedObject,\n): block is PortableTextListItemBlock {\n  return (\n    isPortableTextBlock(block) &&\n    'listItem' in block &&\n    typeof block.listItem === 'string' &&\n    (typeof block.level === 'undefined' || typeof block.level === 'number')\n  )\n}\n\n/**\n * Loose check to determine if block is a toolkit list node.\n * Only checks `_type`, assumes correct structure.\n *\n * @param block - Block to check\n * @returns True if toolkit list, otherwise false\n */\nexport function isPortableTextToolkitList(\n  block: TypedObject | ToolkitPortableTextList,\n): block is ToolkitPortableTextList {\n  return block._type === '@list'\n}\n\n/**\n * Loose check to determine if span is a toolkit span node.\n * Only checks `_type`, assumes correct structure.\n *\n * @param span - Span to check\n * @returns True if toolkit span, otherwise false\n */\nexport function isPortableTextToolkitSpan(\n  span: TypedObject | ToolkitNestedPortableTextSpan,\n): span is ToolkitNestedPortableTextSpan {\n  return span._type === '@span'\n}\n\n/**\n * Loose check to determine if node is a toolkit text node.\n * Only checks `_type`, assumes correct structure.\n *\n * @param node - Node to check\n * @returns True if toolkit text node, otherwise false\n */\nexport function isPortableTextToolkitTextNode(\n  node: TypedObject | ToolkitTextNode,\n): node is ToolkitTextNode {\n  return node._type === '@text'\n}\n","import type {PortableTextSpan, TypedObject} from '@portabletext/types'\n\nimport {isPortableTextSpan} from './asserters'\n\nconst knownDecorators = ['strong', 'em', 'code', 'underline', 'strike-through']\n\n/**\n * Figures out the optimal order of marks, in order to minimize the amount of\n * nesting/repeated elements in environments such as HTML. For instance, a naive\n * implementation might render something like:\n *\n * ```html\n * <strong>This block contains </strong>\n * <strong><a href=\"https://some.url/\">a link</a></strong>\n * <strong> and some bolded text</strong>\n * ```\n *\n * ...whereas an optimal order would be:\n *\n * ```html\n * <strong>\n *   This block contains <a href=\"https://some.url/\">a link</a> and some bolded text\n * </strong>\n * ```\n *\n * This is particularly necessary for cases like links, where you don't want multiple\n * individual links for different segments of the link text, even if parts of it are\n * bolded/italicized.\n *\n * This function is meant to be used like: `block.children.map(sortMarksByOccurences)`,\n * and is used internally in {@link buildMarksTree | `buildMarksTree()`}.\n *\n * The marks are sorted in the following order:\n *\n *  1. Marks that are shared amongst the most adjacent siblings\n *  2. Non-default marks (links, custom metadata)\n *  3. Decorators (bold, emphasis, code etc), in a predefined, preferred order\n *\n * @param span - The current span to sort\n * @param index - The index of the current span within the block\n * @param blockChildren - All children of the block being sorted\n * @returns Array of decorators and annotations, sorted by \"most adjacent siblings\"\n */\nexport function sortMarksByOccurences(\n  span: PortableTextSpan | TypedObject,\n  index: number,\n  blockChildren: (PortableTextSpan | TypedObject)[],\n): string[] {\n  if (!isPortableTextSpan(span) || !span.marks) {\n    return []\n  }\n\n  if (!span.marks.length) {\n    return []\n  }\n\n  // Slicing because we'll be sorting with `sort()`, which mutates\n  const marks = span.marks.slice()\n  const occurences: Record<string, number> = {}\n  marks.forEach((mark) => {\n    occurences[mark] = 1\n\n    for (let siblingIndex = index + 1; siblingIndex < blockChildren.length; siblingIndex++) {\n      const sibling = blockChildren[siblingIndex]\n\n      if (\n        sibling &&\n        isPortableTextSpan(sibling) &&\n        Array.isArray(sibling.marks) &&\n        sibling.marks.indexOf(mark) !== -1\n      ) {\n        occurences[mark]++\n      } else {\n        break\n      }\n    }\n  })\n\n  return marks.sort((markA, markB) => sortMarks(occurences, markA, markB))\n}\n\nfunction sortMarks<U extends string, T extends Record<U, number>>(\n  occurences: T,\n  markA: U,\n  markB: U,\n): number {\n  const aOccurences = occurences[markA]\n  const bOccurences = occurences[markB]\n\n  if (aOccurences !== bOccurences) {\n    return bOccurences - aOccurences\n  }\n\n  const aKnownPos = knownDecorators.indexOf(markA)\n  const bKnownPos = knownDecorators.indexOf(markB)\n\n  // Sort known decorators last\n  if (aKnownPos !== bKnownPos) {\n    return aKnownPos - bKnownPos\n  }\n\n  // Sort other marks simply by key\n  return markA.localeCompare(markB)\n}\n","import type {\n  ArbitraryTypedObject,\n  PortableTextBlock,\n  PortableTextMarkDefinition,\n} from '@portabletext/types'\n\nimport type {ToolkitNestedPortableTextSpan, ToolkitTextNode} from './types'\n\nimport {isPortableTextSpan} from './asserters'\nimport {sortMarksByOccurences} from './sortMarksByOccurences'\n\n/**\n * Takes a Portable Text block and returns a nested tree of nodes optimized for rendering\n * in HTML-like environments where you want marks/annotations to be nested inside of eachother.\n * For instance, a naive span-by-span rendering might yield:\n *\n * ```html\n * <strong>This block contains </strong>\n * <strong><a href=\"https://some.url/\">a link</a></strong>\n * <strong> and some bolded and </strong>\n * <em><strong>italicized text</strong></em>\n * ```\n *\n * ...whereas an optimal order would be:\n *\n * ```html\n * <strong>\n *   This block contains <a href=\"https://some.url/\">a link</a>\n *   and some bolded and <em>italicized text</em>\n * </strong>\n * ```\n *\n * Note that since \"native\" Portable Text spans cannot be nested,\n * this function returns an array of \"toolkit specific\" types:\n * {@link ToolkitTextNode | `@text`} and {@link ToolkitNestedPortableTextSpan | `@span` }.\n *\n * The toolkit-specific type can hold both types, as well as any arbitrary inline objects,\n * creating an actual tree.\n *\n * @param block - The Portable Text block to create a tree of nodes from\n * @returns Array of (potentially) nested spans, text nodes and/or arbitrary inline objects\n */\nexport function buildMarksTree<M extends PortableTextMarkDefinition = PortableTextMarkDefinition>(\n  block: PortableTextBlock<M>,\n): (ToolkitNestedPortableTextSpan<M> | ToolkitTextNode | ArbitraryTypedObject)[] {\n  const {children} = block\n  const markDefs = block.markDefs ?? []\n  if (!children || !children.length) {\n    return []\n  }\n\n  const sortedMarks = children.map(sortMarksByOccurences)\n\n  const rootNode: ToolkitNestedPortableTextSpan<M> = {\n    _type: '@span',\n    children: [],\n    markType: '<unknown>',\n  }\n\n  let nodeStack: ToolkitNestedPortableTextSpan<M>[] = [rootNode]\n\n  for (let i = 0; i < children.length; i++) {\n    const span = children[i]\n    if (!span) {\n      continue\n    }\n\n    const marksNeeded = sortedMarks[i] || []\n    let pos = 1\n\n    // Start at position one. Root is always plain and should never be removed\n    if (nodeStack.length > 1) {\n      for (pos; pos < nodeStack.length; pos++) {\n        const mark = nodeStack[pos]?.markKey || ''\n        const index = marksNeeded.indexOf(mark)\n\n        if (index === -1) {\n          break\n        }\n\n        marksNeeded.splice(index, 1)\n      }\n    }\n\n    // Keep from beginning to first miss\n    nodeStack = nodeStack.slice(0, pos)\n\n    // Add needed nodes\n    let currentNode = nodeStack[nodeStack.length - 1]\n    if (!currentNode) {\n      continue\n    }\n\n    for (const markKey of marksNeeded) {\n      const markDef = markDefs?.find((def) => def._key === markKey)\n      const markType = markDef ? markDef._type : markKey\n      const node: ToolkitNestedPortableTextSpan<M> = {\n        _type: '@span',\n        _key: span._key,\n        children: [],\n        markDef,\n        markType,\n        markKey,\n      }\n\n      currentNode.children.push(node)\n      nodeStack.push(node)\n      currentNode = node\n    }\n\n    // Split at newlines to make individual line chunks, but keep newline\n    // characters as individual elements in the array. We use these characters\n    // in the span serializer to trigger hard-break rendering\n    if (isPortableTextSpan(span)) {\n      const lines = span.text.split('\\n')\n      for (let line = lines.length; line-- > 1; ) {\n        lines.splice(line, 0, '\\n')\n      }\n\n      currentNode.children = currentNode.children.concat(\n        lines.map((text) => ({_type: '@text', text})),\n      )\n    } else {\n      // This is some other inline object, not a text span\n      currentNode.children = currentNode.children.concat(span)\n    }\n  }\n\n  return rootNode.children\n}\n","import type {PortableTextBlock, PortableTextListItemBlock, TypedObject} from '@portabletext/types'\n\nimport type {\n  ToolkitListNestMode,\n  ToolkitPortableTextDirectList,\n  ToolkitPortableTextHtmlList,\n  ToolkitPortableTextList,\n  ToolkitPortableTextListItem,\n} from './types'\n\nimport {\n  isPortableTextListItemBlock,\n  isPortableTextSpan,\n  isPortableTextToolkitList,\n} from './asserters'\n\nexport type ToolkitNestListsOutputNode<T> =\n  | T\n  | ToolkitPortableTextHtmlList\n  | ToolkitPortableTextDirectList\n\n/**\n * Takes an array of blocks and returns an array of nodes optimized for rendering in HTML-like\n * environment, where lists are nested inside of eachother instead of appearing \"flat\" as in\n * native Portable Text data structures.\n *\n * Note that the list node is not a native Portable Text node type, and thus is represented\n * using the {@link ToolkitPortableTextList | `@list`} type name (`{_type: '@list'}`).\n *\n * The nesting can be configured in two modes:\n *\n * - `direct`: deeper list nodes will appear as a direct child of the parent list\n * - `html`, deeper list nodes will appear as a child of the last _list item_ in the parent list\n *\n * When using `direct`, all list nodes will be of type {@link ToolkitPortableTextDirectList},\n * while with `html` they will be of type {@link ToolkitPortableTextHtmlList}\n *\n * These modes are available as {@link LIST_NEST_MODE_HTML} and {@link LIST_NEST_MODE_DIRECT}.\n *\n * @param blocks - Array of Portable Text blocks and other arbitrary types\n * @param mode - Mode to use for nesting, `direct` or `html`\n * @returns Array of potentially nested nodes optimized for rendering\n */\nexport function nestLists<T extends TypedObject = PortableTextBlock | TypedObject>(\n  blocks: T[],\n  mode: 'direct',\n): (T | ToolkitPortableTextDirectList)[]\nexport function nestLists<T extends TypedObject = PortableTextBlock | TypedObject>(\n  blocks: T[],\n  mode: 'html',\n): (T | ToolkitPortableTextHtmlList)[]\nexport function nestLists<T extends TypedObject = PortableTextBlock | TypedObject>(\n  blocks: T[],\n  mode: 'direct' | 'html',\n): (T | ToolkitPortableTextHtmlList | ToolkitPortableTextDirectList)[]\nexport function nestLists<T extends TypedObject = PortableTextBlock | TypedObject>(\n  blocks: T[],\n  mode: ToolkitListNestMode,\n): ToolkitNestListsOutputNode<T>[] {\n  const tree: ToolkitNestListsOutputNode<T>[] = []\n  let currentList: ToolkitPortableTextList | undefined\n\n  for (let i = 0; i < blocks.length; i++) {\n    const block = blocks[i]\n    if (!block) {\n      continue\n    }\n\n    if (!isPortableTextListItemBlock(block)) {\n      tree.push(block)\n      currentList = undefined\n      continue\n    }\n\n    // Start of a new list?\n    if (!currentList) {\n      currentList = listFromBlock(block, i, mode)\n      tree.push(currentList)\n      continue\n    }\n\n    // New list item within same list?\n    if (blockMatchesList(block, currentList)) {\n      currentList.children.push(block)\n      continue\n    }\n\n    // Different list props, are we going deeper?\n    if ((block.level || 1) > currentList.level) {\n      const newList = listFromBlock(block, i, mode)\n\n      if (mode === 'html') {\n        // Because HTML is kinda weird, nested lists needs to be nested within list items.\n        // So while you would think that we could populate the parent list with a new sub-list,\n        // we actually have to target the last list element (child) of the parent.\n        // However, at this point we need to be very careful - simply pushing to the list of children\n        // will mutate the input, and we don't want to blindly clone the entire tree.\n\n        // Clone the last child while adding our new list as the last child of it\n        const lastListItem = currentList.children[\n          currentList.children.length - 1\n        ] as ToolkitPortableTextListItem\n\n        const newLastChild: ToolkitPortableTextListItem = {\n          ...lastListItem,\n          children: [...lastListItem.children, newList],\n        }\n\n        // Swap the last child\n        currentList.children[currentList.children.length - 1] = newLastChild\n      } else {\n        ;(currentList as ToolkitPortableTextDirectList).children.push(\n          newList as ToolkitPortableTextDirectList,\n        )\n      }\n\n      // Set the newly created, deeper list as the current\n      currentList = newList\n      continue\n    }\n\n    // Different list props, are we going back up the tree?\n    if ((block.level || 1) < currentList.level) {\n      // Current list has ended, and we need to hook up with a parent of the same level and type\n      const matchingBranch = tree[tree.length - 1]\n      const match = matchingBranch && findListMatching(matchingBranch, block)\n      if (match) {\n        currentList = match\n        currentList.children.push(block)\n        continue\n      }\n\n      // Similar parent can't be found, assume new list\n      currentList = listFromBlock(block, i, mode)\n      tree.push(currentList)\n      continue\n    }\n\n    // Different list props, different list style?\n    if (block.listItem !== currentList.listItem) {\n      const matchingBranch = tree[tree.length - 1]\n      const match = matchingBranch && findListMatching(matchingBranch, {level: block.level || 1})\n      if (match && match.listItem === block.listItem) {\n        currentList = match\n        currentList.children.push(block)\n        continue\n      } else {\n        currentList = listFromBlock(block, i, mode)\n        tree.push(currentList)\n        continue\n      }\n    }\n\n    // oxlint-disable-next-line no-console\n    console.warn('Unknown state encountered for block', block)\n    tree.push(block)\n  }\n\n  return tree\n}\n\nfunction blockMatchesList(block: PortableTextBlock, list: ToolkitPortableTextList) {\n  return (block.level || 1) === list.level && block.listItem === list.listItem\n}\n\nfunction listFromBlock(\n  block: PortableTextListItemBlock,\n  index: number,\n  mode: ToolkitListNestMode,\n): ToolkitPortableTextList {\n  return {\n    _type: '@list',\n    _key: `${block._key || `${index}`}-parent`,\n    mode,\n    level: block.level || 1,\n    listItem: block.listItem,\n    children: [block],\n  }\n}\n\nfunction findListMatching<T extends TypedObject | PortableTextBlock>(\n  rootNode: T,\n  matching: Partial<PortableTextListItemBlock>,\n): ToolkitPortableTextList | undefined {\n  const level = matching.level || 1\n  const style = matching.listItem || 'normal'\n  const filterOnType = typeof matching.listItem === 'string'\n  if (\n    isPortableTextToolkitList(rootNode) &&\n    (rootNode.level || 1) === level &&\n    filterOnType &&\n    (rootNode.listItem || 'normal') === style\n  ) {\n    return rootNode\n  }\n\n  if (!('children' in rootNode)) {\n    return undefined\n  }\n\n  const node = rootNode.children[rootNode.children.length - 1]\n  return node && !isPortableTextSpan(node) ? findListMatching(node, matching) : undefined\n}\n","import type {ToolkitNestedPortableTextSpan} from './types'\n\nimport {isPortableTextToolkitSpan, isPortableTextToolkitTextNode} from './asserters'\n\n/**\n * Returns the plain-text representation of a\n * {@link ToolkitNestedPortableTextSpan | toolkit-specific Portable Text span}.\n *\n * Useful if you have a subset of nested nodes and want the text from just those,\n * instead of for the entire Portable Text block.\n *\n * @param span - Span node to get text from (Portable Text toolkit specific type)\n * @returns The plain-text version of the span\n */\nexport function spanToPlainText(span: ToolkitNestedPortableTextSpan): string {\n  let text = ''\n  span.children.forEach((current) => {\n    if (isPortableTextToolkitTextNode(current)) {\n      text += current.text\n    } else if (isPortableTextToolkitSpan(current)) {\n      text += spanToPlainText(current)\n    }\n  })\n  return text\n}\n","import type {ArbitraryTypedObject, PortableTextBlock} from '@portabletext/types'\n\nimport {isPortableTextBlock, isPortableTextSpan} from './asserters'\n\nconst leadingSpace = /^\\s/\nconst trailingSpace = /\\s$/\n\n/**\n * Takes a Portable Text block (or an array of them) and returns the text value\n * of all the Portable Text span nodes. Adds whitespace when encountering inline,\n * non-span nodes to ensure text flow is optimal.\n *\n * Note that this only accounts for regular Portable Text blocks - any text inside\n * custom content types are not included in the output.\n *\n * @param block - Single block or an array of blocks to extract text from\n * @returns The plain-text content of the blocks\n */\nexport function toPlainText(\n  block: PortableTextBlock | ArbitraryTypedObject[] | PortableTextBlock[],\n): string {\n  const blocks = Array.isArray(block) ? block : [block]\n  let text = ''\n\n  blocks.forEach((current, index) => {\n    if (!isPortableTextBlock(current)) {\n      return\n    }\n\n    let pad = false\n    current.children.forEach((span) => {\n      if (isPortableTextSpan(span)) {\n        // If the previous element was a non-span, and we have no natural whitespace\n        // between the previous and the next span, insert it to give the spans some\n        // room to breathe. However, don't do so if this is the first span.\n        text += pad && text && !trailingSpace.test(text) && !leadingSpace.test(span.text) ? ' ' : ''\n        text += span.text\n        pad = false\n      } else {\n        pad = true\n      }\n    })\n\n    if (index !== blocks.length - 1) {\n      text += '\\n\\n'\n    }\n  })\n\n  return text\n}\n","import type {\n  ArbitraryTypedObject,\n  PortableTextListItemBlock,\n  PortableTextMarkDefinition,\n  PortableTextSpan,\n} from '@portabletext/types'\n\n/**\n * List nesting mode for HTML, see the {@link nestLists | `nestLists()` function}\n */\nexport const LIST_NEST_MODE_HTML = 'html'\n\n/**\n * List nesting mode for direct, nested lists, see the {@link nestLists | `nestLists()` function}\n */\nexport const LIST_NEST_MODE_DIRECT = 'direct'\n\n/**\n * List nesting mode, see the {@link nestLists | `nestLists()` function}\n */\nexport type ToolkitListNestMode = 'html' | 'direct'\n\n/**\n * Toolkit-specific type representing a nested list\n *\n * See the `nestLists()` function for more info\n */\nexport type ToolkitPortableTextList = ToolkitPortableTextHtmlList | ToolkitPortableTextDirectList\n\n/**\n * Toolkit-specific type representing a nested list in HTML mode, where deeper lists are nested\n * inside of the _list items_, eg `<ul><li>Some text<ul><li>Deeper</li></ul></li></ul>`\n */\nexport interface ToolkitPortableTextHtmlList {\n  /**\n   * Type name, prefixed with `@` to signal that this is a toolkit-specific node.\n   */\n  _type: '@list'\n\n  /**\n   * Unique key for this list (within its parent)\n   */\n  _key: string\n\n  /**\n   * List mode, signaling that list nodes will appear as children of the _list items_\n   */\n  mode: 'html'\n\n  /**\n   * Level/depth of this list node (starts at `1`)\n   */\n  level: number\n\n  /**\n   * Style of this list item (`bullet`, `number` are common values, but can be customized)\n   */\n  listItem: string\n\n  /**\n   * Child nodes of this list - toolkit-specific list items which can themselves hold deeper lists\n   */\n  children: ToolkitPortableTextListItem[]\n}\n\n/**\n * Toolkit-specific type representing a nested list in \"direct\" mode, where deeper lists are nested\n * inside of the lists children, alongside other blocks.\n */\nexport interface ToolkitPortableTextDirectList {\n  /**\n   * Type name, prefixed with `@` to signal that this is a toolkit-specific node.\n   */\n  _type: '@list'\n\n  /**\n   * Unique key for this list (within its parent)\n   */\n  _key: string\n\n  /**\n   * List mode, signaling that list nodes can appear as direct children\n   */\n  mode: 'direct'\n\n  /**\n   * Level/depth of this list node (starts at `1`)\n   */\n  level: number\n\n  /**\n   * Style of this list item (`bullet`, `number` are common values, but can be customized)\n   */\n  listItem: string\n\n  /**\n   * Child nodes of this list - either portable text list items, or another, deeper list\n   */\n  children: (PortableTextListItemBlock | ToolkitPortableTextDirectList)[]\n}\n\n/**\n * Toolkit-specific type representing a list item block, but where the children can be another list\n */\nexport interface ToolkitPortableTextListItem extends PortableTextListItemBlock<\n  PortableTextMarkDefinition,\n  PortableTextSpan | ToolkitPortableTextList\n> {}\n\n/**\n * Toolkit-specific type representing a text node, used when nesting spans.\n *\n * See the {@link buildMarksTree | `buildMarksTree()` function}\n */\nexport interface ToolkitTextNode {\n  /**\n   * Type name, prefixed with `@` to signal that this is a toolkit-specific node.\n   */\n  _type: '@text'\n\n  /**\n   * The actual string value of the text node\n   */\n  text: string\n}\n\n/**\n * Toolkit-specific type representing a portable text span that can hold other spans.\n * In this type, each span only has a single mark, instead of an array of them.\n */\nexport interface ToolkitNestedPortableTextSpan<\n  M extends PortableTextMarkDefinition = PortableTextMarkDefinition,\n> {\n  /**\n   * Type name, prefixed with `@` to signal that this is a toolkit-specific node.\n   */\n  _type: '@span'\n\n  /**\n   * Unique key for this span\n   */\n  _key?: string\n\n  /**\n   * Holds the value (definition) of the mark in the case of annotations.\n   * `undefined` if the mark is a decorator (strong, em or similar).\n   */\n  markDef?: M\n\n  /**\n   * The key of the mark definition (in the case of annotations).\n   * `undefined` if the mark is a decorator (strong, em or similar).\n   */\n  markKey?: string\n\n  /**\n   * Type of the mark. For annotations, this is the `_type` property of the value.\n   * For decorators, it will hold the name of the decorator (strong, em or similar).\n   */\n  markType: string\n\n  /**\n   * Child nodes of this span. Can be toolkit-specific text nodes, nested spans\n   * or any inline object type.\n   */\n  children: (ToolkitTextNode | ToolkitNestedPortableTextSpan | ArbitraryTypedObject)[]\n}\n"],"names":["occurences: Record<string, number>","rootNode: ToolkitNestedPortableTextSpan<M>","nodeStack: ToolkitNestedPortableTextSpan<M>[]","node: ToolkitNestedPortableTextSpan<M>","tree: ToolkitNestListsOutputNode<T>[]","currentList: ToolkitPortableTextList | undefined","newLastChild: ToolkitPortableTextListItem"],"mappings":"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"}},
    {"offset": {"line": 226, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@portabletext/react/dist/index.js","sources":["file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/react/src/components/list.tsx","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/react/src/components/marks.tsx","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/react/src/warnings.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/react/src/components/unknown.tsx","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/react/src/components/defaults.tsx","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/react/src/components/merge.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/react/src/react-portable-text.tsx"],"sourcesContent":["import type {PortableTextListComponent, PortableTextListItemComponent} from '../types'\n\nexport const defaultLists: Record<'number' | 'bullet', PortableTextListComponent> = {\n  number: ({children}) => <ol>{children}</ol>,\n  bullet: ({children}) => <ul>{children}</ul>,\n}\n\nexport const DefaultListItem: PortableTextListItemComponent = ({children}) => <li>{children}</li>\n","import type {TypedObject} from '@portabletext/types'\n\nimport type {PortableTextMarkComponent} from '../types'\n\ninterface DefaultLink extends TypedObject {\n  _type: 'link'\n  href: string\n}\n\nconst link: PortableTextMarkComponent<DefaultLink> = ({children, value}) => (\n  <a href={value?.href}>{children}</a>\n)\n\nconst underlineStyle = {textDecoration: 'underline'}\n\nexport const defaultMarks: Record<string, PortableTextMarkComponent | undefined> = {\n  em: ({children}) => <em>{children}</em>,\n  strong: ({children}) => <strong>{children}</strong>,\n  code: ({children}) => <code>{children}</code>,\n  underline: ({children}) => <span style={underlineStyle}>{children}</span>,\n  'strike-through': ({children}) => <del>{children}</del>,\n  link,\n}\n","const getTemplate = (type: string, prop: string): string =>\n  `[@portabletext/react] Unknown ${type}, specify a component for it in the \\`components.${prop}\\` prop`\n\nexport const unknownTypeWarning = (typeName: string): string =>\n  getTemplate(`block type \"${typeName}\"`, 'types')\n\nexport const unknownMarkWarning = (markType: string): string =>\n  getTemplate(`mark type \"${markType}\"`, 'marks')\n\nexport const unknownBlockStyleWarning = (blockStyle: string): string =>\n  getTemplate(`block style \"${blockStyle}\"`, 'block')\n\nexport const unknownListStyleWarning = (listStyle: string): string =>\n  getTemplate(`list style \"${listStyle}\"`, 'list')\n\nexport const unknownListItemStyleWarning = (listStyle: string): string =>\n  getTemplate(`list item style \"${listStyle}\"`, 'listItem')\n\nexport function printWarning(message: string): void {\n  // oxlint-disable-next-line no-console\n  console.warn(message)\n}\n","import type {PortableTextReactComponents} from '../types'\n\nimport {unknownTypeWarning} from '../warnings'\n\nconst hidden = {display: 'none'}\n\nexport const DefaultUnknownType: PortableTextReactComponents['unknownType'] = ({\n  value,\n  isInline,\n}) => {\n  const warning = unknownTypeWarning(value._type)\n  return isInline ? <span style={hidden}>{warning}</span> : <div style={hidden}>{warning}</div>\n}\n\nexport const DefaultUnknownMark: PortableTextReactComponents['unknownMark'] = ({\n  markType,\n  children,\n}) => {\n  return <span className={`unknown__pt__mark__${markType}`}>{children}</span>\n}\n\nexport const DefaultUnknownBlockStyle: PortableTextReactComponents['unknownBlockStyle'] = ({\n  children,\n}) => {\n  return <p>{children}</p>\n}\n\nexport const DefaultUnknownList: PortableTextReactComponents['unknownList'] = ({children}) => {\n  return <ul>{children}</ul>\n}\n\nexport const DefaultUnknownListItem: PortableTextReactComponents['unknownListItem'] = ({\n  children,\n}) => {\n  return <li>{children}</li>\n}\n","import type {PortableTextBlockStyle} from '@portabletext/types'\nimport type {JSX} from 'react'\n\nimport type {PortableTextBlockComponent, PortableTextReactComponents} from '../types'\n\nimport {DefaultListItem, defaultLists} from './list'\nimport {defaultMarks} from './marks'\nimport {\n  DefaultUnknownBlockStyle,\n  DefaultUnknownList,\n  DefaultUnknownListItem,\n  DefaultUnknownMark,\n  DefaultUnknownType,\n} from './unknown'\n\nexport const DefaultHardBreak = (): JSX.Element => <br />\n\nexport const defaultBlockStyles: Record<\n  PortableTextBlockStyle,\n  PortableTextBlockComponent | undefined\n> = {\n  normal: ({children}) => <p>{children}</p>,\n  blockquote: ({children}) => <blockquote>{children}</blockquote>,\n  h1: ({children}) => <h1>{children}</h1>,\n  h2: ({children}) => <h2>{children}</h2>,\n  h3: ({children}) => <h3>{children}</h3>,\n  h4: ({children}) => <h4>{children}</h4>,\n  h5: ({children}) => <h5>{children}</h5>,\n  h6: ({children}) => <h6>{children}</h6>,\n}\n\nexport const defaultComponents: PortableTextReactComponents = {\n  types: {},\n\n  block: defaultBlockStyles,\n  marks: defaultMarks,\n  list: defaultLists,\n  listItem: DefaultListItem,\n  hardBreak: DefaultHardBreak,\n\n  unknownType: DefaultUnknownType,\n  unknownMark: DefaultUnknownMark,\n  unknownList: DefaultUnknownList,\n  unknownListItem: DefaultUnknownListItem,\n  unknownBlockStyle: DefaultUnknownBlockStyle,\n}\n","import type {PortableTextComponents, PortableTextReactComponents} from '../types'\n\nexport function mergeComponents(\n  parent: PortableTextReactComponents,\n  overrides: PortableTextComponents,\n): PortableTextReactComponents {\n  const {\n    block: _block,\n    list: _list,\n    listItem: _listItem,\n    marks: _marks,\n    types: _types,\n    ...rest\n  } = overrides\n  // @todo figure out how to not `as ...` these\n  return {\n    ...parent,\n    block: mergeDeeply(parent, overrides, 'block') as PortableTextReactComponents['block'],\n    list: mergeDeeply(parent, overrides, 'list') as PortableTextReactComponents['list'],\n    listItem: mergeDeeply(parent, overrides, 'listItem') as PortableTextReactComponents['listItem'],\n    marks: mergeDeeply(parent, overrides, 'marks') as PortableTextReactComponents['marks'],\n    types: mergeDeeply(parent, overrides, 'types') as PortableTextReactComponents['types'],\n    ...rest,\n  }\n}\n\nfunction mergeDeeply(\n  parent: PortableTextReactComponents,\n  overrides: PortableTextComponents,\n  key: 'block' | 'list' | 'listItem' | 'marks' | 'types',\n): PortableTextReactComponents[typeof key] {\n  const override = overrides[key]\n  const parentVal = parent[key]\n\n  if (typeof override === 'function') {\n    return override\n  }\n\n  if (override && typeof parentVal === 'function') {\n    return override\n  }\n\n  if (override) {\n    return {...parentVal, ...override} as PortableTextReactComponents[typeof key]\n  }\n\n  return parentVal\n}\n","import type {ToolkitNestedPortableTextSpan, ToolkitTextNode} from '@portabletext/toolkit'\nimport type {PortableTextBlock, PortableTextListItemBlock, TypedObject} from '@portabletext/types'\n\nimport {\n  buildMarksTree,\n  isPortableTextBlock,\n  isPortableTextListItemBlock,\n  isPortableTextToolkitList,\n  isPortableTextToolkitSpan,\n  isPortableTextToolkitTextNode,\n  LIST_NEST_MODE_HTML,\n  nestLists,\n  spanToPlainText,\n} from '@portabletext/toolkit'\nimport {type JSX, type ReactNode, useMemo} from 'react'\n\nimport type {\n  MissingComponentHandler,\n  NodeRenderer,\n  PortableTextProps,\n  PortableTextReactComponents,\n  ReactPortableTextList,\n  Serializable,\n  SerializedBlock,\n} from './types'\n\nimport {defaultComponents} from './components/defaults'\nimport {mergeComponents} from './components/merge'\nimport {\n  printWarning,\n  unknownBlockStyleWarning,\n  unknownListItemStyleWarning,\n  unknownListStyleWarning,\n  unknownMarkWarning,\n  unknownTypeWarning,\n} from './warnings'\n\nexport function PortableText<B extends TypedObject = PortableTextBlock>({\n  value: input,\n  components: componentOverrides,\n  listNestingMode,\n  onMissingComponent: missingComponentHandler = printWarning,\n}: PortableTextProps<B>): JSX.Element {\n  const handleMissingComponent = missingComponentHandler || noop\n  const blocks = Array.isArray(input) ? input : [input]\n  const nested = nestLists(blocks, listNestingMode || LIST_NEST_MODE_HTML)\n\n  const components = useMemo(() => {\n    return componentOverrides\n      ? mergeComponents(defaultComponents, componentOverrides)\n      : defaultComponents\n  }, [componentOverrides])\n\n  const renderNode = useMemo(\n    () => getNodeRenderer(components, handleMissingComponent),\n    [components, handleMissingComponent],\n  )\n  const rendered = nested.map((node, index) =>\n    renderNode({node: node, index, isInline: false, renderNode}),\n  )\n\n  return <>{rendered}</>\n}\n\nconst getNodeRenderer = (\n  components: PortableTextReactComponents,\n  handleMissingComponent: MissingComponentHandler,\n): NodeRenderer => {\n  function renderNode<N extends TypedObject>(options: Serializable<N>): ReactNode {\n    const {node, index, isInline} = options\n    const key = node._key || `node-${index}`\n\n    if (isPortableTextToolkitList(node)) {\n      return renderList(node, index, key)\n    }\n\n    if (isPortableTextListItemBlock(node)) {\n      return renderListItem(node, index, key)\n    }\n\n    if (isPortableTextToolkitSpan(node)) {\n      return renderSpan(node, index, key)\n    }\n\n    if (hasCustomComponentForNode(node)) {\n      return renderCustomBlock(node, index, key, isInline)\n    }\n\n    if (isPortableTextBlock(node)) {\n      return renderBlock(node, index, key, isInline)\n    }\n\n    if (isPortableTextToolkitTextNode(node)) {\n      return renderText(node, key)\n    }\n\n    return renderUnknownType(node, index, key, isInline)\n  }\n\n  function hasCustomComponentForNode(node: TypedObject): boolean {\n    return node._type in components.types\n  }\n\n  function renderListItem(node: PortableTextListItemBlock, index: number, key: string) {\n    const tree = serializeBlock({node, index, isInline: false, renderNode})\n    const renderer = components.listItem\n    const handler = typeof renderer === 'function' ? renderer : renderer[node.listItem]\n    const Li = handler || components.unknownListItem\n\n    if (Li === components.unknownListItem) {\n      const style = node.listItem || 'bullet'\n      handleMissingComponent(unknownListItemStyleWarning(style), {\n        type: style,\n        nodeType: 'listItemStyle',\n      })\n    }\n\n    let children = tree.children\n    if (node.style && node.style !== 'normal') {\n      // Wrap any other style in whatever the block serializer says to use\n      const {listItem: _listItem, ...blockNode} = node\n      children = renderNode({\n        node: blockNode,\n        index,\n        isInline: false,\n        renderNode,\n      })\n    }\n\n    return (\n      <Li key={key} value={node} index={index} isInline={false} renderNode={renderNode}>\n        {children}\n      </Li>\n    )\n  }\n\n  function renderList(node: ReactPortableTextList, index: number, key: string) {\n    const children = node.children.map((child, childIndex) =>\n      renderNode({\n        node: child._key ? child : {...child, _key: `li-${index}-${childIndex}`},\n        index: childIndex,\n        isInline: false,\n        renderNode,\n      }),\n    )\n\n    const component = components.list\n    const handler = typeof component === 'function' ? component : component[node.listItem]\n    const List = handler || components.unknownList\n\n    if (List === components.unknownList) {\n      const style = node.listItem || 'bullet'\n      handleMissingComponent(unknownListStyleWarning(style), {\n        nodeType: 'listStyle',\n        type: style,\n      })\n    }\n\n    return (\n      <List key={key} value={node} index={index} isInline={false} renderNode={renderNode}>\n        {children}\n      </List>\n    )\n  }\n\n  function renderSpan(node: ToolkitNestedPortableTextSpan, _index: number, key: string) {\n    const {markDef, markType, markKey} = node\n    const Span = components.marks[markType] || components.unknownMark\n    const children = node.children.map((child, childIndex) =>\n      renderNode({\n        node: child,\n        index: childIndex,\n        isInline: true,\n        renderNode,\n      }),\n    )\n\n    if (Span === components.unknownMark) {\n      handleMissingComponent(unknownMarkWarning(markType), {\n        nodeType: 'mark',\n        type: markType,\n      })\n    }\n\n    return (\n      <Span\n        key={key}\n        text={spanToPlainText(node)}\n        value={markDef}\n        markType={markType}\n        markKey={markKey}\n        renderNode={renderNode}\n      >\n        {children}\n      </Span>\n    )\n  }\n\n  function renderBlock(node: PortableTextBlock, index: number, key: string, isInline: boolean) {\n    const {_key, ...props} = serializeBlock({\n      node,\n      index,\n      isInline,\n      renderNode,\n    })\n    const style = props.node.style || 'normal'\n    const handler =\n      typeof components.block === 'function' ? components.block : components.block[style]\n    const Block = handler || components.unknownBlockStyle\n\n    if (Block === components.unknownBlockStyle) {\n      handleMissingComponent(unknownBlockStyleWarning(style), {\n        nodeType: 'blockStyle',\n        type: style,\n      })\n    }\n\n    return <Block key={key} {...props} value={props.node} renderNode={renderNode} />\n  }\n\n  function renderText(node: ToolkitTextNode, key: string) {\n    if (node.text === '\\n') {\n      const HardBreak = components.hardBreak\n      return HardBreak ? <HardBreak key={key} /> : '\\n'\n    }\n\n    return node.text\n  }\n\n  function renderUnknownType(node: TypedObject, index: number, key: string, isInline: boolean) {\n    const nodeOptions = {\n      value: node,\n      isInline,\n      index,\n      renderNode,\n    }\n\n    handleMissingComponent(unknownTypeWarning(node._type), {\n      nodeType: 'block',\n      type: node._type,\n    })\n\n    const UnknownType = components.unknownType\n    return <UnknownType key={key} {...nodeOptions} />\n  }\n\n  function renderCustomBlock(node: TypedObject, index: number, key: string, isInline: boolean) {\n    const nodeOptions = {\n      value: node,\n      isInline,\n      index,\n      renderNode,\n    }\n\n    const Node = components.types[node._type]\n    return Node ? <Node key={key} {...nodeOptions} /> : null\n  }\n\n  return renderNode\n}\n\nfunction serializeBlock(options: Serializable<PortableTextBlock>): SerializedBlock {\n  const {node, index, isInline, renderNode} = options\n  const tree = buildMarksTree(node)\n  const children = tree.map((child, i) =>\n    renderNode({node: child, isInline: true, index: i, renderNode}),\n  )\n\n  return {\n    _key: node._key || `block-${index}`,\n    children,\n    index,\n    isInline,\n    node,\n  }\n}\n\nfunction noop() {\n  // Intentional noop\n}\n"],"names":["defaultLists: Record<'number' | 'bullet', PortableTextListComponent>","DefaultListItem: PortableTextListItemComponent","link: PortableTextMarkComponent<DefaultLink>","defaultMarks: Record<string, PortableTextMarkComponent | undefined>","DefaultUnknownType: PortableTextReactComponents['unknownType']","DefaultUnknownMark: PortableTextReactComponents['unknownMark']","DefaultUnknownBlockStyle: PortableTextReactComponents['unknownBlockStyle']","DefaultUnknownList: PortableTextReactComponents['unknownList']","DefaultUnknownListItem: PortableTextReactComponents['unknownListItem']","defaultBlockStyles: Record<\n  PortableTextBlockStyle,\n  PortableTextBlockComponent | undefined\n>","defaultComponents: PortableTextReactComponents"],"mappings":"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"}},
    {"offset": {"line": 526, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@portabletext/schema/dist/index.js","sources":["file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/schema/src/compile-schema.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/schema/src/define-schema.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/schema/src/types.ts"],"sourcesContent":["import type {SchemaDefinition} from './define-schema'\nimport type {FieldDefinition, Schema} from './schema'\n\n/**\n * @public\n */\nexport function compileSchema(definition: SchemaDefinition): Schema {\n  const styles = (definition.styles ?? []).map((style) => ({\n    ...style,\n    value: style.name,\n  }))\n\n  const blockFields: Array<FieldDefinition> = []\n\n  if (definition.block?.fields) {\n    for (const field of definition.block.fields) {\n      if (\n        field.name === '_type' ||\n        field.name === '_key' ||\n        field.name === 'children' ||\n        field.name === 'markDefs' ||\n        field.name === 'style' ||\n        field.name === 'listItem' ||\n        field.name === 'level'\n      ) {\n        console.warn(\n          `\"${field.name}\" is a reserved field name on Portable Text blocks`,\n        )\n        continue\n      }\n\n      blockFields.push(field)\n    }\n  }\n\n  return {\n    block: {\n      name: definition.block?.name ?? 'block',\n      ...(blockFields.length > 0 ? {fields: blockFields} : {}),\n    },\n    span: {\n      name: 'span',\n    },\n    styles: !styles.some((style) => style.value === 'normal')\n      ? [{value: 'normal', name: 'normal', title: 'Normal'}, ...styles]\n      : styles,\n    lists: (definition.lists ?? []).map((list) => ({\n      ...list,\n      value: list.name,\n    })),\n    decorators: (definition.decorators ?? []).map((decorator) => ({\n      ...decorator,\n      value: decorator.name,\n    })),\n    annotations: (definition.annotations ?? []).map((annotation) => ({\n      ...annotation,\n      fields: annotation.fields ?? [],\n    })),\n    blockObjects: (definition.blockObjects ?? []).map((blockObject) => ({\n      ...blockObject,\n      fields: blockObject.fields ?? [],\n    })),\n    inlineObjects: (definition.inlineObjects ?? []).map((inlineObject) => ({\n      ...inlineObject,\n      fields: inlineObject.fields ?? [],\n    })),\n  }\n}\n","import type {BaseDefinition, FieldDefinition} from './schema'\n\n/**\n * @public\n */\nexport type SchemaDefinition = {\n  block?: {\n    name?: string\n    fields?: ReadonlyArray<FieldDefinition>\n  }\n  styles?: ReadonlyArray<StyleDefinition>\n  lists?: ReadonlyArray<ListDefinition>\n  decorators?: ReadonlyArray<DecoratorDefinition>\n  annotations?: ReadonlyArray<AnnotationDefinition>\n  blockObjects?: ReadonlyArray<BlockObjectDefinition>\n  inlineObjects?: ReadonlyArray<InlineObjectDefinition>\n}\n\n/**\n * @public\n * A helper wrapper that adds editor support, such as autocomplete and type checking, for a schema definition.\n * @example\n * ```ts\n * import { defineSchema } from '@portabletext/editor'\n *\n * const schemaDefinition = defineSchema({\n *  decorators: [{name: 'strong'}, {name: 'em'}, {name: 'underline'}],\n *  annotations: [{name: 'link'}],\n *  styles: [\n *    {name: 'normal'},\n *    {name: 'h1'},\n *    {name: 'h2'},\n *    {name: 'h3'},\n *    {name: 'blockquote'},\n *  ],\n *  lists: [],\n *  inlineObjects: [],\n *  blockObjects: [],\n * }\n * ```\n */\nexport function defineSchema<const TSchemaDefinition extends SchemaDefinition>(\n  definition: TSchemaDefinition,\n): TSchemaDefinition {\n  return definition\n}\n\n/**\n * @public\n */\nexport type StyleDefinition<\n  TBaseDefinition extends BaseDefinition = BaseDefinition,\n> = TBaseDefinition\n\n/**\n * @public\n */\nexport type ListDefinition<\n  TBaseDefinition extends BaseDefinition = BaseDefinition,\n> = TBaseDefinition\n\n/**\n * @public\n */\nexport type DecoratorDefinition<\n  TBaseDefinition extends BaseDefinition = BaseDefinition,\n> = TBaseDefinition\n\n/**\n * @public\n */\nexport type AnnotationDefinition<\n  TBaseDefinition extends BaseDefinition = BaseDefinition,\n> = TBaseDefinition & {\n  fields?: ReadonlyArray<FieldDefinition>\n}\n\n/**\n * @public\n */\nexport type BlockObjectDefinition<\n  TBaseDefinition extends BaseDefinition = BaseDefinition,\n> = TBaseDefinition & {\n  fields?: ReadonlyArray<FieldDefinition>\n}\n\n/**\n * @public\n */\nexport type InlineObjectDefinition<\n  TBaseDefinition extends BaseDefinition = BaseDefinition,\n> = TBaseDefinition & {\n  fields?: ReadonlyArray<FieldDefinition>\n}\n","import type {Schema} from './schema'\n\n/**\n * @public\n */\nexport interface TypedObject {\n  [key: string]: unknown\n  _type: string\n}\n\n/**\n * @public\n */\nexport function isTypedObject(object: unknown): object is TypedObject {\n  return isRecord(object) && typeof object._type === 'string'\n}\n\nfunction isRecord(value: unknown): value is Record<string, unknown> {\n  return !!value && (typeof value === 'object' || typeof value === 'function')\n}\n\n/**\n * @public\n */\nexport type PortableTextBlock = PortableTextTextBlock | PortableTextObject\n\n/**\n * @public\n */\nexport interface PortableTextTextBlock<\n  TChild = PortableTextSpan | PortableTextObject,\n> {\n  _type: string\n  _key: string\n  children: TChild[]\n  markDefs?: PortableTextObject[]\n  listItem?: string\n  style?: string\n  level?: number\n}\n\n/**\n * @public\n */\nexport function isTextBlock(\n  context: {schema: Schema},\n  block: unknown,\n): block is PortableTextTextBlock {\n  if (!isTypedObject(block)) {\n    return false\n  }\n\n  if (block._type !== context.schema.block.name) {\n    return false\n  }\n\n  if (!Array.isArray(block.children)) {\n    return false\n  }\n\n  return true\n}\n\n/**\n * @public\n */\nexport interface PortableTextSpan {\n  _key: string\n  _type: 'span'\n  text: string\n  marks?: string[]\n}\n\n/**\n * @public\n */\nexport function isSpan(\n  context: {schema: Schema},\n  child: unknown,\n): child is PortableTextSpan {\n  if (!isTypedObject(child)) {\n    return false\n  }\n\n  if (child._type !== context.schema.span.name) {\n    return false\n  }\n\n  if (typeof child.text !== 'string') {\n    return false\n  }\n\n  return true\n}\n\n/**\n * @public\n */\nexport interface PortableTextObject {\n  _type: string\n  _key: string\n  [other: string]: unknown\n}\n\n/**\n * @public\n */\nexport type PortableTextChild = PortableTextSpan | PortableTextObject\n\n/**\n * @public\n */\nexport interface PortableTextListBlock extends PortableTextTextBlock {\n  listItem: string\n  level: number\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 611, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@portabletext/sanity-bridge/dist/index.js","sources":["file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/sanity-bridge/src/portable-text-member-schema-types.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/sanity-bridge/src/portable-text-member-schema-types-to-schema.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/sanity-bridge/src/sanity-schema-to-portable-text-schema.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/sanity-bridge/src/key-generator.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/sanity-bridge/src/start-case.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/sanity-bridge/src/schema-definition-to-portable-text-member-schema-types.ts"],"sourcesContent":["import type {\n  ArraySchemaType,\n  BlockDecoratorDefinition,\n  BlockListDefinition,\n  BlockSchemaType,\n  BlockStyleDefinition,\n  ObjectSchemaType,\n  PortableTextBlock,\n  SchemaType,\n  SpanSchemaType,\n} from '@sanity/types'\n\n/**\n * @public\n * Sanity-specific schema types for Portable Text.\n */\nexport type PortableTextMemberSchemaTypes = {\n  annotations: (ObjectSchemaType & {i18nTitleKey?: string})[]\n  block: ObjectSchemaType\n  blockObjects: ObjectSchemaType[]\n  decorators: BlockDecoratorDefinition[]\n  inlineObjects: ObjectSchemaType[]\n  portableText: ArraySchemaType<PortableTextBlock>\n  span: ObjectSchemaType\n  styles: BlockStyleDefinition[]\n  lists: BlockListDefinition[]\n}\n\n/**\n * @public\n * Create Sanity-specific schema types for Portable Text from a Sanity array\n * schema type.\n */\nexport function createPortableTextMemberSchemaTypes(\n  portableTextType: ArraySchemaType<PortableTextBlock>,\n): PortableTextMemberSchemaTypes {\n  if (!portableTextType) {\n    throw new Error(\"Parameter 'portabletextType' missing (required)\")\n  }\n  const blockType = portableTextType.of?.find(findBlockType) as\n    | BlockSchemaType\n    | undefined\n  if (!blockType) {\n    throw new Error('Block type is not defined in this schema (required)')\n  }\n  const childrenField = blockType.fields?.find(\n    (field) => field.name === 'children',\n  ) as {type: ArraySchemaType} | undefined\n  if (!childrenField) {\n    throw new Error('Children field for block type found in schema (required)')\n  }\n  const ofType = childrenField.type.of\n  if (!ofType) {\n    throw new Error(\n      'Valid types for block children not found in schema (required)',\n    )\n  }\n  const spanType = ofType.find((memberType) => memberType.name === 'span') as\n    | ObjectSchemaType\n    | undefined\n  if (!spanType) {\n    throw new Error('Span type not found in schema (required)')\n  }\n  const inlineObjectTypes = (ofType.filter(\n    (memberType) => memberType.name !== 'span',\n  ) || []) as ObjectSchemaType[]\n  const blockObjectTypes = (portableTextType.of?.filter(\n    (field) => field.name !== blockType.name,\n  ) || []) as ObjectSchemaType[]\n  return {\n    styles: resolveEnabledStyles(blockType),\n    decorators: resolveEnabledDecorators(spanType),\n    lists: resolveEnabledListItems(blockType),\n    block: blockType,\n    span: spanType,\n    portableText: portableTextType,\n    inlineObjects: inlineObjectTypes,\n    blockObjects: blockObjectTypes,\n    annotations: (spanType as SpanSchemaType).annotations,\n  }\n}\n\nfunction resolveEnabledStyles(blockType: ObjectSchemaType) {\n  const styleField = blockType.fields?.find(\n    (btField) => btField.name === 'style',\n  )\n  if (!styleField) {\n    throw new Error(\n      \"A field with name 'style' is not defined in the block type (required).\",\n    )\n  }\n  const textStyles =\n    styleField.type.options?.list &&\n    styleField.type.options.list?.filter(\n      (style: {value: string}) => style.value,\n    )\n  if (!textStyles || textStyles.length === 0) {\n    throw new Error(\n      'The style fields need at least one style ' +\n        \"defined. I.e: {title: 'Normal', value: 'normal'}.\",\n    )\n  }\n  return textStyles\n}\n\nfunction resolveEnabledDecorators(spanType: ObjectSchemaType) {\n  return (spanType as any).decorators\n}\n\nfunction resolveEnabledListItems(blockType: ObjectSchemaType) {\n  const listField = blockType.fields?.find(\n    (btField) => btField.name === 'listItem',\n  )\n  if (!listField) {\n    throw new Error(\n      \"A field with name 'listItem' is not defined in the block type (required).\",\n    )\n  }\n  const listItems =\n    listField.type.options?.list &&\n    listField.type.options.list.filter((list: {value: string}) => list.value)\n  if (!listItems) {\n    throw new Error('The list field need at least to be an empty array')\n  }\n  return listItems\n}\n\nfunction findBlockType(type: SchemaType): BlockSchemaType | null {\n  if (type.type) {\n    return findBlockType(type.type)\n  }\n\n  if (type.name === 'block') {\n    return type as BlockSchemaType\n  }\n\n  return null\n}\n","import type {Schema} from '@portabletext/schema'\nimport type {PortableTextMemberSchemaTypes} from './portable-text-member-schema-types'\n\n/**\n * @public\n * Convert Sanity-specific schema types for Portable Text to a first-class\n * Portable Text schema.\n */\nexport function portableTextMemberSchemaTypesToSchema(\n  schema: PortableTextMemberSchemaTypes,\n): Schema {\n  return {\n    annotations: schema.annotations.map((annotation) => ({\n      name: annotation.name,\n      fields: annotation.fields.map((field) => ({\n        name: field.name,\n        type: field.type.jsonType,\n        title: field.type.title,\n      })),\n      title: annotation.title,\n    })),\n    block: {\n      name: schema.block.name,\n    },\n    blockObjects: schema.blockObjects.map((blockObject) => ({\n      name: blockObject.name,\n      fields: blockObject.fields.map((field) => ({\n        name: field.name,\n        type: field.type.jsonType,\n        title: field.type.title,\n      })),\n      title: blockObject.title,\n    })),\n    decorators: schema.decorators.map((decorator) => ({\n      name: decorator.value,\n      title: decorator.title,\n      value: decorator.value,\n    })),\n    inlineObjects: schema.inlineObjects.map((inlineObject) => ({\n      name: inlineObject.name,\n      fields: inlineObject.fields.map((field) => ({\n        name: field.name,\n        type: field.type.jsonType,\n        title: field.type.title,\n      })),\n      title: inlineObject.title,\n    })),\n    span: {\n      name: schema.span.name,\n    },\n    styles: schema.styles.map((style) => ({\n      name: style.value,\n      title: style.title,\n      value: style.value,\n    })),\n    lists: schema.lists.map((list) => ({\n      name: list.value,\n      title: list.title,\n      value: list.value,\n    })),\n  }\n}\n","import type {Schema} from '@portabletext/schema'\nimport {Schema as SanitySchema} from '@sanity/schema'\nimport {builtinTypes} from '@sanity/schema/_internal'\nimport type {ArrayDefinition, ArraySchemaType} from '@sanity/types'\nimport {createPortableTextMemberSchemaTypes} from './portable-text-member-schema-types'\nimport {portableTextMemberSchemaTypesToSchema} from './portable-text-member-schema-types-to-schema'\n\n/**\n * @public\n * Compile a Sanity schema to a Portable Text `Schema`.\n *\n * A Portable Text `Schema` is compatible with a Portable Text\n * `SchemaDefinition` and can be used as configuration for the Portable Text\n * Editor.\n *\n * @example\n * ```tsx\n * const schema = sanitySchemaToPortableTextSchema(sanitySchema)\n *\n * return (\n *   <EditorProvider\n *     initialConfig={{\n *       // ...\n *       schemaDefinition: schema,\n *     }}\n *   >\n *     // ...\n *   </EditorProvider>\n * ```\n */\nexport function sanitySchemaToPortableTextSchema(\n  sanitySchema: ArraySchemaType<unknown> | ArrayDefinition,\n): Schema {\n  const portableTextMemberSchemaTypes = createPortableTextMemberSchemaTypes(\n    sanitySchema.hasOwnProperty('jsonType')\n      ? sanitySchema\n      : compileType(sanitySchema),\n  )\n\n  return portableTextMemberSchemaTypesToSchema(portableTextMemberSchemaTypes)\n}\n\nfunction compileType(rawType: any) {\n  return SanitySchema.compile({\n    name: 'blockTypeSchema',\n    types: [rawType, ...builtinTypes],\n  }).get(rawType.name)\n}\n","export const keyGenerator = (): string => randomKey(12)\n\nconst getByteHexTable = (() => {\n  let table: any[]\n  return () => {\n    if (table) {\n      return table\n    }\n\n    table = []\n    for (let i = 0; i < 256; ++i) {\n      table[i] = (i + 0x100).toString(16).slice(1)\n    }\n    return table\n  }\n})()\n\n// WHATWG crypto RNG - https://w3c.github.io/webcrypto/Overview.html\nfunction whatwgRNG(length = 16) {\n  const rnds8 = new Uint8Array(length)\n  crypto.getRandomValues(rnds8)\n  return rnds8\n}\n\nfunction randomKey(length?: number): string {\n  const table = getByteHexTable()\n  return whatwgRNG(length)\n    .reduce((str, n) => str + table[n], '')\n    .slice(0, length)\n}\n","export function startCase(str: string): string {\n  return (\n    str\n      // Insert space before uppercase letters in camelCase (e.g., 'fooBar' -> 'foo Bar')\n      .replace(/([a-z])([A-Z])/g, '$1 $2')\n      // Replace underscores and dashes with spaces\n      .replace(/[_-]+/g, ' ')\n      // Trim and split on whitespace\n      .trim()\n      .split(/\\s+/)\n      .filter(Boolean)\n      // Capitalize first letter of each word, preserve rest\n      .map((word) => word.charAt(0).toUpperCase() + word.slice(1))\n      .join(' ')\n  )\n}\n","import type {SchemaDefinition} from '@portabletext/schema'\nimport {Schema as SanitySchema} from '@sanity/schema'\nimport {defineField, defineType} from '@sanity/types'\nimport {keyGenerator} from './key-generator'\nimport {\n  createPortableTextMemberSchemaTypes,\n  type PortableTextMemberSchemaTypes,\n} from './portable-text-member-schema-types'\nimport {startCase} from './start-case'\n\nconst defaultObjectTitles: Record<string, string> = {\n  image: 'Image',\n  url: 'URL',\n}\n\n/**\n * Names that conflict with Sanity's built-in schema types and need temporary\n * names during `SanitySchema.compile` to avoid getting default fields added.\n */\nconst sanityBuiltinNames = new Set(['file', 'geopoint', 'image', 'slug', 'url'])\n\n/**\n * @public\n * Compile a Portable Text schema definition to Sanity-specific schema types for\n * Portable Text.\n */\nexport function compileSchemaDefinitionToPortableTextMemberSchemaTypes(\n  definition?: SchemaDefinition,\n): PortableTextMemberSchemaTypes {\n  const blockObjectDefs = definition?.blockObjects ?? []\n  const inlineObjectDefs = definition?.inlineObjects ?? []\n\n  // Collect names that appear in both blockObjects and inlineObjects, or that\n  // conflict with Sanity built-in types. These need temporary names so that\n  // `SanitySchema.compile` doesn't see duplicate type registrations.\n  const blockObjectNameSet = new Set(\n    blockObjectDefs.map((blockObject) => blockObject.name),\n  )\n  const inlineObjectNameSet = new Set(\n    inlineObjectDefs.map((inlineObject) => inlineObject.name),\n  )\n\n  const temporaryBlockObjectNames: Record<string, string> = {}\n  const temporaryInlineObjectNames: Record<string, string> = {}\n  const blockObjectNames: Record<string, string> = {}\n  const inlineObjectNames: Record<string, string> = {}\n\n  for (const name of blockObjectNameSet) {\n    if (sanityBuiltinNames.has(name) || inlineObjectNameSet.has(name)) {\n      const tmpName = `tmp-${keyGenerator()}-${name}`\n      temporaryBlockObjectNames[name] = tmpName\n      blockObjectNames[tmpName] = name\n    }\n  }\n\n  for (const name of inlineObjectNameSet) {\n    if (sanityBuiltinNames.has(name) || blockObjectNameSet.has(name)) {\n      const tmpName = `tmp-${keyGenerator()}-${name}`\n      temporaryInlineObjectNames[name] = tmpName\n      inlineObjectNames[tmpName] = name\n    }\n  }\n\n  const blockObjects = blockObjectDefs.map((blockObject) =>\n    defineType({\n      type: 'object',\n      // Use temporary names to work around `SanitySchema.compile` adding\n      // default fields to objects with certain names, and to avoid duplicate\n      // type names when a type appears in both blockObjects and inlineObjects.\n      name: temporaryBlockObjectNames[blockObject.name] ?? blockObject.name,\n      title:\n        blockObject.title === undefined\n          ? // This avoids the default title which is a title case of the object name\n            defaultObjectTitles[blockObject.name]\n          : blockObject.title,\n      fields:\n        blockObject.fields?.map((field) => ({\n          name: field.name,\n          type: field.type,\n          title: field.title ?? startCase(field.name),\n        })) ?? [],\n    }),\n  )\n\n  const inlineObjects = inlineObjectDefs.map((inlineObject) =>\n    defineType({\n      type: 'object',\n      // Use temporary names to work around `SanitySchema.compile` adding\n      // default fields to objects with certain names, and to avoid duplicate\n      // type names when a type appears in both blockObjects and inlineObjects.\n      name: temporaryInlineObjectNames[inlineObject.name] ?? inlineObject.name,\n\n      title:\n        inlineObject.title === undefined\n          ? // This avoids the default title which is a title case of the object name\n            defaultObjectTitles[inlineObject.name]\n          : inlineObject.title,\n      fields:\n        inlineObject.fields?.map((field) => ({\n          name: field.name,\n          type: field.type,\n          title: field.title ?? startCase(field.name),\n        })) ?? [],\n    }),\n  )\n\n  const portableTextSchema = defineField({\n    type: 'array',\n    name: 'portable-text',\n    of: [\n      ...blockObjects.map((blockObject) => ({type: blockObject.name})),\n      {\n        type: 'block',\n        name: 'block',\n        of: inlineObjects.map((inlineObject) => ({type: inlineObject.name})),\n        marks: {\n          decorators:\n            definition?.decorators?.map((decorator) => ({\n              title: decorator.title ?? startCase(decorator.name),\n              value: decorator.name,\n            })) ?? [],\n          annotations:\n            definition?.annotations?.map((annotation) => ({\n              name: annotation.name,\n              type: 'object',\n              title: annotation.title,\n              fields:\n                annotation.fields?.map((field) => ({\n                  name: field.name,\n                  title: field.title ?? startCase(field.name),\n                  type: field.type,\n                })) ?? [],\n            })) ?? [],\n        },\n        lists:\n          definition?.lists?.map((list) => ({\n            value: list.name,\n            title: list.title ?? startCase(list.name),\n          })) ?? [],\n        styles:\n          definition?.styles?.map((style) => ({\n            value: style.name,\n            title: style.title ?? startCase(style.name),\n          })) ?? [],\n      },\n    ],\n  })\n\n  const schema = SanitySchema.compile({\n    types: [portableTextSchema, ...blockObjects, ...inlineObjects],\n  }).get('portable-text')\n\n  const pteSchema = createPortableTextMemberSchemaTypes(schema)\n\n  // Restore original names on blockObjects and inlineObjects.\n  // These are shared references with portableText.of, so mutating them\n  // also restores names in the portableText array type's nested structure.\n  for (const blockObject of pteSchema.blockObjects) {\n    const originalName = blockObjectNames[blockObject.name]\n    if (originalName !== undefined) {\n      blockObject.name = originalName\n      if (blockObject.type) {\n        blockObject.type = {...blockObject.type, name: originalName}\n      }\n    }\n  }\n\n  for (const inlineObject of pteSchema.inlineObjects) {\n    const originalName = inlineObjectNames[inlineObject.name]\n    if (originalName !== undefined) {\n      inlineObject.name = originalName\n      if (inlineObject.type) {\n        inlineObject.type = {...inlineObject.type, name: originalName}\n      }\n    }\n  }\n\n  return pteSchema\n}\n"],"names":["SanitySchema"],"mappings":"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"}},
    {"offset": {"line": 869, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@portabletext/block-tools/lib/_chunks-es/helpers.js","sources":["file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/block-tools/src/util/resolveJsType.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/block-tools/src/equality.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/block-tools/src/types.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/flatten-nested-blocks.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/block-tools/src/constants.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/helpers.ts"],"sourcesContent":["const objectToString = Object.prototype.toString\n\n// Copied from https://github.com/ForbesLindesay/type-of\n// but inlined to have fine grained control\nexport function resolveJsType(val: unknown) {\n  switch (objectToString.call(val)) {\n    case '[object Function]':\n      return 'function'\n    case '[object Date]':\n      return 'date'\n    case '[object RegExp]':\n      return 'regexp'\n    case '[object Arguments]':\n      return 'arguments'\n    case '[object Array]':\n      return 'array'\n    case '[object String]':\n      return 'string'\n    default:\n  }\n\n  if (val === null) {\n    return 'null'\n  }\n\n  if (val === undefined) {\n    return 'undefined'\n  }\n\n  if (\n    val &&\n    typeof val === 'object' &&\n    'nodeType' in val &&\n    (val as {nodeType: unknown}).nodeType === 1\n  ) {\n    return 'element'\n  }\n\n  if (val === Object(val)) {\n    return 'object'\n  }\n\n  return typeof val\n}\n","export function isEqualMarks(\n  a: Array<string> | undefined,\n  b: Array<string> | undefined,\n): boolean {\n  if (!a || !b) {\n    return a === b\n  }\n\n  if (a.length !== b.length) {\n    return false\n  }\n\n  for (let index = 0; index < a.length; index++) {\n    if (a[index] !== b[index]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * More or less copied from Remeda (https://github.com/remeda/remeda/blob/main/packages/remeda/src/isDeepEqual.ts)\n */\nexport function isDeepEqual<A, B>(data: A, other: B) {\n  return isDeepEqualImplementation(data, other)\n}\n\nfunction isDeepEqualImplementation<T>(data: unknown, other: T): data is T {\n  if (data === other) {\n    return true\n  }\n\n  if (Object.is(data, other)) {\n    // We want to ignore the slight differences between `===` and `Object.is` as\n    // both of them largely define equality from a semantic point-of-view.\n    return true\n  }\n\n  if (typeof data !== 'object' || typeof other !== 'object') {\n    return false\n  }\n\n  if (data === null || other === null) {\n    return false\n  }\n\n  if (Object.getPrototypeOf(data) !== Object.getPrototypeOf(other)) {\n    // If the objects don't share a prototype it's unlikely that they are\n    // semantically equal. It is technically possible to build 2 prototypes that\n    // act the same but are not equal (at the reference level, checked via\n    // `===`) and then create 2 objects that are equal although we would fail on\n    // them. Because this is so unlikely, the optimization we gain here for the\n    // rest of the function by assuming that `other` is of the same type as\n    // `data` is more than worth it.\n    return false\n  }\n\n  if (Array.isArray(data)) {\n    return isDeepEqualArrays(data, other as unknown as ReadonlyArray<unknown>)\n  }\n\n  if (data instanceof Map) {\n    return isDeepEqualMaps(data, other as unknown as Map<unknown, unknown>)\n  }\n\n  if (data instanceof Set) {\n    return isDeepEqualSets(data, other as unknown as Set<unknown>)\n  }\n\n  if (data instanceof Date) {\n    return data.getTime() === (other as unknown as Date).getTime()\n  }\n\n  if (data instanceof RegExp) {\n    return data.toString() === (other as unknown as RegExp).toString()\n  }\n\n  // At this point we only know that the 2 objects share a prototype and are not\n  // any of the previous types. They could be plain objects (Object.prototype),\n  // they could be classes, they could be other built-ins, or they could be\n  // something weird. We assume that comparing values by keys is enough to judge\n  // their equality.\n\n  if (Object.keys(data).length !== Object.keys(other).length) {\n    return false\n  }\n\n  for (const [key, value] of Object.entries(data)) {\n    if (!(key in other)) {\n      return false\n    }\n\n    if (\n      !isDeepEqualImplementation(\n        value,\n        // @ts-expect-error [ts7053] - We already checked that `other` has `key`\n        other[key],\n      )\n    ) {\n      return false\n    }\n  }\n\n  return true\n}\n\nfunction isDeepEqualArrays(\n  data: ReadonlyArray<unknown>,\n  other: ReadonlyArray<unknown>,\n): boolean {\n  if (data.length !== other.length) {\n    return false\n  }\n\n  for (const [index, item] of data.entries()) {\n    if (!isDeepEqualImplementation(item, other[index])) {\n      return false\n    }\n  }\n\n  return true\n}\n\nfunction isDeepEqualMaps(\n  data: ReadonlyMap<unknown, unknown>,\n  other: ReadonlyMap<unknown, unknown>,\n): boolean {\n  if (data.size !== other.size) {\n    return false\n  }\n\n  for (const [key, value] of data.entries()) {\n    if (!other.has(key)) {\n      return false\n    }\n\n    if (!isDeepEqualImplementation(value, other.get(key))) {\n      return false\n    }\n  }\n\n  return true\n}\n\nfunction isDeepEqualSets(\n  data: ReadonlySet<unknown>,\n  other: ReadonlySet<unknown>,\n): boolean {\n  if (data.size !== other.size) {\n    return false\n  }\n\n  // To ensure we only count each item once we need to \"remember\" which items of\n  // the other set we've already matched against. We do this by creating a copy\n  // of the other set and removing items from it as we find them in the data\n  // set.\n  const otherCopy = [...other]\n\n  for (const dataItem of data) {\n    let isFound = false\n\n    for (const [index, otherItem] of otherCopy.entries()) {\n      if (isDeepEqualImplementation(dataItem, otherItem)) {\n        isFound = true\n        otherCopy.splice(index, 1)\n        break\n      }\n    }\n\n    if (!isFound) {\n      return false\n    }\n  }\n\n  return true\n}\n","import type {PortableTextObject} from '@portabletext/schema'\nimport type {SchemaMatchers} from './schema-matchers'\n\n/**\n * @public\n */\nexport interface TypedObject {\n  _type: string\n  _key?: string\n}\n\n/**\n * @public\n */\nexport interface ArbitraryTypedObject extends TypedObject {\n  [key: string]: unknown\n}\n\nexport function isArbitraryTypedObject(\n  object: unknown,\n): object is ArbitraryTypedObject {\n  return isRecord(object) && typeof object._type === 'string'\n}\n\nfunction isRecord(value: unknown): value is Record<string, unknown> {\n  return !!value && (typeof value === 'object' || typeof value === 'function')\n}\n\nexport interface MinimalSpan {\n  _type: 'span'\n  _key?: string\n  text: string\n  marks?: string[]\n}\n\nexport interface MinimalBlock extends TypedObject {\n  _type: 'block'\n  children: TypedObject[]\n  markDefs?: TypedObject[]\n  style?: string\n  level?: number\n  listItem?: string\n}\n\nexport interface PlaceholderDecorator {\n  _type: '__decorator'\n  name: string\n  children: TypedObject[]\n}\n\nexport interface PlaceholderAnnotation {\n  _type: '__annotation'\n  markDef: PortableTextObject\n  children: TypedObject[]\n}\n\n/**\n * @public\n */\nexport type HtmlParser = (html: string) => Document\n\n/**\n * @public\n */\nexport type WhiteSpacePasteMode = 'preserve' | 'remove' | 'normalize'\n\n/**\n * @public\n */\nexport interface HtmlDeserializerOptions {\n  keyGenerator?: () => string\n  rules?: DeserializerRule[]\n  parseHtml?: HtmlParser\n  unstable_whitespaceOnPasteMode?: WhiteSpacePasteMode\n  /**\n   * Custom schema matchers to use when deserializing HTML to Portable Text.\n   * @beta\n   */\n  matchers?: SchemaMatchers\n}\n\nexport interface HtmlPreprocessorOptions {\n  unstable_whitespaceOnPasteMode?: WhiteSpacePasteMode\n}\n\n/**\n * @public\n */\nexport interface DeserializerRule {\n  deserialize: (\n    el: Node,\n    next: (\n      elements: Node | Node[] | NodeList,\n    ) => TypedObject | TypedObject[] | undefined,\n    createBlock: (props: ArbitraryTypedObject) => {\n      _type: string\n      block: ArbitraryTypedObject\n    },\n  ) => TypedObject | TypedObject[] | undefined\n}\n","import type {Schema} from '@portabletext/schema'\nimport {\n  isSpan,\n  isTextBlock,\n  type PortableTextBlock,\n  type PortableTextObject,\n  type PortableTextSpan,\n  type PortableTextTextBlock,\n} from '@portabletext/schema'\nimport {isDeepEqual} from '../equality'\nimport {\n  isArbitraryTypedObject,\n  type ArbitraryTypedObject,\n  type TypedObject,\n} from '../types'\n\nexport function flattenNestedBlocks(\n  context: {\n    schema: Schema\n  },\n  blocks: Array<ArbitraryTypedObject>,\n): TypedObject[] {\n  const flattened = blocks.flatMap((block) => {\n    if (isBlockContainer(block)) {\n      return flattenNestedBlocks(context, [block.block])\n    }\n\n    if (isTextBlock(context, block)) {\n      const hasBlockObjects = block.children.some((child) => {\n        const knownBlockObject = context.schema.blockObjects.some(\n          (blockObject) => blockObject.name === child._type,\n        )\n        return knownBlockObject\n      })\n      const hasBlocks = block.children.some(\n        (child) => child._type === '__block' || child._type === 'block',\n      )\n\n      if (hasBlockObjects || hasBlocks) {\n        const splitChildren = getSplitChildren(context, block)\n\n        if (\n          splitChildren.length === 1 &&\n          splitChildren[0].type === 'children' &&\n          isDeepEqual(splitChildren[0].children, block.children)\n        ) {\n          return [block]\n        }\n\n        return splitChildren.flatMap((slice) => {\n          if (slice.type === 'block object') {\n            return [slice.block]\n          }\n\n          if (slice.type === 'block') {\n            return flattenNestedBlocks(context, [\n              slice.block as ArbitraryTypedObject,\n            ])\n          }\n\n          if (slice.children.length > 0) {\n            if (\n              slice.children.every(\n                (child) => isSpan(context, child) && child.text.trim() === '',\n              )\n            ) {\n              return []\n            }\n\n            return flattenNestedBlocks(context, [\n              {\n                ...block,\n                children: slice.children,\n              },\n            ])\n          }\n\n          return []\n        })\n      }\n\n      return [block]\n    }\n\n    return [block]\n  })\n\n  return flattened\n}\n\nfunction isBlockContainer(\n  block: ArbitraryTypedObject,\n): block is BlockContainer {\n  return block._type === '__block' && isArbitraryTypedObject(block.block)\n}\n\ntype BlockContainer = {\n  _type: '__block'\n  block: ArbitraryTypedObject\n}\n\nfunction getSplitChildren(\n  context: {schema: Schema},\n  block: PortableTextTextBlock,\n) {\n  return block.children.reduce(\n    (slices, child) => {\n      const knownInlineObject = context.schema.inlineObjects.some(\n        (inlineObject) => inlineObject.name === child._type,\n      )\n      const knownBlockObject = context.schema.blockObjects.some(\n        (blockObject) => blockObject.name === child._type,\n      )\n\n      const lastSlice = slices.pop()\n\n      if (!isSpan(context, child) && !knownInlineObject) {\n        if (knownBlockObject) {\n          return [\n            ...slices,\n            ...(lastSlice ? [lastSlice] : []),\n            {type: 'block object' as const, block: child},\n          ]\n        }\n      }\n\n      if (child._type === '__block') {\n        return [\n          ...slices,\n          ...(lastSlice ? [lastSlice] : []),\n          {\n            type: 'block object' as const,\n            block: (child as any).block,\n          },\n        ]\n      }\n\n      if (child._type === 'block') {\n        return [\n          ...slices,\n          ...(lastSlice ? [lastSlice] : []),\n          {type: 'block' as const, block: child},\n        ]\n      }\n\n      if (lastSlice) {\n        if (lastSlice.type === 'children') {\n          return [\n            ...slices,\n            {\n              type: 'children' as const,\n              children: [...lastSlice.children, child],\n            },\n          ]\n        }\n      }\n\n      return [\n        ...slices,\n        ...(lastSlice ? [lastSlice] : []),\n        {type: 'children' as const, children: [child]},\n      ]\n    },\n    [] as Array<\n      | {\n          type: 'children'\n          children: Array<PortableTextSpan | PortableTextObject>\n        }\n      | {type: 'block object'; block: PortableTextObject}\n      | {type: 'block'; block: PortableTextBlock}\n    >,\n  )\n}\n","export interface PartialBlock {\n  _type: string\n  markDefs: string[]\n  style: string\n  level?: number\n  listItem?: string\n}\n\nexport const PRESERVE_WHITESPACE_TAGS = ['pre', 'textarea', 'code']\n\nexport const BLOCK_DEFAULT_STYLE = 'normal'\n\nexport const DEFAULT_BLOCK: PartialBlock = Object.freeze({\n  _type: 'block',\n  markDefs: [],\n  style: BLOCK_DEFAULT_STYLE,\n})\n\nexport const DEFAULT_SPAN = Object.freeze({\n  _type: 'span',\n  marks: [] as string[],\n})\n\nexport const HTML_BLOCK_TAGS = {\n  p: DEFAULT_BLOCK,\n  blockquote: {...DEFAULT_BLOCK, style: 'blockquote'} as PartialBlock,\n}\n\nexport const HTML_SPAN_TAGS = {\n  span: {object: 'text'},\n}\n\nexport const HTML_LIST_CONTAINER_TAGS: Record<\n  string,\n  {object: null} | undefined\n> = {\n  ol: {object: null},\n  ul: {object: null},\n}\n\nexport const HTML_HEADER_TAGS: Record<string, PartialBlock | undefined> = {\n  h1: {...DEFAULT_BLOCK, style: 'h1'},\n  h2: {...DEFAULT_BLOCK, style: 'h2'},\n  h3: {...DEFAULT_BLOCK, style: 'h3'},\n  h4: {...DEFAULT_BLOCK, style: 'h4'},\n  h5: {...DEFAULT_BLOCK, style: 'h5'},\n  h6: {...DEFAULT_BLOCK, style: 'h6'},\n}\n\nexport const HTML_MISC_TAGS = {\n  br: {...DEFAULT_BLOCK, style: BLOCK_DEFAULT_STYLE} as PartialBlock,\n}\n\nexport const HTML_DECORATOR_TAGS: Record<string, string | undefined> = {\n  b: 'strong',\n  strong: 'strong',\n\n  i: 'em',\n  em: 'em',\n\n  u: 'underline',\n  s: 'strike-through',\n  strike: 'strike-through',\n  del: 'strike-through',\n\n  code: 'code',\n  sup: 'sup',\n  sub: 'sub',\n  ins: 'ins',\n  mark: 'mark',\n  small: 'small',\n}\n\nexport const HTML_LIST_ITEM_TAGS: Record<string, PartialBlock | undefined> = {\n  li: {\n    ...DEFAULT_BLOCK,\n    style: BLOCK_DEFAULT_STYLE,\n    level: 1,\n    listItem: 'bullet',\n  },\n}\n\nexport const ELEMENT_MAP = {\n  ...HTML_BLOCK_TAGS,\n  ...HTML_SPAN_TAGS,\n  ...HTML_LIST_CONTAINER_TAGS,\n  ...HTML_LIST_ITEM_TAGS,\n  ...HTML_HEADER_TAGS,\n  ...HTML_MISC_TAGS,\n}\n\nexport const DEFAULT_SUPPORTED_STYLES = [\n  ...new Set(\n    Object.values(ELEMENT_MAP)\n      .filter((tag): tag is PartialBlock => 'style' in tag)\n      .map((tag) => tag.style),\n  ),\n]\n\nexport const DEFAULT_SUPPORTED_DECORATORS = [\n  ...new Set(Object.values(HTML_DECORATOR_TAGS)),\n]\n\nexport const DEFAULT_SUPPORTED_ANNOTATIONS = ['link']\n","import type {Schema} from '@portabletext/schema'\nimport {isTextBlock, type PortableTextObject} from '@portabletext/schema'\nimport {DEFAULT_BLOCK} from '../constants'\nimport type {\n  ArbitraryTypedObject,\n  HtmlParser,\n  MinimalBlock,\n  MinimalSpan,\n  PlaceholderAnnotation,\n  PlaceholderDecorator,\n  TypedObject,\n} from '../types'\nimport {resolveJsType} from '../util/resolveJsType'\n\n/**\n * Utility function that always return a lowerCase version of the element.tagName\n *\n * @param el - Element to get tag name for\n * @returns Lowercase tagName for that element, or undefined if not an element\n */\nexport function tagName(el: HTMLElement | Node | null): string | undefined {\n  if (el && 'tagName' in el) {\n    return el.tagName.toLowerCase()\n  }\n\n  return undefined\n}\n\n/**\n * A default `parseHtml` function that returns the html using `DOMParser`.\n *\n * @returns HTML Parser based on `DOMParser`\n */\nexport function defaultParseHtml(): HtmlParser {\n  if (resolveJsType(DOMParser) === 'undefined') {\n    throw new Error(\n      'The native `DOMParser` global which the `Html` deserializer uses by ' +\n        'default is not present in this environment. ' +\n        'You must supply the `options.parseHtml` function instead.',\n    )\n  }\n  return (html) => {\n    return new DOMParser().parseFromString(html, 'text/html')\n  }\n}\n\nexport function ensureRootIsBlocks(\n  schema: Schema,\n  objects: Array<ArbitraryTypedObject>,\n): ArbitraryTypedObject[] {\n  return objects.reduce((blocks, node, i, original) => {\n    if (node._type === 'block') {\n      blocks.push(node)\n      return blocks\n    }\n\n    if (node._type === '__block') {\n      blocks.push((node as any).block)\n      return blocks\n    }\n\n    const lastBlock = blocks[blocks.length - 1]\n    if (\n      i > 0 &&\n      !isTextBlock({schema}, original[i - 1]) &&\n      isTextBlock({schema}, lastBlock)\n    ) {\n      lastBlock.children.push(node as PortableTextObject)\n      return blocks\n    }\n\n    const block = {\n      ...DEFAULT_BLOCK,\n      children: [node],\n    }\n\n    blocks.push(block)\n    return blocks\n  }, [] as ArbitraryTypedObject[])\n}\n\nexport function isNodeList(node: unknown): node is NodeList {\n  return Object.prototype.toString.call(node) === '[object NodeList]'\n}\n\nexport function isMinimalSpan(node: TypedObject): node is MinimalSpan {\n  return node._type === 'span'\n}\n\nexport function isMinimalBlock(node: TypedObject): node is MinimalBlock {\n  return node._type === 'block'\n}\n\nexport function isPlaceholderDecorator(\n  node: TypedObject,\n): node is PlaceholderDecorator {\n  return node._type === '__decorator'\n}\n\nexport function isPlaceholderAnnotation(\n  node: TypedObject,\n): node is PlaceholderAnnotation {\n  return node._type === '__annotation'\n}\n\nexport function isElement(node: Node): node is Element {\n  return node.nodeType === 1\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1219, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@portabletext/block-tools/lib/index.js","sources":["file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/node_modules/.pnpm/%40vercel%2Bstega%401.0.0/node_modules/%40vercel/stega/dist/index.mjs","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/block-tools/src/util/randomKey.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/word-online/asserters.word-online.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/word-online/preprocessor.word-online.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/preprocessors/xpathResult.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/preprocessors/preprocessor.gdocs.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/preprocessors/preprocessor.html.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/preprocessors/preprocessor.notion.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/preprocessors/preprocessor.whitespace.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/preprocessors/preprocessor.word.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/preprocessors/index.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/word-online/rules.word-online.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/rules/rules.gdocs.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/rules/rules.whitespace-text-node.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/rules/rules.html.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/rules/rules.notion.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/rules/rules.word.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/rules/index.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/trim-whitespace.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/index.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/block-tools/src/util/normalizeBlock.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/block-tools/src/index.ts"],"sourcesContent":["var l={0:8203,1:8204,2:8205,3:8290,4:8291,5:8288,6:65279,7:8289,8:119155,9:119156,a:119157,b:119158,c:119159,d:119160,e:119161,f:119162},d={0:8203,1:8204,2:8205,3:65279},a={0:String.fromCodePoint(d[0]),1:String.fromCodePoint(d[1]),2:String.fromCodePoint(d[2]),3:String.fromCodePoint(d[3])},p=new Array(4).fill(String.fromCodePoint(d[0])).join(\"\"),m=String.fromCharCode(0);function A(t){let e=JSON.stringify(t),r=new TextEncoder().encode(e),n=\"\";for(let i=0;i<r.length;i++){let c=r[i];n+=a[c>>6&3]+a[c>>4&3]+a[c>>2&3]+a[c&3]}return p+n}function C(t){let e=JSON.stringify(t);return Array.from(e).map(r=>{let n=r.charCodeAt(0);if(n>255)throw new Error(`Only ASCII edit info can be encoded. Error attempting to encode ${e} on character ${r} (${n})`);return Array.from(n.toString(16).padStart(2,\"0\")).map(i=>String.fromCodePoint(l[i])).join(\"\")}).join(\"\")}function h(t){return!Number.isNaN(Number(t))||/[a-z]/i.test(t)&&!/\\d+(?:[-:\\/]\\d+){2}(?:T\\d+(?:[-:\\/]\\d+){1,2}(\\.\\d+)?Z?)?/.test(t)?!1:!!Date.parse(t)}function S(t){try{new URL(t,t.startsWith(\"/\")?\"https://acme.com\":void 0)}catch{return!1}return!0}function b(t,e,r=\"auto\"){return r===!0||r===\"auto\"&&(h(t)||S(t))?t:`${t}${A(e)}`}var g=Object.fromEntries(Object.entries(a).map(t=>[t[1],+t[0]])),T=Object.fromEntries(Object.entries(l).map(t=>t.reverse())),_=`${Object.values(l).map(t=>`\\\\u{${t.toString(16)}}`).join(\"\")}`,u=new RegExp(`[${_}]{4,}`,\"gu\");function X(t){let e=t.match(u);if(e)return x(e[0],!0)[0]}function w(t){let e=t.match(u);if(e)return e.map(r=>x(r)).flat()}function x(t,e=!1){let r=Array.from(t);if(r.length%2===0){if(r.length%4||!t.startsWith(p))return I(r,e)}else throw new Error(\"Encoded data has invalid length\");let n=r.slice(4),i=new Uint8Array(n.length/4);for(let o=0;o<i.length;o++)i[o]=g[n[o*4]]<<6|g[n[o*4+1]]<<4|g[n[o*4+2]]<<2|g[n[o*4+3]];let c=new TextDecoder().decode(i);if(e){let o=c.indexOf(m);return o===-1&&(o=c.length),[JSON.parse(c.slice(0,o))]}return c.split(m).filter(Boolean).map(o=>JSON.parse(o))}function I(t,e){var o;let r=[];for(let s=t.length*.5;s--;){let f=`${T[t[s*2].codePointAt(0)]}${T[t[s*2+1].codePointAt(0)]}`;r.unshift(String.fromCharCode(parseInt(f,16)))}let n=[],i=[r.join(\"\")],c=10;for(;i.length;){let s=i.shift();try{if(n.push(JSON.parse(s)),e)return n}catch(f){if(!c--)throw f;let E=+((o=f.message.match(/\\sposition\\s(\\d+)$/))==null?void 0:o[1]);if(!E)throw f;i.unshift(s.substring(0,E),s.substring(E))}}return n}function D(t){var e;return{cleaned:t.replace(u,\"\"),encoded:((e=t.match(u))==null?void 0:e[0])||\"\"}}function M(t){return t&&JSON.parse(D(JSON.stringify(t)).cleaned)}export{u as VERCEL_STEGA_REGEX,C as legacyStegaEncode,M as vercelStegaClean,b as vercelStegaCombine,X as vercelStegaDecode,w as vercelStegaDecodeAll,A as vercelStegaEncode,D as vercelStegaSplit};\n","export function keyGenerator() {\n  return randomKey(12)\n}\n\n// WHATWG crypto RNG - https://w3c.github.io/webcrypto/Overview.html\nfunction whatwgRNG(length = 16) {\n  const rnds8 = new Uint8Array(length)\n  crypto.getRandomValues(rnds8)\n  return rnds8\n}\n\nconst byteToHex: string[] = []\nfor (let i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).slice(1)\n}\n\n/**\n * Generate a random key of the given length\n *\n * @param length - Length of string to generate\n * @returns A string of the given length\n * @public\n */\nexport function randomKey(length: number): string {\n  return whatwgRNG(length)\n    .reduce((str, n) => str + byteToHex[n], '')\n    .slice(0, length)\n}\n","import {isElement, tagName} from '../helpers'\n\nexport function isWordOnlineHtml(html: string): boolean {\n  return (\n    /class=\"(?:TextRun|NormalTextRun)[^\"]*SCXW\\d+[^\"]*BCX\\d+/.test(html) ||\n    /class=\"EOP[^\"]*SCXW\\d+/.test(html)\n  )\n}\n\nexport function isWordOnlineTextRun(el: Node): boolean {\n  if (!isElement(el) || tagName(el) !== 'span') {\n    return false\n  }\n\n  return el.classList.contains('TextRun') && !el.classList.contains('EOP')\n}\n\n/**\n * Identifies the inner text holder spans in Word Online's nested structure.\n * Word Online uses: <span class=\"TextRun\"><span class=\"NormalTextRun\">text</span></span>\n * This function matches the inner span where actual text content lives.\n * Use this to find the text-bearing children within a TextRun container.\n */\nexport function isNormalTextRun(el: Node): boolean {\n  if (!isElement(el) || tagName(el) !== 'span') {\n    return false\n  }\n\n  return el.classList.contains('NormalTextRun')\n}\n\n/**\n * Identifies the outer container spans in Word Online's nested structure.\n * Word Online uses: <span class=\"TextRun\"><span class=\"NormalTextRun\">text</span></span>\n * This function matches the outer span that holds formatting and contains NormalTextRun children.\n * Use this to find the top-level containers, then search within for NormalTextRun spans.\n * Note: Excludes spans that also have \"NormalTextRun\" or \"EOP\" classes.\n */\nexport function isTextRunSpan(el: Node): boolean {\n  if (!isElement(el) || tagName(el) !== 'span') {\n    return false\n  }\n\n  return (\n    el.classList.contains('TextRun') &&\n    !el.classList.contains('NormalTextRun') &&\n    !el.classList.contains('EOP')\n  )\n}\n\nexport function isEmptyOutlineElement(el: Element): boolean {\n  if (!isElement(el)) {\n    return false\n  }\n\n  if (!el.classList.contains('OutlineElement')) {\n    return false\n  }\n\n  return el.textContent.trim() === ''\n}\n\nexport function isFindHit(el: Node): boolean {\n  if (!isElement(el) || tagName(el) !== 'span') {\n    return false\n  }\n\n  return el.classList.contains('FindHit')\n}\n\nexport function isInHeading(el: Node): boolean {\n  let current: Node | null = el\n\n  while (current) {\n    if (isElement(current)) {\n      if (\n        tagName(current) === 'word-online-block' &&\n        /^heading \\d$/.test(current.getAttribute('data-parastyle') ?? '')\n      ) {\n        return true\n      }\n    }\n\n    current = current.parentNode\n  }\n\n  return false\n}\n\nexport function isInBlockquote(el: Node): boolean {\n  let current: Node | null = el\n\n  while (current) {\n    if (isElement(current)) {\n      if (\n        tagName(current) === 'word-online-block' &&\n        current.getAttribute('data-parastyle') === 'Quote'\n      ) {\n        return true\n      }\n    }\n\n    current = current.parentNode\n  }\n\n  return false\n}\n\n/**********************\n * Formatting asserters\n **********************/\n\nexport function hasStrongFormatting(el: Element): boolean {\n  const style = el.getAttribute('style') ?? ''\n\n  return (\n    el.classList.contains('MacChromeBold') ||\n    /font-weight\\s*:\\s*bold/.test(style)\n  )\n}\n\nexport function hasEmphasisFormatting(el: Element): boolean {\n  const style = el.getAttribute('style') ?? ''\n\n  return /font-style\\s*:\\s*italic/.test(style)\n}\n\nexport function hasUnderlineFormatting(el: Element): boolean {\n  const style = el.getAttribute('style') ?? ''\n\n  return (\n    el.classList.contains('Underlined') ||\n    /text-decoration\\s*:\\s*underline/.test(style)\n  )\n}\n\nexport function hasStrikethroughFormatting(el: Element): boolean {\n  const style = el.getAttribute('style') ?? ''\n\n  return (\n    el.classList.contains('Strikethrough') ||\n    /text-decoration\\s*:\\s*line-through/.test(style)\n  )\n}\n\nexport function hasFormatting(el: Element): boolean {\n  return (\n    hasStrongFormatting(el) ||\n    hasEmphasisFormatting(el) ||\n    hasUnderlineFormatting(el) ||\n    hasStrikethroughFormatting(el)\n  )\n}\n","import {isElement, tagName} from '../helpers'\nimport {\n  hasFormatting,\n  isNormalTextRun,\n  isTextRunSpan,\n  isWordOnlineHtml,\n} from './asserters.word-online'\n\nexport function preprocessWordOnline(html: string, doc: Document): Document {\n  if (!isWordOnlineHtml(html)) {\n    return doc\n  }\n\n  const paragraphs = Array.from(\n    doc.querySelectorAll('p.Paragraph[role=\"heading\"]'),\n  )\n\n  for (const paragraph of paragraphs) {\n    const ariaLevel = paragraph.getAttribute('aria-level')\n\n    if (ariaLevel) {\n      const wrapper = doc.createElement('word-online-block')\n\n      wrapper.setAttribute('data-parastyle', `heading ${ariaLevel}`)\n\n      const parent = paragraph.parentNode\n\n      if (parent) {\n        parent.insertBefore(wrapper, paragraph)\n\n        while (paragraph.firstChild) {\n          wrapper.appendChild(paragraph.firstChild)\n        }\n\n        parent.removeChild(paragraph)\n      }\n    }\n  }\n\n  // Group NormalTextRun spans with the same data-ccp-parastyle attribute\n  // This handles cases like blockquotes, headings where multiple spans should form one block\n  // Process from the body directly to handle DOM mutations\n  let child = doc.body.firstChild\n\n  while (child) {\n    const next = child.nextSibling\n\n    if (!isElement(child) || !tagName(child)?.includes('span')) {\n      child = next\n\n      continue\n    }\n\n    const paraStyle = getParaStyle(child)\n\n    if (!paraStyle) {\n      child = next\n\n      continue\n    }\n\n    // Found a span with paragraph style - collect all consecutive siblings with same style\n    const group: Element[] = [child]\n    let sibling = next\n\n    while (sibling) {\n      if (!isElement(sibling) || getParaStyle(sibling) !== paraStyle) {\n        break\n      }\n\n      group.push(sibling)\n      sibling = sibling.nextSibling\n    }\n\n    // Wrap the spans in a container\n    // Use a custom element name to avoid conflicts with HTML rules\n    const wrapper = doc.createElement('word-online-block')\n    wrapper.setAttribute('data-parastyle', paraStyle)\n\n    // Insert the wrapper before the first span\n    doc.body.insertBefore(wrapper, child)\n\n    // Move all grouped spans into the wrapper\n    for (const span of group) {\n      wrapper.appendChild(span)\n    }\n\n    // Continue with the sibling after the last grouped span\n    child = sibling\n  }\n\n  // Find all TextRun spans\n  const textRunSpans = Array.from(doc.body.querySelectorAll('span')).filter(\n    isTextRunSpan,\n  )\n\n  for (const textRunSpan of textRunSpans) {\n    // Find ALL NormalTextRun children (Word Online can have multiple per TextRun)\n    const normalTextRuns = Array.from(textRunSpan.childNodes).filter(\n      isNormalTextRun,\n    )\n\n    for (const normalTextRun of normalTextRuns) {\n      // Process ALL nested spans with whitespace in this NormalTextRun\n      // We need to process them in a loop since removing one might affect indices\n      let foundNestedSpan = true\n\n      while (foundNestedSpan) {\n        const children = Array.from(normalTextRun.childNodes)\n        const nestedSpanIndex = children.findIndex(\n          (node) =>\n            isElement(node) &&\n            tagName(node) === 'span' &&\n            node.textContent.trim() === '',\n        )\n\n        if (nestedSpanIndex === -1) {\n          foundNestedSpan = false\n          break\n        }\n\n        const nestedSpan = children.at(nestedSpanIndex)\n\n        if (!nestedSpan) {\n          foundNestedSpan = false\n          break\n        }\n\n        // Word Online uses non-breaking spaces, convert to regular spaces\n        const spaceText = nestedSpan.textContent?.replace(/\\u00a0/g, ' ') ?? ''\n\n        // Determine if the space is at the beginning or end BEFORE removing it\n        // Check if there are any text nodes before this position\n        const hasTextBefore = children\n          .slice(0, nestedSpanIndex)\n          .some((n) => n.nodeType === 3)\n        const isSpaceAtBeginning = !hasTextBefore\n\n        // Remove the nested span\n        normalTextRun.removeChild(nestedSpan)\n\n        if (isSpaceAtBeginning) {\n          // Space at the beginning - keep it at the beginning\n          const firstTextNode = Array.from(normalTextRun.childNodes).find(\n            (n) => n.nodeType === 3,\n          )\n\n          if (firstTextNode) {\n            firstTextNode.textContent =\n              spaceText + (firstTextNode.textContent || '')\n          } else {\n            // No text node exists, create one with the space\n            const spaceNode = doc.createTextNode(spaceText)\n            normalTextRun.insertBefore(spaceNode, normalTextRun.firstChild)\n          }\n        } else {\n          // Space at the end - check if we should move it to the next TextRun\n          // Only move if the formatting (marks) are different\n          const nextSibling = textRunSpan.nextSibling\n          const currentHasFormatting = hasFormatting(textRunSpan)\n\n          if (\n            nextSibling &&\n            isElement(nextSibling) &&\n            isTextRunSpan(nextSibling)\n          ) {\n            const nextHasFormatting = hasFormatting(nextSibling)\n\n            // If current has formatting but next doesn't, move space to the next span\n            // This makes semantic sense: \"**bar** baz\" or \"*bar* baz\"  space should be outside the formatting\n            if (currentHasFormatting && !nextHasFormatting) {\n              const nextNormalTextRun = Array.from(nextSibling.childNodes).find(\n                isNormalTextRun,\n              )\n\n              if (nextNormalTextRun && isElement(nextNormalTextRun)) {\n                // Prepend space to the first text node of the next NormalTextRun\n                const firstChild = nextNormalTextRun.firstChild\n\n                if (firstChild && firstChild.nodeType === 3) {\n                  firstChild.textContent =\n                    spaceText + (firstChild.textContent ?? '')\n                } else {\n                  // No text node, insert a new one at the beginning\n                  const spaceNode = doc.createTextNode(spaceText)\n                  nextNormalTextRun.insertBefore(\n                    spaceNode,\n                    nextNormalTextRun.firstChild,\n                  )\n                }\n              }\n              // Don't add the space back to the current span - it's been moved\n            } else {\n              // Same formatting, keep the space in the current span\n              const lastTextNode = Array.from(normalTextRun.childNodes).find(\n                (n) => n.nodeType === 3,\n              )\n\n              if (lastTextNode) {\n                lastTextNode.textContent =\n                  (lastTextNode.textContent ?? '') + spaceText\n              } else {\n                // No text node exists, create one with the space\n                const spaceNode = doc.createTextNode(spaceText)\n                normalTextRun.appendChild(spaceNode)\n              }\n            }\n          } else {\n            // No next TextRun, keep the space at the end of this span's text\n            const lastTextNode = Array.from(normalTextRun.childNodes).find(\n              (n) => n.nodeType === 3,\n            )\n\n            if (lastTextNode) {\n              lastTextNode.textContent =\n                (lastTextNode.textContent ?? '') + spaceText\n            } else {\n              // No text node exists, create one with the space\n              const spaceNode = doc.createTextNode(spaceText)\n              normalTextRun.appendChild(spaceNode)\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return doc\n}\n\n// Helper to get paragraph style from a span (either directly or from NormalTextRun child)\nfunction getParaStyle(element: Element): string | undefined {\n  // Check direct attribute first\n  const directStyle = element.getAttribute('data-ccp-parastyle')\n\n  if (directStyle) {\n    return directStyle\n  }\n\n  // Check if it's a TextRun with NormalTextRun children that have the attribute\n  if (tagName(element) === 'span' && element.classList.contains('TextRun')) {\n    const normalTextRuns = Array.from(\n      element.querySelectorAll('.NormalTextRun'),\n    )\n\n    if (normalTextRuns.length > 0) {\n      const firstStyle = normalTextRuns[0].getAttribute('data-ccp-parastyle')\n\n      // Verify all NormalTextRuns have the same style\n      if (\n        firstStyle &&\n        normalTextRuns.every(\n          (normalTextRun) =>\n            normalTextRun.getAttribute('data-ccp-parastyle') === firstStyle,\n        )\n      ) {\n        return firstStyle\n      }\n    }\n  }\n\n  return undefined\n}\n","// We need this here if run server side\nexport const _XPathResult = {\n  ANY_TYPE: 0,\n  NUMBER_TYPE: 1,\n  STRING_TYPE: 2,\n  BOOLEAN_TYPE: 3,\n  UNORDERED_NODE_ITERATOR_TYPE: 4,\n  ORDERED_NODE_ITERATOR_TYPE: 5,\n  UNORDERED_NODE_SNAPSHOT_TYPE: 6,\n  ORDERED_NODE_SNAPSHOT_TYPE: 7,\n  ANY_UNORDERED_NODE_TYPE: 8,\n  FIRST_ORDERED_NODE_TYPE: 9,\n}\n","import {tagName} from '../helpers'\nimport {_XPathResult} from './xpathResult'\n\nexport function preprocessGDocs(_html: string, doc: Document): Document {\n  let gDocsRootOrSiblingNode = doc\n    .evaluate(\n      '//*[@id and contains(@id, \"docs-internal-guid\")]',\n      doc,\n      null,\n      _XPathResult.ORDERED_NODE_ITERATOR_TYPE,\n      null,\n    )\n    .iterateNext()\n\n  if (gDocsRootOrSiblingNode) {\n    const isWrappedRootTag = tagName(gDocsRootOrSiblingNode) === 'b'\n\n    // If this document isn't wrapped in a 'b' tag, then assume all siblings live on the root level\n    if (!isWrappedRootTag) {\n      gDocsRootOrSiblingNode = doc.body\n    }\n\n    // Tag every child with attribute 'is-google-docs' so that the GDocs rule-set can\n    // work exclusivly on these children\n    const childNodes = doc.evaluate(\n      '//*',\n      doc,\n      null,\n      _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n      null,\n    )\n\n    for (let i = childNodes.snapshotLength - 1; i >= 0; i--) {\n      const elm = childNodes.snapshotItem(i) as HTMLElement\n      elm?.setAttribute('data-is-google-docs', 'true')\n\n      if (\n        elm?.parentElement === gDocsRootOrSiblingNode ||\n        (!isWrappedRootTag && elm.parentElement === doc.body)\n      ) {\n        elm?.setAttribute('data-is-root-node', 'true')\n        tagName(elm)\n      }\n\n      // Handle checkmark lists - The first child of a list item is an image with a checkmark, and the serializer\n      // expects the first child to be the text node\n      if (\n        tagName(elm) === 'li' &&\n        elm.firstChild &&\n        tagName(elm?.firstChild) === 'img'\n      ) {\n        elm.removeChild(elm.firstChild)\n      }\n    }\n\n    // Remove that 'b' which Google Docs wraps the HTML content in\n    if (isWrappedRootTag) {\n      doc.body.firstElementChild?.replaceWith(\n        ...Array.from(gDocsRootOrSiblingNode.childNodes),\n      )\n    }\n\n    return doc\n  }\n  return doc\n}\n","import {_XPathResult} from './xpathResult'\n\n// Remove this cruft from the document\nconst unwantedWordDocumentPaths = [\n  '/html/text()',\n  '/html/head/text()',\n  '/html/body/text()',\n  '/html/body/ul/text()',\n  '/html/body/ol/text()',\n  '//comment()',\n  '//style',\n  '//xml',\n  '//script',\n  '//meta',\n  '//link',\n]\n\nexport function preprocessHTML(_html: string, doc: Document): Document {\n  // Make sure text directly on the body is wrapped in spans.\n  // This mimics what the browser does before putting html on the clipboard,\n  // when used in a script context with JSDOM\n  const bodyTextNodes = doc.evaluate(\n    '/html/body/text()',\n    doc,\n    null,\n    _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n    null,\n  )\n\n  for (let i = bodyTextNodes.snapshotLength - 1; i >= 0; i--) {\n    const node = bodyTextNodes.snapshotItem(i) as HTMLElement\n    const text = node.textContent || ''\n    if (text.replace(/[^\\S\\n]+$/g, '')) {\n      const newNode = doc.createElement('span')\n      newNode.appendChild(doc.createTextNode(text))\n      node.parentNode?.replaceChild(newNode, node)\n    } else {\n      node.parentNode?.removeChild(node)\n    }\n  }\n\n  const unwantedNodes = doc.evaluate(\n    unwantedWordDocumentPaths.join('|'),\n    doc,\n    null,\n    _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n    null,\n  )\n  for (let i = unwantedNodes.snapshotLength - 1; i >= 0; i--) {\n    const unwanted = unwantedNodes.snapshotItem(i)\n    if (!unwanted) {\n      continue\n    }\n    unwanted.parentNode?.removeChild(unwanted)\n  }\n  return doc\n}\n","import {_XPathResult} from './xpathResult'\n\nexport function preprocessNotion(html: string, doc: Document): Document {\n  const NOTION_REGEX = /<!-- notionvc:.*?-->/g\n\n  if (html.match(NOTION_REGEX)) {\n    // Tag every child with attribute 'is-notion' so that the Notion rule-set can\n    // work exclusivly on these children\n    const childNodes = doc.evaluate(\n      '//*',\n      doc,\n      null,\n      _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n      null,\n    )\n\n    for (let i = childNodes.snapshotLength - 1; i >= 0; i--) {\n      const elm = childNodes.snapshotItem(i) as HTMLElement\n      elm?.setAttribute('data-is-notion', 'true')\n    }\n\n    return doc\n  }\n  return doc\n}\n","import {PRESERVE_WHITESPACE_TAGS} from '../../constants'\nimport {_XPathResult} from './xpathResult'\n\n// Elements that only contain block-level children (not inline text content)\nconst BLOCK_CONTAINER_ELEMENTS = [\n  'body',\n  'table',\n  'tbody',\n  'thead',\n  'tfoot',\n  'tr',\n  'ul',\n  'ol',\n]\n\nexport function preprocessWhitespace(_: string, doc: Document): Document {\n  // Recursively process all nodes.\n  function processNode(node: Node) {\n    // If this is a text node and not inside a tag where whitespace should be preserved, process it.\n    if (\n      node.nodeType === _XPathResult.BOOLEAN_TYPE &&\n      !PRESERVE_WHITESPACE_TAGS.includes(\n        node.parentElement?.tagName.toLowerCase() || '',\n      )\n    ) {\n      const normalized =\n        node.textContent\n          ?.replace(/\\s\\s+/g, ' ') // Remove multiple whitespace\n          .replace(/[\\r\\n]+/g, ' ') || '' // Replace newlines with spaces\n      const parentTag = node.parentElement?.tagName.toLowerCase()\n\n      if (\n        parentTag &&\n        BLOCK_CONTAINER_ELEMENTS.includes(parentTag) &&\n        normalized.trim() === ''\n      ) {\n        // If parent is a block container and text is only whitespace, remove it\n        node.parentNode?.removeChild(node)\n      } else {\n        node.textContent = normalized\n      }\n    }\n    // Otherwise, if this node has children, process them.\n    else {\n      // Process children in reverse to handle removals safely\n      for (let i = node.childNodes.length - 1; i >= 0; i--) {\n        processNode(node.childNodes[i])\n      }\n    }\n  }\n\n  // Process all nodes starting from the root.\n  processNode(doc.body)\n\n  return doc\n}\n","import {_XPathResult} from './xpathResult'\n\nconst WORD_HTML_REGEX =\n  /(class=\"?Mso|style=(?:\"|')[^\"]*?\\bmso-|w:WordDocument|<o:\\w+>|<\\/font>)/\n\n// xPaths for elements that will be removed from the document\nconst unwantedPaths = [\n  '//o:p',\n  \"//span[@style='mso-list:Ignore']\",\n  \"//span[@style='mso-list: Ignore']\",\n]\n\n// xPaths for elements that needs to be remapped into other tags\nconst mappedPaths = [\n  \"//p[@class='MsoTocHeading']\",\n  \"//p[@class='MsoTitle']\",\n  \"//p[@class='MsoToaHeading']\",\n  \"//p[@class='MsoSubtitle']\",\n  \"//span[@class='MsoSubtleEmphasis']\",\n  \"//span[@class='MsoIntenseEmphasis']\",\n]\n\n// Which HTML element(s) to map the elements matching mappedPaths into\nconst elementMap: Record<string, string[] | undefined> = {\n  MsoTocHeading: ['h3'],\n  MsoTitle: ['h1'],\n  MsoToaHeading: ['h2'],\n  MsoSubtitle: ['h5'],\n  MsoSubtleEmphasis: ['span', 'em'],\n  MsoIntenseEmphasis: ['span', 'em', 'strong'],\n  // Remove cruft\n}\n\nfunction isWordHtml(html: string) {\n  return WORD_HTML_REGEX.test(html)\n}\n\nexport function preprocessWord(html: string, doc: Document): Document {\n  if (!isWordHtml(html)) {\n    return doc\n  }\n\n  const unwantedNodes = doc.evaluate(\n    unwantedPaths.join('|'),\n    doc,\n    (prefix) => {\n      if (prefix === 'o') {\n        return 'urn:schemas-microsoft-com:office:office'\n      }\n      return null\n    },\n    _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n    null,\n  )\n\n  for (let i = unwantedNodes.snapshotLength - 1; i >= 0; i--) {\n    const unwanted = unwantedNodes.snapshotItem(i)\n    if (unwanted?.parentNode) {\n      unwanted.parentNode.removeChild(unwanted)\n    }\n  }\n\n  // Transform mapped elements into what they should be mapped to\n  const mappedElements = doc.evaluate(\n    mappedPaths.join('|'),\n    doc,\n    null,\n    _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n    null,\n  )\n  for (let i = mappedElements.snapshotLength - 1; i >= 0; i--) {\n    const mappedElm = mappedElements.snapshotItem(i) as HTMLElement\n    const tags = elementMap[mappedElm.className]\n    const text = doc.createTextNode(mappedElm.textContent || '')\n    if (!tags) {\n      continue\n    }\n\n    const parentElement = doc.createElement(tags[0])\n    let parent = parentElement\n    let child = parentElement\n    tags.slice(1).forEach((tag) => {\n      child = doc.createElement(tag)\n      parent.appendChild(child)\n      parent = child\n    })\n    child.appendChild(text)\n    mappedElm?.parentNode?.replaceChild(parentElement, mappedElm)\n  }\n\n  return doc\n}\n","import {preprocessWordOnline} from '../word-online/preprocessor.word-online'\nimport {preprocessGDocs} from './preprocessor.gdocs'\nimport {preprocessHTML} from './preprocessor.html'\nimport {preprocessNotion} from './preprocessor.notion'\nimport {preprocessWhitespace} from './preprocessor.whitespace'\nimport {preprocessWord} from './preprocessor.word'\n\nexport const preprocessors = [\n  preprocessWhitespace,\n  preprocessNotion,\n  preprocessWord,\n  preprocessWordOnline,\n  preprocessGDocs,\n  preprocessHTML,\n]\n","import type {Schema} from '@portabletext/schema'\nimport {DEFAULT_SPAN, HTML_BLOCK_TAGS, HTML_HEADER_TAGS} from '../../constants'\nimport type {SchemaMatchers} from '../../schema-matchers'\nimport type {DeserializerRule} from '../../types'\nimport {keyGenerator} from '../../util/randomKey'\nimport {isElement, tagName} from '../helpers'\nimport {\n  hasEmphasisFormatting,\n  hasStrikethroughFormatting,\n  hasStrongFormatting,\n  hasUnderlineFormatting,\n  isFindHit,\n  isInBlockquote,\n  isInHeading,\n  isNormalTextRun,\n  isWordOnlineTextRun,\n} from './asserters.word-online'\n\nfunction mapParaStyleToBlockStyle(schema: Schema, paraStyle: string) {\n  const blockStyleMap: Record<string, string> = {\n    'heading 1': 'h1',\n    'heading 2': 'h2',\n    'heading 3': 'h3',\n    'heading 4': 'h4',\n    'heading 5': 'h5',\n    'heading 6': 'h6',\n    'Quote': 'blockquote',\n  }\n\n  const blockStyle = blockStyleMap[paraStyle] ?? 'normal'\n\n  return schema.styles.find((style) => style.name === blockStyle)?.name\n}\n\nexport function createWordOnlineRules(\n  schema: Schema,\n  options: {keyGenerator?: () => string; matchers?: SchemaMatchers},\n): DeserializerRule[] {\n  return [\n    // Image rule - handles bare Word Online <img> tags with WACImage class\n    {\n      deserialize(el) {\n        if (!isElement(el) || tagName(el) !== 'img') {\n          return undefined\n        }\n\n        // Handle className which might be a string or SVGAnimatedString\n        const classNameRaw = el.className\n        let className = ''\n        if (typeof classNameRaw === 'string') {\n          className = classNameRaw\n        } else if (classNameRaw && typeof classNameRaw === 'object') {\n          // SVGAnimatedString has baseVal property\n          className = (classNameRaw as {baseVal?: string}).baseVal || ''\n        }\n\n        if (!className.includes('WACImage')) {\n          return undefined\n        }\n\n        const src = el.getAttribute('src') ?? undefined\n        const alt = el.getAttribute('alt') ?? undefined\n\n        const props = Object.fromEntries(\n          Array.from(el.attributes).map((attr) => [attr.name, attr.value]),\n        )\n\n        // Bare <img> tags are typically block-level, not inline\n        // They should be returned as block images\n        const image = options.matchers?.image?.({\n          context: {\n            schema: schema,\n            keyGenerator: options.keyGenerator ?? keyGenerator,\n          },\n          props: {\n            ...props,\n            ...(src ? {src} : {}),\n            ...(alt ? {alt} : {}),\n          },\n        })\n\n        if (image) {\n          return {\n            _type: '__block',\n            block: image,\n          }\n        }\n\n        return undefined\n      },\n    },\n    // Image rule - handles Word Online images wrapped in WACImageContainer\n    {\n      deserialize(el) {\n        if (!isElement(el)) {\n          return undefined\n        }\n\n        // Handle className which might be a string or SVGAnimatedString\n        const classNameRaw = el.className\n        let className = ''\n        if (typeof classNameRaw === 'string') {\n          className = classNameRaw\n        } else if (classNameRaw && typeof classNameRaw === 'object') {\n          // SVGAnimatedString has baseVal property\n          className = (classNameRaw as {baseVal?: string}).baseVal || ''\n        }\n        if (!className.includes('WACImageContainer')) {\n          return undefined\n        }\n\n        // Find the img element inside\n        const img = el.querySelector('img')\n        if (!img) {\n          return undefined\n        }\n\n        const src = img.getAttribute('src') ?? undefined\n        const alt = img.getAttribute('alt') ?? undefined\n\n        const props = Object.fromEntries(\n          Array.from(img.attributes).map((attr) => [attr.name, attr.value]),\n        )\n\n        // Determine if this should be an inline or block-level image\n        // Word Online inline images:\n        // 1. Siblings of TextRun spans (not wrapped in paragraphs)\n        // 2. Inside list items (should be inline relative to the list item)\n        const isInsideListItem = el.closest('li') !== null\n        const isInsideParagraph = el.closest('p') !== null\n\n        if (!isInsideParagraph || isInsideListItem) {\n          // Inline image (either not in a paragraph, or inside a list item)\n          const inlineImage = options.matchers?.inlineImage?.({\n            context: {\n              schema: schema,\n              keyGenerator: options.keyGenerator ?? keyGenerator,\n            },\n            props: {\n              ...props,\n              ...(src ? {src} : {}),\n              ...(alt ? {alt} : {}),\n            },\n          })\n\n          if (inlineImage) {\n            return inlineImage\n          }\n        }\n\n        // Block-level image (or fallback if inline image not supported)\n        const image = options.matchers?.image?.({\n          context: {\n            schema: schema,\n            keyGenerator: options.keyGenerator ?? keyGenerator,\n          },\n          props: {\n            ...props,\n            ...(src ? {src} : {}),\n            ...(alt ? {alt} : {}),\n          },\n        })\n\n        if (image) {\n          return {\n            _type: '__block',\n            block: image,\n          }\n        }\n\n        return undefined\n      },\n    },\n    // List item rule - handles <li> elements with aria-level\n    {\n      deserialize(el, next) {\n        if (!isElement(el) || tagName(el) !== 'li') {\n          return undefined\n        }\n\n        const ariaLevel = el.getAttribute('data-aria-level')\n\n        if (!ariaLevel) {\n          return undefined\n        }\n\n        const listItem = tagName(el.parentNode) === 'ol' ? 'number' : 'bullet'\n\n        let childNodesToProcess = el.childNodes\n        let blockStyle = 'normal'\n\n        if (\n          el.childNodes.length === 1 &&\n          el.firstChild &&\n          isElement(el.firstChild)\n        ) {\n          const childTag = tagName(el.firstChild)\n\n          if (\n            childTag &&\n            (HTML_BLOCK_TAGS[childTag as keyof typeof HTML_BLOCK_TAGS] ||\n              HTML_HEADER_TAGS[childTag as keyof typeof HTML_HEADER_TAGS] ||\n              childTag === 'word-online-block')\n          ) {\n            // If it's a word-online-block, extract the style before skipping it\n            if (childTag === 'word-online-block') {\n              const paraStyle = el.firstChild.getAttribute('data-parastyle')\n              const foundBlockStyle = paraStyle\n                ? mapParaStyleToBlockStyle(schema, paraStyle)\n                : undefined\n\n              if (foundBlockStyle) {\n                blockStyle = foundBlockStyle\n              }\n            }\n\n            // Skip the block wrapper and process its children directly\n            childNodesToProcess = el.firstChild.childNodes\n          }\n        }\n\n        const children = next(childNodesToProcess)\n        let childArray = Array.isArray(children)\n          ? children\n          : [children].filter(Boolean)\n\n        // Clean up trailing empty or whitespace-only spans\n        // Word Online often adds trailing tabs/breaks and extra spaces in list items\n        while (childArray.length > 0) {\n          const lastChild = childArray[childArray.length - 1]\n\n          if (\n            lastChild &&\n            typeof lastChild === 'object' &&\n            'text' in lastChild\n          ) {\n            const text = (lastChild.text as string).trimEnd()\n            if (text === '') {\n              // Remove empty span\n              childArray = childArray.slice(0, -1)\n            } else if (text !== lastChild.text) {\n              // Update with trimmed text\n              lastChild.text = text\n              break\n            } else {\n              break\n            }\n          } else {\n            break\n          }\n        }\n\n        return {\n          _type: schema.block.name,\n          children: childArray,\n          markDefs: [],\n          style: blockStyle,\n          listItem,\n          level: parseInt(ariaLevel, 10),\n        }\n      },\n    },\n    // Block style rule - handles paragraph styles like Quote\n    // The preprocessor wraps grouped NormalTextRun spans in a word-online-block element\n    {\n      deserialize(el, next) {\n        if (!isElement(el)) {\n          return undefined\n        }\n\n        const paraStyle = el.getAttribute('data-parastyle')\n        const blockStyle = paraStyle\n          ? mapParaStyleToBlockStyle(schema, paraStyle)\n          : undefined\n\n        if (!blockStyle) {\n          return undefined\n        }\n\n        const children = next(el.childNodes)\n\n        return {\n          _type: schema.block.name,\n          style: blockStyle,\n          markDefs: [],\n          children: Array.isArray(children)\n            ? children\n            : children\n              ? [children]\n              : [],\n        }\n      },\n    },\n    // TextRun rule\n    {\n      deserialize(el) {\n        if (isWordOnlineTextRun(el)) {\n          if (!isElement(el)) {\n            return undefined\n          }\n\n          if (!el.textContent) {\n            return undefined\n          }\n\n          // Find ALL NormalTextRun and FindHit children and extract text from them\n          // (Word Online sometimes splits text across multiple spans)\n          // FindHit is used for search result highlighting\n          const textSpans = Array.from(el.childNodes).filter(\n            (node) => isNormalTextRun(node) || isFindHit(node),\n          )\n          const text = textSpans\n            .map((span) => (isElement(span) ? (span.textContent ?? '') : ''))\n            .join('')\n\n          if (!text) {\n            return undefined\n          }\n\n          const span = {\n            ...DEFAULT_SPAN,\n            marks: [] as Array<string>,\n            text,\n          }\n\n          if (hasStrongFormatting(el)) {\n            span.marks.push('strong')\n          }\n\n          // Don't add italic mark if we're in a heading or blockquote (it's part of their default style)\n          if (\n            hasEmphasisFormatting(el) &&\n            !isInHeading(el) &&\n            !isInBlockquote(el)\n          ) {\n            span.marks.push('em')\n          }\n\n          // Add underline mark if the element has explicit underline formatting\n          // Word Online always adds underline to links, so we need to distinguish between:\n          // 1. Default link underline (skip)\n          // 2. Explicit user underline that includes the link (add)\n          // We check: if the link is surrounded by underlined content, it's explicit user underline\n          if (hasUnderlineFormatting(el)) {\n            const isInsideLink =\n              isElement(el) &&\n              el.parentElement &&\n              tagName(el.parentElement) === 'a'\n\n            if (isInsideLink) {\n              // Check if there are underlined siblings of the link\n              const linkElement = el.parentElement\n              if (linkElement) {\n                const prevSibling = linkElement.previousSibling\n                const nextSibling = linkElement.nextSibling\n\n                // If either sibling is an underlined TextRun, the link is part of explicit underline\n                const hasPrevUnderline =\n                  prevSibling &&\n                  isElement(prevSibling) &&\n                  hasUnderlineFormatting(prevSibling)\n                const hasNextUnderline =\n                  nextSibling &&\n                  isElement(nextSibling) &&\n                  hasUnderlineFormatting(nextSibling)\n\n                if (hasPrevUnderline || hasNextUnderline) {\n                  span.marks.push('underline')\n                }\n                // Otherwise, it's just default link styling, don't add underline mark\n              }\n            } else {\n              // Not in a link, always add underline\n              span.marks.push('underline')\n            }\n          }\n\n          // Add strikethrough mark if the element has strikethrough formatting\n          if (hasStrikethroughFormatting(el)) {\n            span.marks.push('strike-through')\n          }\n\n          return span\n        }\n\n        return undefined\n      },\n    },\n  ]\n}\n","import type {Schema} from '@portabletext/schema'\nimport {\n  BLOCK_DEFAULT_STYLE,\n  DEFAULT_BLOCK,\n  DEFAULT_SPAN,\n  HTML_BLOCK_TAGS,\n  HTML_HEADER_TAGS,\n  HTML_LIST_CONTAINER_TAGS,\n} from '../../constants'\nimport type {DeserializerRule} from '../../types'\nimport {isElement, tagName} from '../helpers'\n\nconst LIST_CONTAINER_TAGS = Object.keys(HTML_LIST_CONTAINER_TAGS)\n\n// font-style:italic seems like the most important rule for italic / emphasis in their html\nfunction isEmphasis(el: Node): boolean {\n  const style = isElement(el) && el.getAttribute('style')\n  return /font-style\\s*:\\s*italic/.test(style || '')\n}\n\n// font-weight:700 seems like the most important rule for bold in their html\nfunction isStrong(el: Node): boolean {\n  const style = isElement(el) && el.getAttribute('style')\n  return /font-weight\\s*:\\s*700/.test(style || '')\n}\n\n// text-decoration seems like the most important rule for underline in their html\nfunction isUnderline(el: Node): boolean {\n  if (!isElement(el) || tagName(el.parentNode) === 'a') {\n    return false\n  }\n\n  const style = isElement(el) && el.getAttribute('style')\n\n  return /text-decoration\\s*:\\s*underline/.test(style || '')\n}\n\n// text-decoration seems like the most important rule for strike-through in their html\n// allows for line-through regex to be more lineient to allow for other text-decoration before or after\nfunction isStrikethrough(el: Node): boolean {\n  const style = isElement(el) && el.getAttribute('style')\n  return /text-decoration\\s*:\\s*(?:.*line-through.*;)/.test(style || '')\n}\n\n// Check for attribute given by the gdocs preprocessor\nfunction isGoogleDocs(el: Node): boolean {\n  return isElement(el) && Boolean(el.getAttribute('data-is-google-docs'))\n}\n\nfunction isRootNode(el: Node): boolean {\n  return isElement(el) && Boolean(el.getAttribute('data-is-root-node'))\n}\n\nfunction getListItemStyle(el: Node): 'bullet' | 'number' | undefined {\n  const parentTag = tagName(el.parentNode)\n  if (parentTag && !LIST_CONTAINER_TAGS.includes(parentTag)) {\n    return undefined\n  }\n  return tagName(el.parentNode) === 'ul' ? 'bullet' : 'number'\n}\n\nfunction getListItemLevel(el: Node): number {\n  let level = 0\n  if (tagName(el) === 'li') {\n    let parentNode = el.parentNode\n    while (parentNode) {\n      const parentTag = tagName(parentNode)\n      if (parentTag && LIST_CONTAINER_TAGS.includes(parentTag)) {\n        level++\n      }\n      parentNode = parentNode.parentNode\n    }\n  } else {\n    level = 1\n  }\n  return level\n}\n\nconst blocks: Record<string, {style: string} | undefined> = {\n  ...HTML_BLOCK_TAGS,\n  ...HTML_HEADER_TAGS,\n}\n\nfunction getBlockStyle(schema: Schema, el: Node): string {\n  const childTag = tagName(el.firstChild)\n  const block = childTag && blocks[childTag]\n  if (!block) {\n    return BLOCK_DEFAULT_STYLE\n  }\n  if (!schema.styles.some((style) => style.name === block.style)) {\n    return BLOCK_DEFAULT_STYLE\n  }\n  return block.style\n}\n\nexport function createGDocsRules(schema: Schema): DeserializerRule[] {\n  return [\n    {\n      deserialize(el, next) {\n        if (isElement(el) && tagName(el) === 'span' && isGoogleDocs(el)) {\n          if (!el.textContent) {\n            if (!el.previousSibling && !el.nextSibling) {\n              el.setAttribute('data-lonely-child', 'true')\n            }\n\n            return next(el.childNodes)\n          }\n\n          const span = {\n            ...DEFAULT_SPAN,\n            marks: [] as string[],\n            text: el.textContent,\n          }\n          if (isStrong(el)) {\n            span.marks.push('strong')\n          }\n          if (isUnderline(el)) {\n            span.marks.push('underline')\n          }\n          if (isStrikethrough(el)) {\n            span.marks.push('strike-through')\n          }\n          if (isEmphasis(el)) {\n            span.marks.push('em')\n          }\n          return span\n        }\n        return undefined\n      },\n    },\n    {\n      deserialize(el, next) {\n        if (tagName(el) === 'li' && isGoogleDocs(el)) {\n          return {\n            ...DEFAULT_BLOCK,\n            listItem: getListItemStyle(el),\n            level: getListItemLevel(el),\n            style: getBlockStyle(schema, el),\n            children: next(el.firstChild?.childNodes || []),\n          }\n        }\n        return undefined\n      },\n    },\n    {\n      deserialize(el) {\n        if (\n          tagName(el) === 'br' &&\n          isGoogleDocs(el) &&\n          isElement(el) &&\n          el.classList.contains('apple-interchange-newline')\n        ) {\n          return {\n            ...DEFAULT_SPAN,\n            text: '',\n          }\n        }\n\n        // BRs inside empty paragraphs\n        if (\n          tagName(el) === 'br' &&\n          isGoogleDocs(el) &&\n          isElement(el) &&\n          el?.parentNode?.textContent === ''\n        ) {\n          return {\n            ...DEFAULT_SPAN,\n            text: '',\n          }\n        }\n\n        // BRs on the root\n        if (\n          tagName(el) === 'br' &&\n          isGoogleDocs(el) &&\n          isElement(el) &&\n          isRootNode(el)\n        ) {\n          return {\n            ...DEFAULT_SPAN,\n            text: '',\n          }\n        }\n        return undefined\n      },\n    },\n  ]\n}\n","import {DEFAULT_SPAN} from '../../constants'\nimport type {DeserializerRule} from '../../types'\nimport {tagName} from '../helpers'\n\nexport const whitespaceTextNodeRule: DeserializerRule = {\n  deserialize(node) {\n    return node.nodeName === '#text' && isWhitespaceTextNode(node)\n      ? {\n          ...DEFAULT_SPAN,\n          marks: [],\n          text: (node.textContent ?? '').replace(/\\s\\s+/g, ' '),\n        }\n      : undefined\n  },\n}\n\nfunction isWhitespaceTextNode(node: Node) {\n  const isWhitespaceOnly =\n    node.nodeType === 3 &&\n    (node.textContent || '').replace(/[\\r\\n]/g, ' ').replace(/\\s\\s+/g, ' ') ===\n      ' '\n\n  const hasSiblingContext =\n    node.nextSibling &&\n    node.nextSibling.nodeType !== 3 &&\n    node.previousSibling &&\n    node.previousSibling.nodeType !== 3\n\n  // When a whitespace text node is the sole child of an inline element (e.g.\n  // <span> </span>), check the parent element's siblings instead. The parent\n  // must have non-text siblings on both sides (matching the same pattern as\n  // the direct sibling check above).\n  const parentIsInline = node.parentNode && tagName(node.parentNode) === 'span'\n  const hasParentSiblingContext =\n    parentIsInline &&\n    !node.nextSibling &&\n    !node.previousSibling &&\n    node.parentNode!.previousSibling &&\n    node.parentNode!.previousSibling.nodeType !== 3 &&\n    node.parentNode!.nextSibling &&\n    node.parentNode!.nextSibling.nodeType !== 3\n\n  const isValidWhiteSpace =\n    isWhitespaceOnly && (hasSiblingContext || hasParentSiblingContext)\n\n  return (\n    (isValidWhiteSpace || node.textContent !== ' ') &&\n    tagName(node.parentNode) !== 'body'\n  )\n}\n","import type {Schema} from '@portabletext/schema'\nimport {\n  DEFAULT_BLOCK,\n  DEFAULT_SPAN,\n  HTML_BLOCK_TAGS,\n  HTML_DECORATOR_TAGS,\n  HTML_HEADER_TAGS,\n  HTML_LIST_CONTAINER_TAGS,\n  HTML_LIST_ITEM_TAGS,\n  HTML_SPAN_TAGS,\n  type PartialBlock,\n} from '../../constants'\nimport type {SchemaMatchers} from '../../schema-matchers'\nimport type {DeserializerRule} from '../../types'\nimport {keyGenerator} from '../../util/randomKey'\nimport {isElement, tagName} from '../helpers'\nimport {whitespaceTextNodeRule} from './rules.whitespace-text-node'\n\nfunction resolveListItem(\n  schema: Schema,\n  listNodeTagName: string,\n): string | undefined {\n  if (\n    listNodeTagName === 'ul' &&\n    schema.lists.some((list) => list.name === 'bullet')\n  ) {\n    return 'bullet'\n  }\n  if (\n    listNodeTagName === 'ol' &&\n    schema.lists.some((list) => list.name === 'number')\n  ) {\n    return 'number'\n  }\n  return undefined\n}\n\nexport function createHTMLRules(\n  schema: Schema,\n  options: {keyGenerator?: () => string; matchers?: SchemaMatchers},\n): DeserializerRule[] {\n  return [\n    whitespaceTextNodeRule,\n    {\n      // Pre element\n      deserialize(el) {\n        if (tagName(el) !== 'pre') {\n          return undefined\n        }\n\n        const isCodeEnabled = schema.styles.some(\n          (style) => style.name === 'code',\n        )\n\n        return {\n          _type: 'block',\n          style: 'normal',\n          markDefs: [],\n          children: [\n            {\n              ...DEFAULT_SPAN,\n              marks: isCodeEnabled ? ['code'] : [],\n              text: el.textContent || '',\n            },\n          ],\n        }\n      },\n    }, // Blockquote element\n    {\n      deserialize(el, next) {\n        if (tagName(el) !== 'blockquote') {\n          return undefined\n        }\n        const blocks: Record<string, PartialBlock | undefined> = {\n          ...HTML_BLOCK_TAGS,\n          ...HTML_HEADER_TAGS,\n        }\n        delete blocks.blockquote\n        const nonBlockquoteBlocks = Object.keys(blocks)\n\n        const children: HTMLElement[] = []\n\n        el.childNodes.forEach((node, index) => {\n          if (!el.ownerDocument) {\n            return\n          }\n\n          if (\n            node.nodeType === 1 &&\n            nonBlockquoteBlocks.includes(\n              (node as Element).localName.toLowerCase(),\n            )\n          ) {\n            const span = el.ownerDocument.createElement('span')\n\n            const previousChild = children[children.length - 1]\n\n            if (\n              previousChild &&\n              previousChild.nodeType === 3 &&\n              previousChild.textContent?.trim()\n            ) {\n              // Only prepend line break if the previous node is a non-empty\n              // text node.\n              span.appendChild(el.ownerDocument.createTextNode('\\r'))\n            }\n\n            node.childNodes.forEach((cn) => {\n              span.appendChild(cn.cloneNode(true))\n            })\n\n            if (index !== el.childNodes.length) {\n              // Only append line break if this is not the last child\n              span.appendChild(el.ownerDocument.createTextNode('\\r'))\n            }\n\n            children.push(span)\n          } else {\n            children.push(node as HTMLElement)\n          }\n        })\n\n        return {\n          _type: 'block',\n          style: 'blockquote',\n          markDefs: [],\n          children: next(children),\n        }\n      },\n    }, // Block elements\n    {\n      deserialize(el, next) {\n        const blocks: Record<string, PartialBlock | undefined> = {\n          ...HTML_BLOCK_TAGS,\n          ...HTML_HEADER_TAGS,\n        }\n        const tag = tagName(el)\n        let block = tag ? blocks[tag] : undefined\n        if (!block) {\n          return undefined\n        }\n        // Don't add blocks into list items\n        if (el.parentNode && tagName(el.parentNode) === 'li') {\n          return next(el.childNodes)\n        }\n        const blockStyle = block.style\n        // If style is not supported, return a defaultBlockType\n        if (!schema.styles.some((style) => style.name === blockStyle)) {\n          block = DEFAULT_BLOCK\n        }\n        return {\n          ...block,\n          children: next(el.childNodes),\n        }\n      },\n    }, // Ignore span tags\n    {\n      deserialize(el, next) {\n        const tag = tagName(el)\n        if (!tag || !(tag in HTML_SPAN_TAGS)) {\n          return undefined\n        }\n        return next(el.childNodes)\n      },\n    }, // Ignore div tags\n    {\n      deserialize(el, next) {\n        const div = tagName(el) === 'div'\n        if (!div) {\n          return undefined\n        }\n        return next(el.childNodes)\n      },\n    }, // Ignore list containers\n    {\n      deserialize(el, next) {\n        const tag = tagName(el)\n        if (!tag || !(tag in HTML_LIST_CONTAINER_TAGS)) {\n          return undefined\n        }\n        return next(el.childNodes)\n      },\n    }, // Deal with br's\n    {\n      deserialize(el) {\n        if (tagName(el) === 'br') {\n          return {\n            ...DEFAULT_SPAN,\n            text: '\\n',\n          }\n        }\n        return undefined\n      },\n    }, // Deal with list items\n    {\n      deserialize(el, next, block) {\n        const tag = tagName(el)\n        const listItem = tag ? HTML_LIST_ITEM_TAGS[tag] : undefined\n        if (!listItem) {\n          return undefined\n        }\n        // Fall back to 'ul' when the list item has no list container parent\n        // (e.g. orphan <li> elements without a <ul> or <ol> wrapper).\n        const parentTag = tagName(el.parentNode) || ''\n        const listTag = HTML_LIST_CONTAINER_TAGS[parentTag] ? parentTag : 'ul'\n        const enabledListItem = resolveListItem(schema, listTag)\n        // If the list item style is not supported, return a new default block\n        if (!enabledListItem) {\n          return block({_type: 'block', children: next(el.childNodes)})\n        }\n        listItem.listItem = enabledListItem\n        return {\n          ...listItem,\n          children: next(el.childNodes),\n        }\n      },\n    }, // Deal with decorators - this is a limited set of known html elements that we know how to deserialize\n    {\n      deserialize(el, next) {\n        const decorator = HTML_DECORATOR_TAGS[tagName(el) || '']\n        if (\n          !decorator ||\n          !schema.decorators.some(\n            (decoratorType) => decoratorType.name === decorator,\n          )\n        ) {\n          return undefined\n        }\n        return {\n          _type: '__decorator',\n          name: decorator,\n          children: next(el.childNodes),\n        }\n      },\n    }, // Special case for hyperlinks, add annotation (if allowed by schema),\n    // If not supported just write out the link text and href in plain text.\n    {\n      deserialize(el, next) {\n        if (tagName(el) !== 'a') {\n          return undefined\n        }\n        const linkEnabled = schema.annotations.some(\n          (annotation) => annotation.name === 'link',\n        )\n        const href = isElement(el) && el.getAttribute('href')\n        if (!href) {\n          return next(el.childNodes)\n        }\n        if (linkEnabled) {\n          return {\n            _type: '__annotation',\n            markDef: {\n              _key: options.keyGenerator\n                ? options.keyGenerator()\n                : keyGenerator(),\n              _type: 'link',\n              href: href,\n            },\n            children: next(el.childNodes),\n          }\n        }\n        return (\n          el.appendChild(el.ownerDocument.createTextNode(` (${href})`)) &&\n          next(el.childNodes)\n        )\n      },\n    },\n    {\n      deserialize(el, next) {\n        if (isElement(el) && (tagName(el) === 'td' || tagName(el) === 'th')) {\n          return {\n            ...DEFAULT_BLOCK,\n            children: next(el.childNodes),\n          }\n        }\n\n        return undefined\n      },\n    },\n    {\n      deserialize(el) {\n        if (isElement(el) && tagName(el) === 'img') {\n          const src = el.getAttribute('src') ?? undefined\n          const alt = el.getAttribute('alt') ?? undefined\n\n          const props = Object.fromEntries(\n            Array.from(el.attributes).map((attr) => [attr.name, attr.value]),\n          )\n\n          const ancestorOfLonelyChild =\n            el?.parentElement?.parentElement?.getAttribute('data-lonely-child')\n          const ancestorOfListItem = el.closest('li') !== null\n\n          if (ancestorOfLonelyChild && !ancestorOfListItem) {\n            const image = options.matchers?.image?.({\n              context: {\n                schema,\n                keyGenerator: options.keyGenerator ?? keyGenerator,\n              },\n              props: {\n                ...props,\n                ...(src ? {src} : {}),\n                ...(alt ? {alt} : {}),\n              },\n            })\n\n            if (image) {\n              return {\n                _type: '__block',\n                block: image,\n              }\n            }\n          }\n\n          const inlineImage = options.matchers?.inlineImage?.({\n            context: {\n              schema,\n              keyGenerator: options.keyGenerator ?? keyGenerator,\n            },\n            props: {\n              ...props,\n              ...(src ? {src} : {}),\n              ...(alt ? {alt} : {}),\n            },\n          })\n\n          if (inlineImage) {\n            return inlineImage\n          }\n\n          const image = options.matchers?.image?.({\n            context: {\n              schema,\n              keyGenerator: options.keyGenerator ?? keyGenerator,\n            },\n            props: {\n              ...props,\n              ...(src ? {src} : {}),\n              ...(alt ? {alt} : {}),\n            },\n          })\n\n          if (image) {\n            return {\n              _type: '__block',\n              block: image,\n            }\n          }\n        }\n\n        return undefined\n      },\n    },\n  ]\n}\n","import {DEFAULT_SPAN} from '../../constants'\nimport type {DeserializerRule} from '../../types'\nimport {isElement, tagName} from '../helpers'\n\n// font-style:italic seems like the most important rule for italic / emphasis in their html\nfunction isEmphasis(el: Node): boolean {\n  const style = isElement(el) && el.getAttribute('style')\n  return /font-style:italic/.test(style || '')\n}\n\n// font-weight:700 or 600 seems like the most important rule for bold in their html\nfunction isStrong(el: Node): boolean {\n  const style = isElement(el) && el.getAttribute('style')\n  return (\n    /font-weight:700/.test(style || '') || /font-weight:600/.test(style || '')\n  )\n}\n\n// text-decoration seems like the most important rule for underline in their html\nfunction isUnderline(el: Node): boolean {\n  const style = isElement(el) && el.getAttribute('style')\n  return /text-decoration:underline/.test(style || '')\n}\n\n// Check for attribute given by the Notion preprocessor\nfunction isNotion(el: Node): boolean {\n  return isElement(el) && Boolean(el.getAttribute('data-is-notion'))\n}\n\nexport function createNotionRules(): DeserializerRule[] {\n  return [\n    {\n      deserialize(el) {\n        // Notion normally exports semantic HTML. However, if you copy a single block, the formatting will be inline styles\n        // This handles a limited set of styles\n        if (isElement(el) && tagName(el) === 'span' && isNotion(el)) {\n          const span = {\n            ...DEFAULT_SPAN,\n            marks: [] as string[],\n            text: el.textContent,\n          }\n          if (isStrong(el)) {\n            span.marks.push('strong')\n          }\n          if (isUnderline(el)) {\n            span.marks.push('underline')\n          }\n          if (isEmphasis(el)) {\n            span.marks.push('em')\n          }\n          return span\n        }\n        return undefined\n      },\n    },\n  ]\n}\n","import {\n  BLOCK_DEFAULT_STYLE,\n  DEFAULT_BLOCK,\n  HTML_HEADER_TAGS,\n} from '../../constants'\nimport type {DeserializerRule} from '../../types'\nimport {isElement, tagName} from '../helpers'\n\nfunction getListItemStyle(el: Node): string | undefined {\n  const style = isElement(el) && el.getAttribute('style')\n  if (!style) {\n    return undefined\n  }\n\n  if (!style.match(/lfo\\d+/)) {\n    return undefined\n  }\n\n  return style.match('lfo1') ? 'number' : 'bullet'\n}\n\nfunction getListItemLevel(el: Node): number | undefined {\n  const style = isElement(el) && el.getAttribute('style')\n  if (!style) {\n    return undefined\n  }\n\n  const levelMatch = style.match(/level\\d+/)\n  if (!levelMatch) {\n    return undefined\n  }\n\n  const [level] = levelMatch[0].match(/\\d/) || []\n  const levelNum = level ? Number.parseInt(level, 10) : 1\n  return levelNum || 1\n}\n\nfunction isWordListElement(el: Node): boolean {\n  if (!isElement(el)) {\n    return false\n  }\n\n  // Check for specific class names\n  if (el.className) {\n    if (\n      el.className === 'MsoListParagraphCxSpFirst' ||\n      el.className === 'MsoListParagraphCxSpMiddle' ||\n      el.className === 'MsoListParagraphCxSpLast'\n    ) {\n      return true\n    }\n  }\n\n  // Check for mso-list in style attribute\n  const style = el.getAttribute('style')\n  if (style && /mso-list:\\s*l\\d+\\s+level\\d+\\s+lfo\\d+/.test(style)) {\n    return true\n  }\n\n  return false\n}\n\nfunction getHeadingStyle(el: Node): string | undefined {\n  const tag = tagName(el)\n  if (tag && HTML_HEADER_TAGS[tag]) {\n    return HTML_HEADER_TAGS[tag]?.style\n  }\n  return undefined\n}\n\nexport function createWordRules(): DeserializerRule[] {\n  return [\n    {\n      deserialize(el, next) {\n        const tag = tagName(el)\n\n        // Handle list items (both paragraphs and headings)\n        if (\n          (tag === 'p' || HTML_HEADER_TAGS[tag || '']) &&\n          isWordListElement(el)\n        ) {\n          const headingStyle = getHeadingStyle(el)\n          return {\n            ...DEFAULT_BLOCK,\n            listItem: getListItemStyle(el),\n            level: getListItemLevel(el),\n            style: headingStyle || BLOCK_DEFAULT_STYLE,\n            children: next(el.childNodes),\n          }\n        }\n        return undefined\n      },\n    },\n  ]\n}\n","import type {Schema} from '@portabletext/schema'\nimport type {SchemaMatchers} from '../../schema-matchers'\nimport type {DeserializerRule} from '../../types'\nimport {createWordOnlineRules} from '../word-online/rules.word-online'\nimport {createGDocsRules} from './rules.gdocs'\nimport {createHTMLRules} from './rules.html'\nimport {createNotionRules} from './rules.notion'\nimport {createWordRules} from './rules.word'\n\nexport function createRules(\n  schema: Schema,\n  options: {keyGenerator?: () => string; matchers?: SchemaMatchers},\n): DeserializerRule[] {\n  return [\n    ...createWordRules(),\n    ...createWordOnlineRules(schema, options),\n    ...createNotionRules(),\n    ...createGDocsRules(schema),\n    ...createHTMLRules(schema, options),\n  ]\n}\n","import {\n  isSpan,\n  isTextBlock,\n  type PortableTextTextBlock,\n  type Schema,\n} from '@portabletext/schema'\nimport {isEqualMarks} from '../equality'\nimport type {TypedObject, WhiteSpacePasteMode} from '../types'\nimport {isMinimalSpan} from './helpers'\n\nexport function trimWhitespace(\n  context: {schema: Schema},\n  mode: WhiteSpacePasteMode,\n  blocks: TypedObject[],\n): TypedObject[] {\n  const trimmedBlocks: TypedObject[] = []\n  let consecutiveEmptyCount = 0\n\n  for (const block of blocks) {\n    const trimmedBlock = isTextBlock(context, block)\n      ? trimTextBlockWhitespace(block)\n      : block\n\n    if (mode === 'preserve') {\n      trimmedBlocks.push(trimmedBlock)\n\n      continue\n    }\n\n    if (mode === 'remove') {\n      if (isEmptyTextBlock(context, trimmedBlock)) {\n        continue\n      }\n\n      trimmedBlocks.push(trimmedBlock)\n\n      continue\n    }\n\n    if (mode === 'normalize') {\n      if (isEmptyTextBlock(context, trimmedBlock)) {\n        consecutiveEmptyCount++\n\n        if (consecutiveEmptyCount === 1) {\n          trimmedBlocks.push(trimmedBlock)\n        }\n\n        continue\n      }\n\n      trimmedBlocks.push(trimmedBlock)\n\n      consecutiveEmptyCount = 0\n    }\n  }\n\n  return trimmedBlocks\n}\n\nfunction isEmptyTextBlock(\n  context: {schema: Schema},\n  block: TypedObject,\n): boolean {\n  if (!isTextBlock(context, block)) {\n    return false\n  }\n\n  if (\n    block.children.some(\n      (child) => !isSpan(context, child) || child.text.trim() !== '',\n    )\n  ) {\n    return false\n  }\n\n  return true\n}\n\nfunction trimTextBlockWhitespace(\n  block: PortableTextTextBlock,\n): PortableTextTextBlock {\n  let index = 0\n\n  for (const child of block.children) {\n    if (!isMinimalSpan(child)) {\n      index++\n      continue\n    }\n\n    const nextChild = nextSpan(block, index)\n    const prevChild = prevSpan(block, index)\n\n    if (index === 0) {\n      child.text = child.text.replace(/^[^\\S\\n]+/g, '')\n    }\n\n    if (index === block.children.length - 1) {\n      child.text = child.text.replace(/[^\\S\\n]+$/g, '')\n    }\n\n    if (\n      /\\s/.test(child.text.slice(Math.max(0, child.text.length - 1))) &&\n      nextChild &&\n      isMinimalSpan(nextChild) &&\n      /\\s/.test(nextChild.text.slice(0, 1))\n    ) {\n      child.text = child.text.replace(/[^\\S\\n]+$/g, '')\n    }\n\n    if (\n      /\\s/.test(child.text.slice(0, 1)) &&\n      prevChild &&\n      isMinimalSpan(prevChild) &&\n      /\\s/.test(prevChild.text.slice(Math.max(0, prevChild.text.length - 1)))\n    ) {\n      child.text = child.text.replace(/^[^\\S\\n]+/g, '')\n    }\n\n    if (!child.text) {\n      block.children.splice(index, 1)\n    }\n\n    if (\n      prevChild &&\n      Array.isArray(prevChild.marks) &&\n      isEqualMarks(prevChild.marks, child.marks) &&\n      isWhiteSpaceChar(child.text)\n    ) {\n      prevChild.text += ' '\n      block.children.splice(index, 1)\n    } else if (\n      nextChild &&\n      Array.isArray(nextChild.marks) &&\n      isEqualMarks(nextChild.marks, child.marks) &&\n      isWhiteSpaceChar(child.text)\n    ) {\n      nextChild.text = ` ${nextChild.text}`\n      block.children.splice(index, 1)\n    }\n\n    index++\n  }\n\n  return block\n}\n\nfunction nextSpan(block: PortableTextTextBlock, index: number) {\n  const next = block.children[index + 1]\n  return next && next._type === 'span' ? next : null\n}\n\nfunction prevSpan(block: PortableTextTextBlock, index: number) {\n  const prev = block.children[index - 1]\n  return prev && prev._type === 'span' ? prev : null\n}\n\nfunction isWhiteSpaceChar(text: string) {\n  return ['\\xa0', ' '].includes(text)\n}\n","import type {Schema} from '@portabletext/schema'\nimport {\n  isTextBlock,\n  type PortableTextBlock,\n  type PortableTextObject,\n} from '@portabletext/schema'\nimport {vercelStegaClean} from '@vercel/stega'\nimport type {\n  ArbitraryTypedObject,\n  DeserializerRule,\n  HtmlDeserializerOptions,\n  PlaceholderAnnotation,\n  PlaceholderDecorator,\n  TypedObject,\n} from '../types'\nimport {keyGenerator} from '../util/randomKey'\nimport {resolveJsType} from '../util/resolveJsType'\nimport {flattenNestedBlocks} from './flatten-nested-blocks'\nimport {\n  defaultParseHtml,\n  ensureRootIsBlocks,\n  isMinimalBlock,\n  isMinimalSpan,\n  isNodeList,\n  isPlaceholderAnnotation,\n  isPlaceholderDecorator,\n  tagName,\n} from './helpers'\nimport {preprocessors} from './preprocessors'\nimport {createRules} from './rules'\nimport {trimWhitespace} from './trim-whitespace'\n\n/**\n * HTML Deserializer\n *\n */\nexport default class HtmlDeserializer {\n  keyGenerator: () => string\n  schema: Schema\n  rules: DeserializerRule[]\n  parseHtml: (html: string) => HTMLElement\n  whitespaceMode: 'preserve' | 'remove' | 'normalize'\n  _markDefs: PortableTextObject[] = []\n\n  /**\n   * Create a new serializer respecting a Sanity block content type's schema\n   *\n   * @param blockContentType - Schema type for array containing _at least_ a block child type\n   * @param options - Options for the deserialization process\n   */\n  constructor(schema: Schema, options: HtmlDeserializerOptions = {}) {\n    const {rules = [], unstable_whitespaceOnPasteMode = 'preserve'} = options\n    const standardRules = createRules(schema, {\n      keyGenerator: options.keyGenerator,\n      matchers: options.matchers,\n    })\n    this.schema = schema\n    this.keyGenerator = options.keyGenerator ?? keyGenerator\n    this.rules = [...rules, ...standardRules]\n    this.whitespaceMode = unstable_whitespaceOnPasteMode\n    const parseHtml = options.parseHtml || defaultParseHtml()\n    this.parseHtml = (html) => {\n      const cleanHTML = vercelStegaClean(html)\n      const doc = parseHtml(cleanHTML)\n\n      for (const processor of preprocessors) {\n        processor(cleanHTML, doc)\n      }\n\n      return doc.body\n    }\n  }\n\n  /**\n   * Deserialize HTML.\n   *\n   * @param html - The HTML to deserialize, as a string\n   * @returns Array of blocks - either portable text blocks or other allowed blocks\n   */\n  deserialize = (html: string): TypedObject[] => {\n    this._markDefs = []\n    const {parseHtml} = this\n    const fragment = parseHtml(html)\n    const children = Array.from(fragment.childNodes) as HTMLElement[]\n\n    const blocks = trimWhitespace(\n      {schema: this.schema},\n      this.whitespaceMode,\n      flattenNestedBlocks(\n        {schema: this.schema},\n        ensureRootIsBlocks(\n          this.schema,\n          this.deserializeElements(children) as Array<ArbitraryTypedObject>,\n        ),\n      ),\n    )\n\n    if (this._markDefs.length > 0) {\n      blocks\n        .filter((block) => isTextBlock({schema: this.schema}, block))\n        .forEach((block) => {\n          block.markDefs = block.markDefs || []\n          block.markDefs = block.markDefs.concat(\n            this._markDefs.filter((def) => {\n              return block.children\n                .flatMap((child) => child.marks || [])\n                .includes(def._key)\n            }),\n          )\n        })\n    }\n\n    return blocks.map((block) => {\n      if (block._type === 'block') {\n        block._type = this.schema.block.name\n      }\n      return block\n    })\n  }\n\n  /**\n   * Deserialize an array of DOM elements.\n   *\n   * @param elements - Array of DOM elements to deserialize\n   * @returns\n   */\n  deserializeElements = (elements: Node[] = []): TypedObject[] => {\n    let nodes: TypedObject[] = []\n    elements.forEach((element) => {\n      nodes = nodes.concat(this.deserializeElement(element))\n    })\n    return nodes\n  }\n\n  /**\n   * Deserialize a DOM element\n   *\n   * @param element - Deserialize a DOM element\n   * @returns\n   */\n  deserializeElement = (element: Node): TypedObject | TypedObject[] => {\n    const next = (\n      elements: Node | Node[] | NodeList,\n    ): TypedObject | TypedObject[] | undefined => {\n      if (isNodeList(elements)) {\n        return this.deserializeElements(Array.from(elements))\n      }\n\n      if (Array.isArray(elements)) {\n        return this.deserializeElements(elements)\n      }\n\n      if (!elements) {\n        return undefined\n      }\n\n      return this.deserializeElement(elements)\n    }\n\n    const block = (props: ArbitraryTypedObject) => {\n      return {\n        _type: '__block',\n        block: props,\n      }\n    }\n\n    let node: TypedObject | Array<TypedObject> | undefined\n    for (let i = 0; i < this.rules.length; i++) {\n      const rule = this.rules[i]\n      if (!rule.deserialize) {\n        continue\n      }\n\n      const ret = rule.deserialize(element, next, block)\n      const type = resolveJsType(ret)\n\n      if (\n        type !== 'array' &&\n        type !== 'object' &&\n        type !== 'null' &&\n        type !== 'undefined'\n      ) {\n        throw new Error(\n          `A rule returned an invalid deserialized representation: \"${node}\".`,\n        )\n      }\n\n      if (ret === undefined) {\n        continue\n      } else if (ret === null) {\n        throw new Error('Deserializer rule returned `null`')\n      } else if (Array.isArray(ret)) {\n        node = ret\n      } else if (isPlaceholderDecorator(ret)) {\n        node = this.deserializeDecorator(ret)\n      } else if (isPlaceholderAnnotation(ret)) {\n        node = this.deserializeAnnotation(ret)\n      } else {\n        node = ret\n      }\n\n      // Set list level on list item\n      if (\n        ret &&\n        !Array.isArray(ret) &&\n        isMinimalBlock(ret) &&\n        'listItem' in ret\n      ) {\n        let parent = element.parentNode?.parentNode\n        while (parent && tagName(parent) === 'li') {\n          parent = parent.parentNode?.parentNode\n          ret.level = ret.level ? ret.level + 1 : 1\n        }\n      }\n\n      // Set newlines on spans orginating from a block element within a blockquote\n      if (\n        ret &&\n        !Array.isArray(ret) &&\n        isMinimalBlock(ret) &&\n        ret.style === 'blockquote'\n      ) {\n        ret.children.forEach((child, index) => {\n          if (isMinimalSpan(child) && child.text === '\\r') {\n            child.text = '\\n'\n            if (index === 0 || index === ret.children.length - 1) {\n              ret.children.splice(index, 1)\n            }\n          }\n        })\n      }\n      break\n    }\n\n    return node || next(element.childNodes) || []\n  }\n\n  /**\n   * Deserialize a `__decorator` type\n   * (an internal made up type to process decorators exclusively)\n   *\n   * @param decorator -\n   * @returns array of ...\n   */\n  deserializeDecorator = (decorator: PlaceholderDecorator): TypedObject[] => {\n    const {name} = decorator\n    const applyDecorator = (node: TypedObject) => {\n      if (isPlaceholderDecorator(node)) {\n        return this.deserializeDecorator(node)\n      } else if (isMinimalSpan(node)) {\n        node.marks = node.marks || []\n        if (node.text.trim()) {\n          // Only apply marks if this is an actual text\n          node.marks.unshift(name)\n        }\n      } else if (\n        'children' in node &&\n        Array.isArray((node as PortableTextBlock).children)\n      ) {\n        const block = node as any\n        block.children = block.children.map(applyDecorator)\n      }\n      return node\n    }\n    return decorator.children.reduce((children, node) => {\n      const ret = applyDecorator(node)\n      if (Array.isArray(ret)) {\n        return children.concat(ret)\n      }\n      children.push(ret)\n      return children\n    }, [] as TypedObject[])\n  }\n\n  /**\n   * Deserialize a `__annotation` object.\n   * (an internal made up type to process annotations exclusively)\n   *\n   * @param annotation -\n   * @returns Array of...\n   */\n  deserializeAnnotation = (\n    annotation: PlaceholderAnnotation,\n  ): TypedObject[] => {\n    const {markDef} = annotation\n    this._markDefs.push(markDef)\n    const applyAnnotation = (node: TypedObject) => {\n      if (isPlaceholderAnnotation(node)) {\n        return this.deserializeAnnotation(node)\n      } else if (isMinimalSpan(node)) {\n        node.marks = node.marks || []\n        if (node.text.trim()) {\n          // Only apply marks if this is an actual text\n          node.marks.unshift(markDef._key)\n        }\n      } else if (\n        'children' in node &&\n        Array.isArray((node as PortableTextBlock).children)\n      ) {\n        const block = node as any\n        block.children = block.children.map(applyAnnotation)\n      }\n      return node\n    }\n    return annotation.children.reduce((children, node) => {\n      const ret = applyAnnotation(node)\n      if (Array.isArray(ret)) {\n        return children.concat(ret)\n      }\n      children.push(ret)\n      return children\n    }, [] as TypedObject[])\n  }\n}\n","import type {Schema} from '@portabletext/schema'\nimport {\n  isSpan,\n  type PortableTextSpan,\n  type PortableTextTextBlock,\n} from '@portabletext/schema'\nimport {isEqualMarks} from '../equality'\nimport type {TypedObject} from '../types'\nimport {keyGenerator} from './randomKey'\n\n/**\n * Block normalization options\n *\n * @public\n */\nexport interface BlockNormalizationOptions {\n  /**\n   * Decorator names that are allowed within portable text blocks, eg `em`, `strong`\n   */\n  allowedDecorators?: string[]\n\n  /**\n   * Name of the portable text block type, if not `block`\n   */\n  blockTypeName?: string\n\n  /**\n   * Custom key generator function\n   */\n  keyGenerator?: () => string\n}\n\n/**\n * Normalizes a block by ensuring it has a `_key` property. If the block is a\n * portable text block, additional normalization is applied:\n *\n * - Ensures it has `children` and `markDefs` properties\n * - Ensures it has at least one child (adds an empty span if empty)\n * - Joins sibling spans that has the same marks\n * - Removes decorators that are not allowed according to the schema\n * - Removes marks that have no annotation definition\n *\n * @param node - The block to normalize\n * @param options - Options for normalization process. See {@link BlockNormalizationOptions}\n * @returns Normalized block\n * @public\n */\nexport function normalizeBlock(\n  node: TypedObject,\n  options: BlockNormalizationOptions = {},\n): Omit<\n  TypedObject | PortableTextTextBlock<TypedObject | PortableTextSpan>,\n  '_key'\n> & {\n  _key: string\n} {\n  const schema: Schema = {\n    block: {\n      name: options.blockTypeName || 'block',\n    },\n    span: {\n      name: 'span',\n    },\n    styles: [],\n    lists: [],\n    decorators: [],\n    annotations: [],\n    blockObjects: [],\n    inlineObjects: [],\n  }\n\n  if (node._type !== (options.blockTypeName || 'block')) {\n    return '_key' in node\n      ? (node as TypedObject & {_key: string})\n      : {\n          ...node,\n          _key: options.keyGenerator ? options.keyGenerator() : keyGenerator(),\n        }\n  }\n\n  const block: Omit<\n    PortableTextTextBlock<TypedObject | PortableTextSpan>,\n    'style'\n  > = {\n    _key: options.keyGenerator ? options.keyGenerator() : keyGenerator(),\n    children: [],\n    markDefs: [],\n    ...node,\n  }\n\n  const lastChild = block.children[block.children.length - 1]\n\n  if (!lastChild) {\n    // A block must at least have an empty span type child\n    block.children = [\n      {\n        _type: 'span',\n        _key: options.keyGenerator ? options.keyGenerator() : keyGenerator(),\n        text: '',\n        marks: [],\n      },\n    ]\n    return block\n  }\n\n  const usedMarkDefs: string[] = []\n  const allowedDecorators =\n    options.allowedDecorators && Array.isArray(options.allowedDecorators)\n      ? options.allowedDecorators\n      : false\n\n  block.children = block.children\n    .reduce(\n      (acc, child) => {\n        const previousChild = acc[acc.length - 1]\n        if (\n          previousChild &&\n          isSpan({schema}, child) &&\n          isSpan({schema}, previousChild) &&\n          isEqualMarks(previousChild.marks, child.marks)\n        ) {\n          if (\n            lastChild &&\n            lastChild === child &&\n            child.text === '' &&\n            block.children.length > 1\n          ) {\n            return acc\n          }\n\n          previousChild.text += child.text\n          return acc\n        }\n        acc.push(child)\n        return acc\n      },\n      [] as (TypedObject | PortableTextSpan)[],\n    )\n    .map((child) => {\n      if (!child) {\n        throw new Error('missing child')\n      }\n\n      child._key = options.keyGenerator\n        ? options.keyGenerator()\n        : keyGenerator()\n\n      if (isSpan({schema}, child)) {\n        if (!child.marks) {\n          child.marks = []\n        } else if (allowedDecorators) {\n          child.marks = child.marks.filter((mark) => {\n            const isAllowed = allowedDecorators.includes(mark)\n            const isUsed = block.markDefs?.some((def) => def._key === mark)\n            return isAllowed || isUsed\n          })\n        }\n\n        usedMarkDefs.push(...child.marks)\n      }\n\n      return child\n    })\n\n  // Remove leftover (unused) markDefs\n  block.markDefs = (block.markDefs || []).filter((markDef) =>\n    usedMarkDefs.includes(markDef._key),\n  )\n\n  return block\n}\n","import {sanitySchemaToPortableTextSchema} from '@portabletext/sanity-bridge'\nimport type {Schema} from '@portabletext/schema'\nimport type {ArraySchemaType} from '@sanity/types'\nimport HtmlDeserializer from './HtmlDeserializer'\nimport type {HtmlDeserializerOptions, TypedObject} from './types'\nimport {normalizeBlock} from './util/normalizeBlock'\n\n/**\n * Convert HTML to blocks respecting the block content type's schema\n *\n * @param html - The HTML to convert to blocks\n * @param schemaType - A compiled version of the schema type for the block content\n * @param options - Options for deserializing HTML to blocks\n * @returns Array of blocks\n * @public\n */\nexport function htmlToBlocks(\n  html: string,\n  schemaType: ArraySchemaType | Schema,\n  options: HtmlDeserializerOptions = {},\n) {\n  const schema = isSanitySchema(schemaType)\n    ? sanitySchemaToPortableTextSchema(schemaType)\n    : schemaType\n\n  const deserializer = new HtmlDeserializer(schema, options)\n  return deserializer\n    .deserialize(html)\n    .map((block) => normalizeBlock(block, {keyGenerator: options.keyGenerator}))\n}\n\nexport type {ImageSchemaMatcher, SchemaMatchers} from './schema-matchers'\nexport type {ArbitraryTypedObject, DeserializerRule, HtmlParser} from './types'\nexport type {\n  PortableTextBlock,\n  PortableTextObject,\n  PortableTextSpan,\n  PortableTextTextBlock,\n} from '@portabletext/schema'\nexport type {BlockNormalizationOptions} from './util/normalizeBlock'\nexport {randomKey} from './util/randomKey'\nexport {normalizeBlock}\nexport type {HtmlDeserializerOptions, TypedObject}\n\nfunction isSanitySchema(\n  schema: ArraySchemaType | Schema,\n): schema is ArraySchemaType {\n  return schema.hasOwnProperty('jsonType')\n}\n"],"names":["_","span","isEmphasis","isStrong","isUnderline","getListItemStyle","getListItemLevel","blocks","image","vercelStegaClean"],"mappings":"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"}},
    {"offset": {"line": 2434, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@portabletext/to-html/dist/index.js","sources":["file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/to-html/src/escape.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/to-html/src/components/list.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/to-html/src/components/marks.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/to-html/src/warnings.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/to-html/src/components/unknown.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/to-html/src/components/defaults.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/to-html/src/components/merge.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/to-html/src/to-html.ts"],"sourcesContent":["const allowedProtocols = ['http', 'https', 'mailto', 'tel']\nconst charMap: Record<string, string> = {\n  '&': 'amp',\n  '<': 'lt',\n  '>': 'gt',\n  '\"': 'quot',\n  \"'\": '#x27',\n}\n\nexport function escapeHTML(str: string): string {\n  return replaceMultipleSpaces(str.replace(/[&<>\"']/g, (s) => `&${charMap[s]};`))\n}\n\nexport function replaceMultipleSpaces(str: string): string {\n  return str.replace(/ {2,}/g, (match: string) => `${'&nbsp;'.repeat(match.length - 1)} `)\n}\n\nexport function uriLooksSafe(uri: string): boolean {\n  const url = (uri || '').trim()\n  const first = url.charAt(0)\n\n  // Allow hash-links, absolute paths and \"same-protocol\" (//foo.bar) URLs\n  if (first === '#' || first === '/') {\n    return true\n  }\n\n  // If the URL does not contain a `:`, allow it\n  const colonIndex = url.indexOf(':')\n  if (colonIndex === -1) {\n    return true\n  }\n\n  // If the protocol is in the allowed list, treat it as OK\n  const proto = url.slice(0, colonIndex).toLowerCase()\n  if (allowedProtocols.indexOf(proto) !== -1) {\n    return true\n  }\n\n  // If the URL is `site/search?query=author:espen`, allow it\n  const queryIndex = url.indexOf('?')\n  if (queryIndex !== -1 && colonIndex > queryIndex) {\n    return true\n  }\n\n  // If the URL is `site/search#my:encoded:data`, allow it\n  const hashIndex = url.indexOf('#')\n  if (hashIndex !== -1 && colonIndex > hashIndex) {\n    return true\n  }\n\n  return false\n}\n","import type {PortableTextListComponent, PortableTextListItemComponent} from '../types'\n\nexport const defaultLists: Record<'number' | 'bullet', PortableTextListComponent> = {\n  number: ({children}) => `<ol>${children}</ol>`,\n  bullet: ({children}) => `<ul>${children}</ul>`,\n}\n\nexport const DefaultListItem: PortableTextListItemComponent = ({children}) => `<li>${children}</li>`\n","import type {TypedObject} from '@portabletext/types'\n\nimport type {PortableTextMarkComponent} from '../types'\n\nimport {escapeHTML, uriLooksSafe} from '../escape'\n\ninterface DefaultLink extends TypedObject {\n  _type: 'link'\n  href: string\n}\n\nconst link: PortableTextMarkComponent<DefaultLink> = ({children, value}) => {\n  const href = value?.href || ''\n  const looksSafe = uriLooksSafe(href)\n  return looksSafe ? `<a href=\"${escapeHTML(href)}\">${children}</a>` : children\n}\n\nexport const defaultMarks: Record<string, PortableTextMarkComponent | undefined> = {\n  em: ({children}) => `<em>${children}</em>`,\n  strong: ({children}) => `<strong>${children}</strong>`,\n  code: ({children}) => `<code>${children}</code>`,\n  underline: ({children}) => `<span style=\"text-decoration:underline\">${children}</span>`,\n  'strike-through': ({children}) => `<del>${children}</del>`,\n  link,\n}\n","const getTemplate = (type: string, prop: string): string =>\n  `Unknown ${type}, specify a component for it in the \\`components.${prop}\\` option`\n\nexport const unknownTypeWarning = (typeName: string): string =>\n  getTemplate(`block type \"${typeName}\"`, 'types')\n\nexport const unknownMarkWarning = (markType: string): string =>\n  getTemplate(`mark type \"${markType}\"`, 'marks')\n\nexport const unknownBlockStyleWarning = (blockStyle: string): string =>\n  getTemplate(`block style \"${blockStyle}\"`, 'block')\n\nexport const unknownListStyleWarning = (listStyle: string): string =>\n  getTemplate(`list style \"${listStyle}\"`, 'list')\n\nexport const unknownListItemStyleWarning = (listStyle: string): string =>\n  getTemplate(`list item style \"${listStyle}\"`, 'listItem')\n\nexport function printWarning(message: string): void {\n  // oxlint-disable-next-line no-console\n  console.warn(message)\n}\n","import type {PortableTextHtmlComponents} from '../types'\n\nimport {unknownTypeWarning} from '../warnings'\n\nexport const DefaultUnknownType: PortableTextHtmlComponents['unknownType'] = ({\n  value,\n  isInline,\n}) => {\n  const warning = unknownTypeWarning(value._type)\n  return isInline\n    ? `<span style=\"display:none\">${warning}</span>`\n    : `<div style=\"display:none\">${warning}</div>`\n}\n\nexport const DefaultUnknownMark: PortableTextHtmlComponents['unknownMark'] = ({\n  markType,\n  children,\n}) => {\n  return `<span class=\"unknown__pt__mark__${markType}\">${children}</span>`\n}\n\nexport const DefaultUnknownBlockStyle: PortableTextHtmlComponents['unknownBlockStyle'] = ({\n  children,\n}) => {\n  return `<p>${children}</p>`\n}\n\nexport const DefaultUnknownList: PortableTextHtmlComponents['unknownList'] = ({children}) => {\n  return `<ul>${children}</ul>`\n}\n\nexport const DefaultUnknownListItem: PortableTextHtmlComponents['unknownListItem'] = ({\n  children,\n}) => {\n  return `<li>${children}</li>`\n}\n","import type {PortableTextBlockStyle} from '@portabletext/types'\n\nimport type {PortableTextBlockComponent, PortableTextHtmlComponents} from '../types'\n\nimport {escapeHTML} from '../escape'\nimport {DefaultListItem, defaultLists} from './list'\nimport {defaultMarks} from './marks'\nimport {\n  DefaultUnknownBlockStyle,\n  DefaultUnknownList,\n  DefaultUnknownListItem,\n  DefaultUnknownMark,\n  DefaultUnknownType,\n} from './unknown'\n\nexport const DefaultHardBreak = (): string => '<br/>'\n\nexport const defaultPortableTextBlockStyles: Record<\n  PortableTextBlockStyle,\n  PortableTextBlockComponent | undefined\n> = {\n  normal: ({children}) => `<p>${children}</p>`,\n  blockquote: ({children}) => `<blockquote>${children}</blockquote>`,\n  h1: ({children}) => `<h1>${children}</h1>`,\n  h2: ({children}) => `<h2>${children}</h2>`,\n  h3: ({children}) => `<h3>${children}</h3>`,\n  h4: ({children}) => `<h4>${children}</h4>`,\n  h5: ({children}) => `<h5>${children}</h5>`,\n  h6: ({children}) => `<h6>${children}</h6>`,\n}\n\nexport const defaultComponents: PortableTextHtmlComponents = {\n  types: {},\n\n  block: defaultPortableTextBlockStyles,\n  marks: defaultMarks,\n  list: defaultLists,\n  listItem: DefaultListItem,\n  hardBreak: DefaultHardBreak,\n  escapeHTML: escapeHTML,\n\n  unknownType: DefaultUnknownType,\n  unknownMark: DefaultUnknownMark,\n  unknownList: DefaultUnknownList,\n  unknownListItem: DefaultUnknownListItem,\n  unknownBlockStyle: DefaultUnknownBlockStyle,\n}\n","import type {PortableTextComponents, PortableTextHtmlComponents} from '../types'\n\nexport function mergeComponents(\n  parent: PortableTextHtmlComponents,\n  overrides: PortableTextComponents,\n): PortableTextHtmlComponents {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const {block, list, listItem, marks, types, ...rest} = overrides\n  // @todo figure out how to not `as ...` these\n  return {\n    ...parent,\n    block: mergeDeeply(parent, overrides, 'block') as PortableTextHtmlComponents['block'],\n    list: mergeDeeply(parent, overrides, 'list') as PortableTextHtmlComponents['list'],\n    listItem: mergeDeeply(parent, overrides, 'listItem') as PortableTextHtmlComponents['listItem'],\n    marks: mergeDeeply(parent, overrides, 'marks') as PortableTextHtmlComponents['marks'],\n    types: mergeDeeply(parent, overrides, 'types') as PortableTextHtmlComponents['types'],\n    ...rest,\n  }\n}\n\nfunction mergeDeeply(\n  parent: PortableTextHtmlComponents,\n  overrides: PortableTextComponents,\n  key: 'block' | 'list' | 'listItem' | 'marks' | 'types',\n): PortableTextHtmlComponents[typeof key] {\n  const override = overrides[key]\n  const parentVal = parent[key]\n\n  if (typeof override === 'function') {\n    return override\n  }\n\n  if (override) {\n    return typeof parentVal === 'function'\n      ? override\n      : ({...parentVal, ...override} as PortableTextHtmlComponents[typeof key])\n  }\n\n  return parentVal\n}\n","import type {\n  ArbitraryTypedObject,\n  PortableTextBlock,\n  PortableTextListItemBlock,\n  TypedObject,\n} from '@portabletext/types'\n\nimport {\n  buildMarksTree,\n  isPortableTextBlock,\n  isPortableTextListItemBlock,\n  isPortableTextToolkitList,\n  isPortableTextToolkitSpan,\n  isPortableTextToolkitTextNode,\n  nestLists,\n  spanToPlainText,\n  type ToolkitNestedPortableTextSpan,\n  type ToolkitTextNode,\n} from '@portabletext/toolkit'\n\nimport type {\n  HtmlPortableTextList,\n  MissingComponentHandler,\n  NodeRenderer,\n  PortableTextHtmlComponents,\n  PortableTextOptions,\n  Serializable,\n  SerializedBlock,\n} from './types'\n\nimport {defaultComponents} from './components/defaults'\nimport {mergeComponents} from './components/merge'\nimport {\n  printWarning,\n  unknownBlockStyleWarning,\n  unknownListItemStyleWarning,\n  unknownListStyleWarning,\n  unknownMarkWarning,\n  unknownTypeWarning,\n} from './warnings'\n\nexport function toHTML<B extends TypedObject = PortableTextBlock | ArbitraryTypedObject>(\n  value: B | B[],\n  options: PortableTextOptions = {},\n): string {\n  const {\n    components: componentOverrides,\n    onMissingComponent: missingComponentHandler = printWarning,\n  } = options\n\n  const handleMissingComponent = missingComponentHandler || noop\n  const blocks = Array.isArray(value) ? value : [value]\n  const nested = nestLists(blocks, 'html')\n  const components = componentOverrides\n    ? mergeComponents(defaultComponents, componentOverrides)\n    : defaultComponents\n\n  const renderNode = getNodeRenderer(components, handleMissingComponent)\n  const rendered = nested.map((node, index) =>\n    renderNode({node: node, index, isInline: false, renderNode}),\n  )\n\n  return rendered.join('')\n}\n\nconst getNodeRenderer = (\n  components: PortableTextHtmlComponents,\n  handleMissingComponent: MissingComponentHandler,\n): NodeRenderer => {\n  function renderNode<N extends TypedObject>(options: Serializable<N>): string {\n    const {node, index, isInline} = options\n\n    if (isPortableTextToolkitList(node)) {\n      return renderList(node, index)\n    }\n\n    if (isPortableTextListItemBlock(node)) {\n      return renderListItem(node, index)\n    }\n\n    if (isPortableTextToolkitSpan(node)) {\n      return renderSpan(node)\n    }\n\n    if (isPortableTextBlock(node)) {\n      return renderBlock(node, index, isInline)\n    }\n\n    if (isPortableTextToolkitTextNode(node)) {\n      return renderText(node)\n    }\n\n    return renderCustomBlock(node, index, isInline)\n  }\n\n  function renderListItem(node: PortableTextListItemBlock, index: number): string {\n    const tree = serializeBlock({node, index, isInline: false, renderNode})\n    const renderer = components.listItem\n    const handler = typeof renderer === 'function' ? renderer : renderer[node.listItem]\n    const itemHandler = handler || components.unknownListItem\n\n    if (itemHandler === components.unknownListItem) {\n      const style = node.listItem || 'bullet'\n      handleMissingComponent(unknownListItemStyleWarning(style), {\n        type: style,\n        nodeType: 'listItemStyle',\n      })\n    }\n\n    let children = tree.children\n    if (node.style && node.style !== 'normal') {\n      // Wrap any other style in whatever the block component says to use\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const {listItem, ...blockNode} = node\n      children = renderNode({node: blockNode, index, isInline: false, renderNode})\n    }\n\n    return itemHandler({value: node, index, isInline: false, renderNode, children})\n  }\n\n  function renderList(node: HtmlPortableTextList, index: number): string {\n    const children = node.children.map((child, childIndex) =>\n      renderNode({\n        node: child._key ? child : {...child, _key: `li-${index}-${childIndex}`},\n        index: childIndex,\n        isInline: false,\n        renderNode,\n      }),\n    )\n\n    const component = components.list\n    const handler = typeof component === 'function' ? component : component[node.listItem]\n    const list = handler || components.unknownList\n\n    if (list === components.unknownList) {\n      const style = node.listItem || 'bullet'\n      handleMissingComponent(unknownListStyleWarning(style), {nodeType: 'listStyle', type: style})\n    }\n\n    return list({value: node, index, isInline: false, renderNode, children: children.join('')})\n  }\n\n  function renderSpan(node: ToolkitNestedPortableTextSpan): string {\n    const {markDef, markType, markKey} = node\n    const span = components.marks[markType] || components.unknownMark\n    const children = node.children.map((child, childIndex) =>\n      renderNode({node: child, index: childIndex, isInline: true, renderNode}),\n    )\n\n    if (span === components.unknownMark) {\n      handleMissingComponent(unknownMarkWarning(markType), {nodeType: 'mark', type: markType})\n    }\n\n    return span({\n      text: spanToPlainText(node),\n      value: markDef,\n      markType,\n      markKey,\n      renderNode,\n      children: children.join(''),\n    })\n  }\n\n  function renderBlock(node: PortableTextBlock, index: number, isInline: boolean): string {\n    const {_key, ...props} = serializeBlock({node, index, isInline, renderNode})\n    const style = props.node.style || 'normal'\n    const handler =\n      typeof components.block === 'function' ? components.block : components.block[style]\n    const block = handler || components.unknownBlockStyle\n\n    if (block === components.unknownBlockStyle) {\n      handleMissingComponent(unknownBlockStyleWarning(style), {\n        nodeType: 'blockStyle',\n        type: style,\n      })\n    }\n\n    return block({...props, value: props.node, renderNode})\n  }\n\n  function renderText(node: ToolkitTextNode): string {\n    if (node.text === '\\n') {\n      const hardBreak = components.hardBreak\n      return hardBreak ? hardBreak() : '\\n'\n    }\n\n    return components.escapeHTML(node.text)\n  }\n\n  function renderCustomBlock(value: TypedObject, index: number, isInline: boolean): string {\n    const node = components.types[value._type]\n\n    if (!node) {\n      handleMissingComponent(unknownTypeWarning(value._type), {\n        nodeType: 'block',\n        type: value._type,\n      })\n    }\n\n    const component = node || components.unknownType\n    return component({\n      value,\n      isInline,\n      index,\n      renderNode,\n    })\n  }\n\n  return renderNode\n}\n\nfunction serializeBlock(options: Serializable<PortableTextBlock>): SerializedBlock {\n  const {node, index, isInline, renderNode} = options\n  const tree = buildMarksTree(node)\n  const children = tree.map((child, i) =>\n    renderNode({node: child, isInline: true, index: i, renderNode}),\n  )\n\n  return {\n    _key: node._key || `block-${index}`,\n    children: children.join(''),\n    index,\n    isInline,\n    node,\n  }\n}\n\nfunction noop() {\n  // Intentional noop\n}\n"],"names":["charMap: Record<string, string>","defaultLists: Record<'number' | 'bullet', PortableTextListComponent>","DefaultListItem: PortableTextListItemComponent","link: PortableTextMarkComponent<DefaultLink>","defaultMarks: Record<string, PortableTextMarkComponent | undefined>","DefaultUnknownType: PortableTextHtmlComponents['unknownType']","DefaultUnknownMark: PortableTextHtmlComponents['unknownMark']","DefaultUnknownBlockStyle: PortableTextHtmlComponents['unknownBlockStyle']","DefaultUnknownList: PortableTextHtmlComponents['unknownList']","DefaultUnknownListItem: PortableTextHtmlComponents['unknownListItem']","defaultPortableTextBlockStyles: Record<\n  PortableTextBlockStyle,\n  PortableTextBlockComponent | undefined\n>","defaultComponents: PortableTextHtmlComponents"],"mappings":"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"}},
    {"offset": {"line": 2691, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@portabletext/markdown/dist/index.js","sources":["file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/markdown/src/key-generator.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/markdown/src/from-portable-text/build-list-index-map.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/markdown/src/from-portable-text/render-node.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/markdown/src/from-portable-text/renderers/block-spacing.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/markdown/src/from-portable-text/renderers/hard-break.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/markdown/src/from-portable-text/renderers/list-item.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/markdown/src/escape.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/markdown/src/from-portable-text/renderers/marks.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/markdown/src/from-portable-text/renderers/style.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/markdown/src/from-portable-text/renderers/type.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/markdown/src/from-portable-text/portable-text-to-markdown.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/markdown/src/default-schema.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/markdown/src/to-portable-text/matchers.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/markdown/src/to-portable-text/markdown-to-portable-text.ts"],"sourcesContent":["export function defaultKeyGenerator() {\n  return randomKey(12)\n}\n\nconst getByteHexTable = (() => {\n  let table: any[]\n  return () => {\n    if (table) {\n      return table\n    }\n\n    table = []\n    for (let i = 0; i < 256; ++i) {\n      table[i] = (i + 0x100).toString(16).slice(1)\n    }\n    return table\n  }\n})()\n\n// WHATWG crypto RNG - https://w3c.github.io/webcrypto/Overview.html\nfunction whatwgRNG(length = 16) {\n  const rnds8 = new Uint8Array(length)\n  crypto.getRandomValues(rnds8)\n  return rnds8\n}\n\nfunction randomKey(length?: number): string {\n  const table = getByteHexTable()\n  return whatwgRNG(length)\n    .reduce((str, n) => str + table[n], '')\n    .slice(0, length)\n}\n","import {\n  compileSchema,\n  defineSchema,\n  isTextBlock,\n  type PortableTextBlock,\n} from '@portabletext/schema'\nimport type {ArbitraryTypedObject, TypedObject} from '@portabletext/types'\nimport {defaultKeyGenerator} from '../key-generator'\n\nconst schema = compileSchema(defineSchema({}))\n\n/**\n * Builds a map of list item `_key`s to their index.\n *\n * Mutates the blocks in place by adding a `_key` if necessary.\n */\nexport function buildListIndexMap<\n  Block extends TypedObject = PortableTextBlock | ArbitraryTypedObject,\n>(blocks: Array<Block>): Map<string, number> {\n  const levelIndexMaps = new Map<string, Map<number, number>>()\n  const listIndexMap = new Map<string, number>()\n\n  let previousListItem:\n    | {\n        listItem: string\n        level: number\n      }\n    | undefined\n\n  for (let blockIndex = 0; blockIndex < blocks.length; blockIndex++) {\n    const block = blocks.at(blockIndex)\n\n    if (block === undefined) {\n      continue\n    }\n\n    if (!block._key) {\n      block._key = defaultKeyGenerator()\n    }\n\n    // Clear the state if we encounter a non-text block\n    if (!isTextBlock({schema}, block)) {\n      levelIndexMaps.clear()\n      previousListItem = undefined\n\n      continue\n    }\n\n    // Clear the state if we encounter a non-list text block\n    if (block.listItem === undefined || block.level === undefined) {\n      levelIndexMaps.clear()\n      previousListItem = undefined\n\n      continue\n    }\n\n    // If we encounter a new list item, we set the initial index to 1 for the\n    // list type on that level.\n    if (!previousListItem) {\n      const listIndex = 1\n      const levelIndexMap =\n        levelIndexMaps.get(block.listItem) ?? new Map<number, number>()\n      levelIndexMap.set(block.level, listIndex)\n      levelIndexMaps.set(block.listItem, levelIndexMap)\n\n      listIndexMap.set(block._key, listIndex)\n\n      previousListItem = {\n        listItem: block.listItem,\n        level: block.level,\n      }\n\n      continue\n    }\n\n    // If the previous list item is of the same type but on a lower level, we\n    // need to reset the level index map for that type.\n    if (\n      previousListItem.listItem === block.listItem &&\n      previousListItem.level < block.level\n    ) {\n      const listIndex = 1\n      const levelIndexMap =\n        levelIndexMaps.get(block.listItem) ?? new Map<number, number>()\n      levelIndexMap.set(block.level, listIndex)\n      levelIndexMaps.set(block.listItem, levelIndexMap)\n\n      listIndexMap.set(block._key, listIndex)\n\n      previousListItem = {\n        listItem: block.listItem,\n        level: block.level,\n      }\n\n      continue\n    }\n\n    // Reset other list types at current level and deeper\n    levelIndexMaps.forEach((levelIndexMap, listItem) => {\n      if (listItem === block.listItem) {\n        return\n      }\n\n      // Reset all levels that are >= current level\n      const levelsToDelete: number[] = []\n\n      levelIndexMap.forEach((_, level) => {\n        if (level >= block.level!) {\n          levelsToDelete.push(level)\n        }\n      })\n\n      levelsToDelete.forEach((level) => {\n        levelIndexMap.delete(level)\n      })\n    })\n\n    const levelIndexMap =\n      levelIndexMaps.get(block.listItem) ?? new Map<number, number>()\n    const levelCounter = levelIndexMap.get(block.level) ?? 0\n    levelIndexMap.set(block.level, levelCounter + 1)\n    levelIndexMaps.set(block.listItem, levelIndexMap)\n\n    listIndexMap.set(block._key, levelCounter + 1)\n\n    previousListItem = {\n      listItem: block.listItem,\n      level: block.level,\n    }\n  }\n\n  return listIndexMap\n}\n","import {\n  buildMarksTree,\n  isPortableTextBlock,\n  isPortableTextListItemBlock,\n  isPortableTextToolkitSpan,\n  isPortableTextToolkitTextNode,\n  spanToPlainText,\n  type ToolkitNestedPortableTextSpan,\n  type ToolkitTextNode,\n} from '@portabletext/toolkit'\nimport type {\n  PortableTextBlock,\n  PortableTextListItemBlock,\n  PortableTextMarkDefinition,\n  PortableTextSpan,\n  TypedObject,\n} from '@portabletext/types'\nimport {defaultKeyGenerator} from '../key-generator'\nimport type {PortableTextRenderers, RenderNode, Serializable} from './types'\n\ninterface SerializedBlock {\n  _key: string\n  children: string\n  index: number\n  isInline: boolean\n  node: PortableTextBlock | PortableTextListItemBlock\n}\n\nexport const createRenderNode = (\n  renderers: PortableTextRenderers,\n  listIndexMap: Map<string, number>,\n): RenderNode => {\n  function renderNode<N extends TypedObject>(options: Serializable<N>): string {\n    const {node, index, isInline} = options\n\n    if (isPortableTextListItemBlock(node)) {\n      return renderListItem(node, index)\n    }\n\n    if (isPortableTextToolkitSpan(node)) {\n      return renderSpan(node)\n    }\n\n    if (isPortableTextBlock(node)) {\n      return renderBlock(node, index, isInline)\n    }\n\n    if (isPortableTextToolkitTextNode(node)) {\n      return renderText(node)\n    }\n\n    return renderCustomBlock(node, index, isInline)\n  }\n\n  function renderListItem(\n    node: PortableTextListItemBlock<\n      PortableTextMarkDefinition,\n      PortableTextSpan\n    >,\n    index: number,\n  ): string {\n    const renderer = renderers.listItem\n    const handler =\n      typeof renderer === 'function' ? renderer : renderer[node.listItem]\n    const itemHandler = handler || renderers.unknownListItem\n\n    // Build the text content from the block\n    const tree = buildMarksTree(node)\n    const textContent = tree\n      .map((child, i) => {\n        return renderNode({node: child, isInline: true, index: i, renderNode})\n      })\n      .join('')\n\n    let children = textContent\n\n    if (node.style && node.style !== 'normal') {\n      // Wrap any other style in whatever the block component says to use\n      const {listItem: _listItem, ...blockNode} = node\n      children = renderNode({\n        node: blockNode,\n        index,\n        isInline: false,\n        renderNode,\n      })\n      // Strip trailing newlines from block styles - list item component handles spacing\n      children = children.replace(/\\n+$/, '')\n    }\n\n    return itemHandler({\n      value: node,\n      index,\n      listIndex: node._key ? listIndexMap.get(node._key) : undefined,\n      isInline: false,\n      renderNode,\n      children,\n    })\n  }\n\n  function renderSpan(node: ToolkitNestedPortableTextSpan): string {\n    const {markDef, markType, markKey} = node\n    const span = renderers.marks[markType] || renderers.unknownMark\n    const children = node.children.map((child, childIndex) =>\n      renderNode({node: child, index: childIndex, isInline: true, renderNode}),\n    )\n\n    return span({\n      text: spanToPlainText(node),\n      value: markDef,\n      markType,\n      markKey,\n      renderNode,\n      children: children.join(''),\n    })\n  }\n\n  function renderBlock(\n    node: PortableTextBlock,\n    index: number,\n    isInline: boolean,\n  ): string {\n    const {_key, ...props} = serializeBlock({node, index, isInline, renderNode})\n    const style = props.node.style || 'normal'\n    const handler =\n      typeof renderers.block === 'function'\n        ? renderers.block\n        : renderers.block[style]\n    const block = handler || renderers.unknownBlockStyle\n\n    return block({...props, value: props.node, renderNode})\n  }\n\n  function renderText(node: ToolkitTextNode): string {\n    if (node.text === '\\n') {\n      return renderers.hardBreak()\n    }\n\n    return node.text\n  }\n\n  function renderCustomBlock(\n    value: TypedObject,\n    index: number,\n    isInline: boolean,\n  ): string {\n    const component = renderers.types[value._type] ?? renderers.unknownType\n\n    return component({\n      value,\n      isInline,\n      index,\n      renderNode,\n    })\n  }\n\n  return renderNode\n}\n\nfunction serializeBlock(\n  options: Serializable<PortableTextBlock>,\n): SerializedBlock {\n  const {node, index, isInline, renderNode} = options\n  const tree = buildMarksTree(node)\n\n  const renderedChildren = tree.map((child, i) =>\n    renderNode({node: child, isInline: true, index: i, renderNode}),\n  )\n\n  return {\n    _key: node._key || defaultKeyGenerator(),\n    children: renderedChildren.join(''),\n    index,\n    isInline,\n    node,\n  }\n}\n","import {\n  isPortableTextBlock,\n  isPortableTextListItemBlock,\n} from '@portabletext/toolkit'\nimport type {TypedObject} from '@portabletext/types'\n\n/**\n * @public\n */\nexport type BlockSpacingRenderer = (options: {\n  current: TypedObject\n  next: TypedObject\n}) => string | undefined\n\n/**\n * @public\n */\nexport const DefaultBlockSpacingRenderer: BlockSpacingRenderer = ({\n  current,\n  next,\n}) => {\n  if (\n    isPortableTextListItemBlock(current) &&\n    isPortableTextListItemBlock(next)\n  ) {\n    return '\\n'\n  }\n\n  if (\n    isPortableTextBlock(current) &&\n    isPortableTextBlock(next) &&\n    current.style === 'blockquote' &&\n    next.style === 'blockquote'\n  ) {\n    return '\\n>\\n'\n  }\n\n  return '\\n\\n'\n}\n","/**\n * @public\n */\nexport const DefaultHardBreakRenderer = (): string => '  \\n'\n","import type {PortableTextListItemRenderer} from '../types'\n\n/**\n * @public\n */\nexport const DefaultListItemRenderer: PortableTextListItemRenderer = ({\n  children,\n  value,\n  listIndex,\n}) => {\n  const listStyle = value.listItem || 'bullet'\n  const level = value.level || 1\n\n  if (listStyle === 'number') {\n    const indent = '   '.repeat(level - 1)\n\n    return `${indent}${listIndex ?? 1}. ${children}`\n  }\n\n  const indent = '   '.repeat(level - 1)\n\n  return `${indent}- ${children}`\n}\n\n/**\n * @public\n */\nexport const DefaultUnknownListItemRenderer: PortableTextListItemRenderer = ({\n  children,\n}) => {\n  return `- ${children}\\n`\n}\n","/**\n * Escapes special characters in image alt texts and link texts.\n */\nexport function escapeImageAndLinkText(text: string): string {\n  return text.replace(/([[\\]\\\\])/g, '\\\\$1')\n}\n\n/**\n * Unescapes special characters in image alt texts and link texts.\n */\nexport function unescapeImageAndLinkText(text: string): string {\n  return text.replace(/\\\\([!\"#$%&'()*+,\\-./:;<=>?@[\\\\\\]^_`{|}~])/g, '$1')\n}\n\n/**\n * Escapes special characters in image/link titles (the part inside quotes).\n */\nexport function escapeImageAndLinkTitle(text: string): string {\n  return text.replace(/([\\\\\"])/g, '\\\\$1')\n}\n","import type {TypedObject} from '@portabletext/types'\nimport {escapeImageAndLinkText, escapeImageAndLinkTitle} from '../../escape'\nimport type {PortableTextMarkRenderer} from '../types'\n\n/**\n * @public\n */\nexport const DefaultEmRenderer: PortableTextMarkRenderer = ({children}) =>\n  `_${children}_`\n\n/**\n * @public\n */\nexport const DefaultStrongRenderer: PortableTextMarkRenderer = ({children}) =>\n  `**${children}**`\n\n/**\n * @public\n */\nexport const DefaultCodeRenderer: PortableTextMarkRenderer = ({children}) =>\n  `\\`${children}\\``\n\n/**\n * @public\n */\nexport const DefaultUnderlineRenderer: PortableTextMarkRenderer = ({\n  children,\n}) => `<u>${children}</u>`\n\n/**\n * @public\n */\nexport const DefaultStrikeThroughRenderer: PortableTextMarkRenderer = ({\n  children,\n}) => `~~${children}~~`\n\ninterface DefaultLink extends TypedObject {\n  _type: 'link'\n  href: string\n  title: string | undefined\n}\n\n/**\n * @public\n */\nexport const DefaultLinkRenderer: PortableTextMarkRenderer<DefaultLink> = ({\n  children,\n  value,\n}) => {\n  const href = value?.href || ''\n  const title = value?.title || ''\n  const looksSafe = uriLooksSafe(href)\n\n  if (looksSafe) {\n    // Check if the URL looks like an HTML injection attempt\n    // If it has quotes AND angle brackets, or other suspicious patterns, encode more aggressively\n    const looksLikeInjection = /[\"'][^\"']*[<>]|[<>][^<>]*[\"']/.test(href)\n\n    if (looksLikeInjection) {\n      // Encode all special characters that could be used for injection\n      const encodedHref = href.replace(/[\"<>() ]/g, (char) => {\n        return `%${char.charCodeAt(0).toString(16).toUpperCase()}`\n      })\n      return `[${escapeImageAndLinkText(children)}](${encodedHref})`\n    }\n\n    // For normal URLs, don't encode parentheses - Markdown handles balanced parens fine\n    return `[${escapeImageAndLinkText(children)}](${href}${title ? ` \"${escapeImageAndLinkTitle(title)}\"` : ''})`\n  }\n\n  // Return children without link when URL is unsafe\n  return children\n}\n\nfunction uriLooksSafe(uri: string): boolean {\n  const url = (uri || '').trim()\n  const first = url.charAt(0)\n\n  if (first === '#' || first === '/') {\n    return true\n  }\n\n  const colonIndex = url.indexOf(':')\n  if (colonIndex === -1) {\n    return true\n  }\n\n  const allowedProtocols = ['http', 'https', 'mailto', 'tel']\n  const proto = url.slice(0, colonIndex).toLowerCase()\n  if (allowedProtocols.indexOf(proto) !== -1) {\n    return true\n  }\n\n  const queryIndex = url.indexOf('?')\n  if (queryIndex !== -1 && colonIndex > queryIndex) {\n    return true\n  }\n\n  const hashIndex = url.indexOf('#')\n  if (hashIndex !== -1 && colonIndex > hashIndex) {\n    return true\n  }\n\n  return false\n}\n\n/**\n * @public\n */\nexport const DefaultUnknownMarkRenderer: PortableTextMarkRenderer = ({\n  children,\n}) => {\n  return children\n}\n","import type {PortableTextBlock} from '@portabletext/types'\nimport type {PortableTextRenderer} from '../types'\n\ntype PortableTextBlockRenderer = PortableTextRenderer<PortableTextBlock>\n\n/**\n * @public\n */\nexport const DefaultNormalRenderer: PortableTextBlockRenderer = ({\n  children,\n}) => {\n  // Empty blocks should not add extra spacing\n  if (!children || children.trim() === '') {\n    return ''\n  }\n\n  return children\n}\n\n/**\n * @public\n */\nexport const DefaultBlockquoteRenderer: PortableTextBlockRenderer = ({\n  children,\n}) => {\n  // Prefix each line with \"> \" for proper blockquote formatting\n  // This handles multi-line content and preserves empty lines\n  if (!children) {\n    return '>'\n  }\n\n  return children\n    .split('\\n')\n    .map((line) => `> ${line}`)\n    .join('\\n')\n}\n\n/**\n * @public\n */\nexport const DefaultH1Renderer: PortableTextBlockRenderer = ({children}) =>\n  `# ${children}`\n\n/**\n * @public\n */\nexport const DefaultH2Renderer: PortableTextBlockRenderer = ({children}) =>\n  `## ${children}`\n\n/**\n * @public\n */\nexport const DefaultH3Renderer: PortableTextBlockRenderer = ({children}) =>\n  `### ${children}`\n\n/**\n * @public\n */\nexport const DefaultH4Renderer: PortableTextBlockRenderer = ({children}) =>\n  `#### ${children}`\n\n/**\n * @public\n */\nexport const DefaultH5Renderer: PortableTextBlockRenderer = ({children}) =>\n  `##### ${children}`\n\n/**\n * @public\n */\nexport const DefaultH6Renderer: PortableTextBlockRenderer = ({children}) =>\n  `###### ${children}`\n\n/**\n * @public\n */\nexport const DefaultUnknownStyleRenderer: PortableTextBlockRenderer = ({\n  children,\n}) => {\n  return children ?? ''\n}\n","import type {PortableTextBlock} from '@portabletext/types'\nimport {escapeImageAndLinkText, escapeImageAndLinkTitle} from '../../escape'\nimport type {PortableTextTypeRenderer} from '../types'\n\n/**\n * @public\n */\nexport const DefaultCodeBlockRenderer: PortableTextTypeRenderer<{\n  _type: 'code'\n  code: string\n  language: string | undefined\n}> = ({value}) => {\n  return `\\`\\`\\`${value.language ?? ''}\\n${value.code}\\n\\`\\`\\``\n}\n\n/**\n * @public\n */\nexport const DefaultHorizontalRuleRenderer: PortableTextTypeRenderer = () => {\n  return '---'\n}\n\n/**\n * @public\n */\nexport const DefaultHtmlRenderer: PortableTextTypeRenderer<{\n  _type: 'html'\n  html: string\n}> = ({value}) => {\n  return value.html\n}\n\n/**\n * @public\n */\nexport const DefaultImageRenderer: PortableTextTypeRenderer<{\n  _type: 'image'\n  src: string\n  alt: string | undefined\n  title: string | undefined\n}> = ({value}) => {\n  const alt = escapeImageAndLinkText(value.alt ?? '')\n  const title = value.title ? ` \"${escapeImageAndLinkTitle(value.title)}\"` : ''\n  return `![${alt}](${value.src}${title})`\n}\n\n/**\n * @public\n */\nexport const DefaultTableRenderer: PortableTextTypeRenderer<{\n  _type: 'table'\n  headerRows: number | undefined\n  rows: Array<{\n    _key: string\n    cells: Array<{\n      _key: string\n      value: Array<PortableTextBlock>\n    }>\n  }>\n}> = ({value, renderNode}) => {\n  const headerRows = value.headerRows || 0\n  const rows = value.rows as Array<{\n    _key: string\n    _type: 'row'\n    cells: Array<{\n      _type: 'cell'\n      _key: string\n      value: Array<{_type: string; children?: Array<unknown>}>\n    }>\n  }>\n  const lines: string[] = []\n\n  // Helper to extract text from cell blocks\n  const getCellText = (\n    cellBlocks: Array<{_type: string; children?: Array<unknown>}>,\n  ): string => {\n    return cellBlocks\n      .map((block, index) =>\n        renderNode({\n          node: block as {_type: string},\n          index,\n          isInline: false,\n          renderNode,\n        }),\n      )\n      .join(' ')\n      .trim()\n  }\n\n  // Add header rows\n  for (let i = 0; i < headerRows; i++) {\n    const row = rows[i]\n    if (row) {\n      const cellTexts = row.cells.map((cell) => getCellText(cell.value))\n      lines.push(`| ${cellTexts.join(' | ')} |`)\n    }\n  }\n\n  // Add separator line if there are headers\n  if (headerRows > 0 && rows[0]) {\n    const separators = rows[0].cells.map(() => ' --- ')\n    lines.push(`|${separators.join('|')}|`)\n  }\n\n  // Add body rows\n  for (let i = headerRows; i < rows.length; i++) {\n    const row = rows[i]\n    if (row) {\n      const cellTexts = row.cells.map((cell) => getCellText(cell.value))\n      lines.push(`| ${cellTexts.join(' | ')} |`)\n    }\n  }\n\n  return lines.join('\\n')\n}\n\n/**\n * @public\n */\nexport const DefaultUnknownTypeRenderer: PortableTextTypeRenderer = ({\n  value,\n  isInline,\n}) => {\n  const json = `\\`\\`\\`json\\n${JSON.stringify(value, null, 2)}\\n\\`\\`\\``\n  // For inline unknown types, add newlines to break them out of the text flow\n  return isInline ? `\\n${json}\\n` : json\n}\n","import type {\n  ArbitraryTypedObject,\n  PortableTextBlock,\n  TypedObject,\n} from '@portabletext/types'\nimport {buildListIndexMap} from './build-list-index-map'\nimport {createRenderNode} from './render-node'\nimport {\n  DefaultBlockSpacingRenderer,\n  type BlockSpacingRenderer,\n} from './renderers/block-spacing'\nimport {DefaultHardBreakRenderer} from './renderers/hard-break'\nimport {\n  DefaultListItemRenderer,\n  DefaultUnknownListItemRenderer,\n} from './renderers/list-item'\nimport {\n  DefaultCodeRenderer,\n  DefaultEmRenderer,\n  DefaultLinkRenderer,\n  DefaultStrikeThroughRenderer,\n  DefaultStrongRenderer,\n  DefaultUnderlineRenderer,\n  DefaultUnknownMarkRenderer,\n} from './renderers/marks'\nimport {\n  DefaultBlockquoteRenderer,\n  DefaultH1Renderer,\n  DefaultH2Renderer,\n  DefaultH3Renderer,\n  DefaultH4Renderer,\n  DefaultH5Renderer,\n  DefaultH6Renderer,\n  DefaultNormalRenderer,\n  DefaultUnknownStyleRenderer,\n} from './renderers/style'\nimport {DefaultUnknownTypeRenderer} from './renderers/type'\nimport type {PortableTextRenderers} from './types'\n\nconst defaultRenderers: PortableTextRenderers = {\n  types: {},\n\n  block: {\n    normal: DefaultNormalRenderer,\n    blockquote: DefaultBlockquoteRenderer,\n    h1: DefaultH1Renderer,\n    h2: DefaultH2Renderer,\n    h3: DefaultH3Renderer,\n    h4: DefaultH4Renderer,\n    h5: DefaultH5Renderer,\n    h6: DefaultH6Renderer,\n  },\n  marks: {\n    'em': DefaultEmRenderer,\n    'strong': DefaultStrongRenderer,\n    'code': DefaultCodeRenderer,\n    'underline': DefaultUnderlineRenderer,\n    'strike-through': DefaultStrikeThroughRenderer,\n    'link': DefaultLinkRenderer,\n  },\n  listItem: DefaultListItemRenderer,\n  hardBreak: DefaultHardBreakRenderer,\n\n  unknownType: DefaultUnknownTypeRenderer,\n  unknownMark: DefaultUnknownMarkRenderer,\n  unknownListItem: DefaultUnknownListItemRenderer,\n  unknownBlockStyle: DefaultUnknownStyleRenderer,\n}\n\ntype Options = Partial<PortableTextRenderers> & {\n  blockSpacing?: BlockSpacingRenderer\n}\n\n/**\n * @public\n */\nexport function portableTextToMarkdown<\n  Block extends TypedObject = PortableTextBlock | ArbitraryTypedObject,\n>(blocks: Array<Block>, options: Options = {}): string {\n  const renderers = {\n    block: {\n      ...defaultRenderers.block,\n      ...options.block,\n    },\n    listItem: options.listItem ?? defaultRenderers.listItem,\n    marks: {\n      ...defaultRenderers.marks,\n      ...options.marks,\n    },\n    types: {\n      ...defaultRenderers.types,\n      ...options.types,\n    },\n    hardBreak: options.hardBreak ?? defaultRenderers.hardBreak,\n    unknownType: options.unknownType ?? defaultRenderers.unknownType,\n    unknownBlockStyle:\n      options.unknownBlockStyle ?? defaultRenderers.unknownBlockStyle,\n    unknownListItem:\n      options.unknownListItem ?? defaultRenderers.unknownListItem,\n    unknownMark: options.unknownMark ?? defaultRenderers.unknownMark,\n  }\n  const renderBlockSpacing = options.blockSpacing ?? DefaultBlockSpacingRenderer\n\n  const listIndexMap = buildListIndexMap(blocks)\n  const renderNode = createRenderNode(renderers, listIndexMap)\n\n  return blocks\n    .map((node, index) => {\n      const renderedNode = renderNode({\n        node,\n        index,\n        isInline: false,\n        renderNode,\n      })\n\n      if (index === blocks.length - 1) {\n        return renderedNode\n      }\n\n      const nextNode = blocks.at(index + 1)\n\n      if (!nextNode) {\n        return renderedNode\n      }\n\n      const blockSpacing =\n        renderBlockSpacing({\n          current: node,\n          next: nextNode,\n        }) ?? '\\n\\n'\n\n      return `${renderedNode}${blockSpacing}`\n    })\n    .join('')\n}\n","import {\n  compileSchema,\n  defineSchema,\n  type AnnotationDefinition,\n  type BlockObjectDefinition,\n  type DecoratorDefinition,\n  type ListDefinition,\n  type StyleDefinition,\n} from '@portabletext/schema'\n\n/********************\n * Default style definitions\n ********************/\n\nexport const normalStyleDefinition = {\n  name: 'normal',\n} as const satisfies StyleDefinition\n\nexport const h1StyleDefinition = {\n  name: 'h1',\n} as const satisfies StyleDefinition\n\nexport const h2StyleDefinition = {\n  name: 'h2',\n} as const satisfies StyleDefinition\n\nexport const h3StyleDefinition = {\n  name: 'h3',\n} as const satisfies StyleDefinition\n\nexport const h4StyleDefinition = {\n  name: 'h4',\n} as const satisfies StyleDefinition\n\nexport const h5StyleDefinition = {\n  name: 'h5',\n} as const satisfies StyleDefinition\n\nexport const h6StyleDefinition = {\n  name: 'h6',\n} as const satisfies StyleDefinition\n\nexport const blockquoteStyleDefinition = {\n  name: 'blockquote',\n} as const satisfies StyleDefinition\n\n/********************\n * Default list definitions\n ********************/\n\nexport const defaultOrderedListItemDefinition = {\n  name: 'number',\n} as const satisfies ListDefinition\n\nexport const defaultUnorderedListItemDefinition = {\n  name: 'bullet',\n} as const satisfies ListDefinition\n\n/********************\n * Default decorator definitions\n ********************/\n\nexport const defaultStrongDecoratorDefinition = {\n  name: 'strong',\n} as const satisfies DecoratorDefinition\n\nexport const defaultEmDecoratorDefinition = {\n  name: 'em',\n} as const satisfies DecoratorDefinition\n\nexport const defaultCodeDecoratorDefinition = {\n  name: 'code',\n} as const satisfies DecoratorDefinition\n\nexport const defaultStrikeThroughDecoratorDefinition = {\n  name: 'strike-through',\n} as const satisfies DecoratorDefinition\n\n/********************\n * Default annotation definitions\n ********************/\n\nexport const defaultLinkObjectDefinition = {\n  name: 'link',\n  fields: [\n    {name: 'href', type: 'string'},\n    {name: 'title', type: 'string'},\n  ],\n} as const satisfies AnnotationDefinition\n\n/********************\n * Default object definitions\n ********************/\n\nexport const defaultCodeObjectDefinition = {\n  name: 'code',\n  fields: [\n    {name: 'language', type: 'string'},\n    {name: 'code', type: 'string'},\n  ],\n} as const satisfies BlockObjectDefinition\n\nexport const defaultImageObjectDefinition = {\n  name: 'image',\n  fields: [\n    {name: 'src', type: 'string'},\n    {name: 'alt', type: 'string'},\n    {name: 'title', type: 'string'},\n  ],\n} as const satisfies BlockObjectDefinition\n\nexport const defaultHorizontalRuleObjectDefinition = {\n  name: 'horizontal-rule',\n} as const satisfies BlockObjectDefinition\n\nexport const defaultHtmlObjectDefinition = {\n  name: 'html',\n  fields: [{name: 'html', type: 'string'}],\n} as const satisfies BlockObjectDefinition\n\nexport const defaultTableObjectDefinition = {\n  name: 'table',\n  fields: [\n    {name: 'headerRows', type: 'number'},\n    {name: 'rows', type: 'array'},\n  ],\n} as const satisfies BlockObjectDefinition\n\n/**\n * The default schema for converting markdown to Portable Text.\n *\n * @public\n */\nexport const defaultSchema = compileSchema(\n  defineSchema({\n    styles: [\n      normalStyleDefinition,\n      h1StyleDefinition,\n      h2StyleDefinition,\n      h3StyleDefinition,\n      h4StyleDefinition,\n      h5StyleDefinition,\n      h6StyleDefinition,\n      blockquoteStyleDefinition,\n    ],\n    lists: [\n      defaultOrderedListItemDefinition,\n      defaultUnorderedListItemDefinition,\n    ],\n    decorators: [\n      defaultStrongDecoratorDefinition,\n      defaultEmDecoratorDefinition,\n      defaultCodeDecoratorDefinition,\n      defaultStrikeThroughDecoratorDefinition,\n    ],\n    annotations: [defaultLinkObjectDefinition],\n    blockObjects: [\n      defaultCodeObjectDefinition,\n      defaultHorizontalRuleObjectDefinition,\n      defaultImageObjectDefinition,\n      defaultHtmlObjectDefinition,\n      defaultTableObjectDefinition,\n    ],\n    inlineObjects: [defaultImageObjectDefinition],\n  }),\n)\n","import type {\n  PortableTextObject,\n  Schema,\n  SchemaDefinition,\n} from '@portabletext/schema'\n\n/**\n * Matcher function for mapping markdown elements to Portable Text block styles.\n *\n * @public\n */\nexport type StyleMatcher = ({\n  context,\n}: {\n  context: {schema: Schema}\n}) => string | undefined\n\nexport function buildStyleMatcher<TDefinition extends {name: string}>(\n  definition: TDefinition,\n): StyleMatcher {\n  return ({context}) => {\n    const schemaDefinition = context.schema.styles.find(\n      (item) => item.name === definition.name,\n    )\n\n    if (!schemaDefinition) {\n      return undefined\n    }\n\n    return schemaDefinition.name\n  }\n}\n\n/**\n * Matcher function for mapping markdown list items to Portable Text list types.\n *\n * @public\n */\nexport type ListItemMatcher = ({\n  context,\n}: {\n  context: {schema: Schema}\n}) => string | undefined\n\nexport function buildListItemMatcher<TDefinition extends {name: string}>(\n  definition: TDefinition,\n): ListItemMatcher {\n  return ({context}) => {\n    const schemaDefinition = context.schema.lists.find(\n      (item) => item.name === definition.name,\n    )\n\n    if (!schemaDefinition) {\n      return undefined\n    }\n\n    return schemaDefinition.name\n  }\n}\n\n/**\n * Matcher function for mapping markdown inline formatting to Portable Text decorators.\n *\n * @public\n */\nexport type DecoratorMatcher = ({\n  context,\n}: {\n  context: {schema: Schema}\n}) => string | undefined\n\nexport function buildDecoratorMatcher<TDefinition extends {name: string}>(\n  definition: TDefinition,\n): DecoratorMatcher {\n  return ({context}) => {\n    const schemaDefinition = context.schema.decorators.find(\n      (item) => item.name === definition.name,\n    )\n\n    if (!schemaDefinition) {\n      return undefined\n    }\n\n    return schemaDefinition.name\n  }\n}\n\n/**\n * Matcher function for mapping markdown links to Portable Text annotations.\n *\n * @public\n */\nexport type AnnotationMatcher<\n  TValue extends Record<string, unknown> = Record<string, never>,\n> = ({\n  context,\n  value,\n}: {\n  context: {schema: Schema; keyGenerator: () => string}\n  value: TValue\n}) => PortableTextObject | undefined\n\nexport function buildAnnotationMatcher<TDefinition extends {name: string}>(\n  definition: TDefinition,\n): AnnotationMatcher<ExtractValue<TDefinition>> {\n  return ({context, value}) => {\n    const schemaDefinition = context.schema.annotations.find(\n      (item) => item.name === definition.name,\n    )\n\n    if (!schemaDefinition) {\n      return undefined\n    }\n\n    const filteredValue = schemaDefinition.fields.reduce<\n      Record<string, unknown>\n    >((filteredValue, field) => {\n      const fieldValue = value[field.name as keyof typeof value]\n\n      if (fieldValue !== undefined) {\n        filteredValue[field.name] = fieldValue\n      }\n\n      return filteredValue\n    }, {})\n\n    return {\n      _key: context.keyGenerator(),\n      _type: schemaDefinition.name,\n      ...filteredValue,\n    }\n  }\n}\n\n/**\n * Matcher function for mapping markdown objects to Portable Text block or inline objects.\n *\n * @public\n */\nexport type ObjectMatcher<\n  TValue extends Record<string, unknown> = Record<string, never>,\n> = ({\n  context,\n  value,\n  isInline,\n}: {\n  context: {schema: Schema; keyGenerator: () => string}\n  value: TValue\n  isInline: boolean\n}) => PortableTextObject | undefined\n\nexport function buildObjectMatcher<TDefinition extends {name: string}>(\n  definition: TDefinition,\n): ObjectMatcher<ExtractValue<TDefinition>> {\n  return ({context, value, isInline}) => {\n    const schemaCollection = isInline\n      ? context.schema.inlineObjects\n      : context.schema.blockObjects\n\n    const schemaDefinition = schemaCollection.find(\n      (item) => item.name === definition.name,\n    )\n\n    if (!schemaDefinition) {\n      return undefined\n    }\n\n    const filteredValue = schemaDefinition.fields.reduce<\n      Record<string, unknown>\n    >((filteredValue, field) => {\n      const fieldValue = value[field.name as keyof typeof value]\n\n      if (fieldValue !== undefined) {\n        filteredValue[field.name] = fieldValue\n      }\n\n      return filteredValue\n    }, {})\n\n    return {\n      _key: context.keyGenerator(),\n      _type: schemaDefinition.name,\n      ...filteredValue,\n    }\n  }\n}\n\nexport type ExtractValue<\n  TDefinition extends NonNullable<SchemaDefinition['blockObjects']>[0],\n> = TDefinition extends {fields: ReadonlyArray<{name: infer TNames}>}\n  ? Record<TNames & string, unknown>\n  : Record<string, never>\n","import {\n  isSpan,\n  type PortableTextBlock,\n  type PortableTextObject,\n  type PortableTextTextBlock,\n  type Schema,\n} from '@portabletext/schema'\nimport markdownit from 'markdown-it'\nimport {\n  blockquoteStyleDefinition,\n  defaultCodeDecoratorDefinition,\n  defaultCodeObjectDefinition,\n  defaultEmDecoratorDefinition,\n  defaultHorizontalRuleObjectDefinition,\n  defaultHtmlObjectDefinition,\n  defaultImageObjectDefinition,\n  defaultLinkObjectDefinition,\n  defaultOrderedListItemDefinition,\n  defaultSchema,\n  defaultStrikeThroughDecoratorDefinition,\n  defaultStrongDecoratorDefinition,\n  defaultUnorderedListItemDefinition,\n  h1StyleDefinition,\n  h2StyleDefinition,\n  h3StyleDefinition,\n  h4StyleDefinition,\n  h5StyleDefinition,\n  h6StyleDefinition,\n  normalStyleDefinition,\n} from '../default-schema'\nimport {unescapeImageAndLinkText} from '../escape'\nimport {defaultKeyGenerator} from '../key-generator'\nimport {\n  buildAnnotationMatcher,\n  buildDecoratorMatcher,\n  buildListItemMatcher,\n  buildObjectMatcher,\n  buildStyleMatcher,\n  type AnnotationMatcher,\n  type DecoratorMatcher,\n  type ExtractValue,\n  type ListItemMatcher,\n  type ObjectMatcher,\n  type StyleMatcher,\n} from './matchers'\n\ntype Options = {\n  schema?: Schema\n  keyGenerator?: () => string\n  marks?: {\n    strong?: DecoratorMatcher\n    em?: DecoratorMatcher\n    code?: DecoratorMatcher\n    strikeThrough?: DecoratorMatcher\n    link?: AnnotationMatcher<{href: string; title: string | undefined}>\n  }\n  block?: {\n    normal?: StyleMatcher\n    blockquote?: StyleMatcher\n    h1?: StyleMatcher\n    h2?: StyleMatcher\n    h3?: StyleMatcher\n    h4?: StyleMatcher\n    h5?: StyleMatcher\n    h6?: StyleMatcher\n  }\n  listItem?: {\n    number?: ListItemMatcher\n    bullet?: ListItemMatcher\n  }\n  types?: {\n    code?: ObjectMatcher<{language: string | undefined; code: string}>\n    horizontalRule?: ObjectMatcher\n    html?: ObjectMatcher<{html: string}>\n    table?: ObjectMatcher<{\n      headerRows: number | undefined\n      rows: Array<{\n        _key: string\n        _type: 'row'\n        cells: Array<{\n          _type: 'cell'\n          _key: string\n          value: Array<PortableTextBlock>\n        }>\n      }>\n    }>\n    image?: ObjectMatcher<{src: string; alt: string; title: string | undefined}>\n  }\n  html?: {\n    /**\n     * How to handle inline HTML.\n     * - 'skip': Ignore inline HTML (default)\n     * - 'text': Convert inline HTML to plain text\n     *\n     * @defaultValue 'skip'\n     */\n    inline?: 'skip' | 'text'\n  }\n}\n\nconst codeBlockMatcher: ObjectMatcher<\n  ExtractValue<typeof defaultCodeObjectDefinition>\n> = ({context, value, isInline}) => {\n  const defaultMatcher = buildObjectMatcher(defaultCodeObjectDefinition)\n  const codeObject = defaultMatcher({context, value, isInline})\n\n  if (!codeObject) {\n    return undefined\n  }\n\n  if (!('code' in codeObject)) {\n    return undefined\n  }\n\n  return codeObject\n}\n\nconst imageBlockMatcher: ObjectMatcher<\n  ExtractValue<typeof defaultImageObjectDefinition>\n> = ({context, value, isInline}) => {\n  const defaultMatcher = buildObjectMatcher(defaultImageObjectDefinition)\n  const imageObject = defaultMatcher({context, value, isInline})\n\n  if (!imageObject) {\n    return undefined\n  }\n\n  if (!('src' in imageObject)) {\n    return undefined\n  }\n\n  return imageObject\n}\n\nconst defaultOptions = {\n  schema: defaultSchema,\n  keyGenerator: defaultKeyGenerator,\n  html: {\n    inline: 'skip',\n  },\n  block: {\n    normal: buildStyleMatcher(normalStyleDefinition),\n    blockquote: buildStyleMatcher(blockquoteStyleDefinition),\n    h1: buildStyleMatcher(h1StyleDefinition),\n    h2: buildStyleMatcher(h2StyleDefinition),\n    h3: buildStyleMatcher(h3StyleDefinition),\n    h4: buildStyleMatcher(h4StyleDefinition),\n    h5: buildStyleMatcher(h5StyleDefinition),\n    h6: buildStyleMatcher(h6StyleDefinition),\n  },\n  listItem: {\n    number: buildListItemMatcher(defaultOrderedListItemDefinition),\n    bullet: buildListItemMatcher(defaultUnorderedListItemDefinition),\n  },\n  marks: {\n    strong: buildDecoratorMatcher(defaultStrongDecoratorDefinition),\n    em: buildDecoratorMatcher(defaultEmDecoratorDefinition),\n    code: buildDecoratorMatcher(defaultCodeDecoratorDefinition),\n    strikeThrough: buildDecoratorMatcher(\n      defaultStrikeThroughDecoratorDefinition,\n    ),\n    link: buildAnnotationMatcher(defaultLinkObjectDefinition),\n  },\n  types: {\n    code: codeBlockMatcher,\n    horizontalRule: buildObjectMatcher(defaultHorizontalRuleObjectDefinition),\n    html: buildObjectMatcher(defaultHtmlObjectDefinition),\n    image: imageBlockMatcher,\n  },\n} as const satisfies Options\n\n/**\n * Flattens a table structure by lifting all blocks from all cells.\n */\nfunction flattenTable(\n  table: {\n    rows: Array<{\n      _key: string\n      _type: 'row'\n      cells: Array<{\n        _type: 'cell'\n        _key: string\n        value: Array<PortableTextBlock>\n      }>\n    }>\n    headerRows: number\n  },\n  portableText: Array<PortableTextBlock>,\n): void {\n  // Flatten the table by lifting all blocks from all cells\n  for (const row of table.rows) {\n    for (const cell of row.cells) {\n      for (const block of cell.value) {\n        portableText.push(block)\n      }\n    }\n  }\n}\n\n/**\n * Converts a markdown string to an array of Portable Text blocks.\n *\n * @public\n */\nexport function markdownToPortableText(\n  markdown: string,\n  options?: Options,\n): Array<PortableTextBlock> {\n  const consolidatedOptions = {\n    schema: options?.schema ?? defaultSchema,\n    keyGenerator: options?.keyGenerator ?? defaultKeyGenerator,\n    html: {\n      inline: options?.html?.inline ?? 'skip',\n    },\n    marks: {\n      ...defaultOptions.marks,\n      ...options?.marks,\n    },\n    block: {\n      ...defaultOptions.block,\n      ...options?.block,\n    },\n    listItem: {\n      ...defaultOptions.listItem,\n      ...options?.listItem,\n    },\n    types: {\n      ...defaultOptions.types,\n      ...options?.types,\n    },\n  }\n\n  const md = markdownit({\n    html: true,\n    linkify: true,\n    typographer: true,\n  }).enable(['strikethrough', 'table'])\n\n  const tokens = md.parse(markdown, {})\n\n  const portableText: Array<PortableTextBlock> = []\n\n  // State\n  let currentBlock: PortableTextTextBlock | null = null\n  const currentListStack: Array<string | null> = []\n  const markDefRefs: Array<string> = [] // mark keys: 'strong', 'em', 'code', or link keys\n  let currentMarkDefs: Array<PortableTextObject> = []\n  let currentBlockquoteStyle: string | null = null // Track blockquote style when inside blockquote\n  let inListItem = false // Track if we're inside a list item\n\n  // Table state\n  let currentTable: {\n    rows: Array<{\n      _key: string\n      _type: 'row'\n      cells: Array<{\n        _type: 'cell'\n        _key: string\n        value: Array<PortableTextBlock>\n      }>\n    }>\n    headerRows: number\n  } | null = null\n  let currentTableRow: Array<{\n    _type: 'cell'\n    _key: string\n    value: Array<PortableTextBlock>\n  }> | null = null\n  let inTableHead = false\n\n  const startBlock = (style: string) => {\n    flushBlock()\n    currentBlock = {\n      _type: 'block' as const,\n      style,\n      children: [],\n      _key: consolidatedOptions.keyGenerator(),\n      markDefs: [],\n    }\n    currentMarkDefs = []\n  }\n\n  const flushBlock = () => {\n    if (!currentBlock) {\n      return\n    }\n\n    // Text blocks must have at least one child span\n    if (currentBlock.children.length === 0) {\n      currentBlock.children.push({\n        _type: consolidatedOptions.schema.span.name,\n        _key: consolidatedOptions.keyGenerator(),\n        text: '',\n        marks: [],\n      })\n    }\n\n    // Assign accumulated markDefs to the block\n    currentBlock.markDefs = currentMarkDefs\n\n    portableText.push(currentBlock)\n\n    currentBlock = null\n    currentMarkDefs = []\n  }\n\n  const addSpan = (text: string) => {\n    if (text.length === 0) {\n      return\n    }\n\n    if (!currentBlock) {\n      const style =\n        currentBlockquoteStyle ??\n        consolidatedOptions.block.normal({\n          context: {schema: consolidatedOptions.schema},\n        })\n\n      if (!style) {\n        console.warn('No default style found, using \"normal\"')\n        startBlock('normal')\n      } else {\n        startBlock(style)\n      }\n    }\n\n    if (!currentBlock) {\n      throw new Error('Expected current block')\n    }\n\n    const lastChild = currentBlock.children.at(-1)\n\n    if (\n      isSpan({schema: consolidatedOptions.schema}, lastChild) &&\n      lastChild.marks?.every((mark) => markDefRefs.includes(mark)) &&\n      markDefRefs.every((mark) => lastChild.marks?.includes(mark))\n    ) {\n      // Merge with previous span if marks match\n      lastChild.text += text\n    } else {\n      currentBlock.children.push({\n        _type: consolidatedOptions.schema.span.name,\n        _key: consolidatedOptions.keyGenerator(),\n        text: text,\n        marks: [...markDefRefs],\n      })\n    }\n  }\n\n  // Helpers for lists\n  const listLevel = () => currentListStack.length\n  const ensureListBlock = (listItem: string) => {\n    if (!currentBlock) {\n      // Use blockquote style if inside a blockquote, otherwise use normal style\n      const style =\n        currentBlockquoteStyle ??\n        consolidatedOptions.block.normal({\n          context: {schema: consolidatedOptions.schema},\n        })\n\n      if (!style) {\n        console.warn('No default style found, using \"normal\"')\n        startBlock('normal')\n      } else {\n        startBlock(style)\n      }\n    }\n\n    if (!currentBlock) {\n      throw new Error('Expected current block')\n    }\n\n    if (\n      currentBlock.listItem !== listItem ||\n      currentBlock.level !== listLevel()\n    ) {\n      currentBlock.listItem = listItem\n      currentBlock.level = listLevel()\n    }\n  }\n\n  // Walk tokens\n  for (const token of tokens) {\n    switch (token.type) {\n      // Paragraphs\n      case 'paragraph_open': {\n        // If we're in a list item but have no current block (e.g., after a code block),\n        // we need to create a new list item block\n        if (inListItem) {\n          if (!currentBlock) {\n            const listType = currentListStack.at(-1)\n\n            if (listType) {\n              ensureListBlock(listType)\n            }\n          }\n\n          break\n        }\n\n        // Use blockquote style if inside a blockquote, otherwise use normal style\n        const style =\n          currentBlockquoteStyle ??\n          consolidatedOptions.block.normal({\n            context: {schema: consolidatedOptions.schema},\n          })\n\n        if (!style) {\n          console.warn('No default style found, using \"normal\"')\n          startBlock('normal')\n          break\n        }\n\n        startBlock(style)\n        break\n      }\n      case 'paragraph_close':\n        // Skip flushing if we're inside a list item (list_item_close will flush)\n        if (inListItem) {\n          break\n        }\n        flushBlock()\n        break\n\n      // Headings\n      case 'heading_open': {\n        const level = Number(token?.tag?.slice(1))\n\n        // Map level to the appropriate heading matcher\n        const headingMatchers = {\n          1: consolidatedOptions.block.h1,\n          2: consolidatedOptions.block.h2,\n          3: consolidatedOptions.block.h3,\n          4: consolidatedOptions.block.h4,\n          5: consolidatedOptions.block.h5,\n          6: consolidatedOptions.block.h6,\n        } as const\n\n        const headingMatcher =\n          headingMatchers[level as keyof typeof headingMatchers]\n\n        const style =\n          headingMatcher?.({\n            context: {schema: consolidatedOptions.schema},\n          }) ??\n          consolidatedOptions.block.normal({\n            context: {schema: consolidatedOptions.schema},\n          })\n\n        if (!style) {\n          console.warn('No heading style found, using \"normal\"')\n          startBlock('normal')\n          break\n        }\n\n        startBlock(style)\n        break\n      }\n      case 'heading_close':\n        flushBlock()\n        break\n\n      // Blockquote\n      case 'blockquote_open': {\n        // Flush any current block before entering blockquote\n        flushBlock()\n\n        // Set the blockquote style for paragraphs inside the blockquote\n        const style =\n          consolidatedOptions.block.blockquote({\n            context: {schema: consolidatedOptions.schema},\n          }) ??\n          consolidatedOptions.block.normal({\n            context: {schema: consolidatedOptions.schema},\n          })\n\n        currentBlockquoteStyle = style ?? 'normal'\n        break\n      }\n      case 'blockquote_close': {\n        // Flush any blockquote content before exiting\n        flushBlock()\n        currentBlockquoteStyle = null\n        break\n      }\n      // Lists\n      case 'bullet_list_open': {\n        const listItem = consolidatedOptions.listItem.bullet({\n          context: {schema: consolidatedOptions.schema},\n        })\n\n        if (!listItem) {\n          // No list definition in schema, push null to indicate we should skip list properties\n          currentListStack.push(null)\n          break\n        }\n\n        currentListStack.push(listItem)\n        break\n      }\n      case 'ordered_list_open': {\n        const listItem = consolidatedOptions.listItem.number({\n          context: {schema: consolidatedOptions.schema},\n        })\n\n        if (!listItem) {\n          // No list definition in schema, push null to indicate we should skip list properties\n          currentListStack.push(null)\n          break\n        }\n\n        currentListStack.push(listItem)\n        break\n      }\n      case 'bullet_list_close':\n      case 'ordered_list_close':\n        currentListStack.pop()\n        break\n      case 'list_item_open': {\n        const listType = currentListStack.at(-1)\n\n        if (listType === undefined) {\n          throw new Error('Expected an open list')\n        }\n\n        // Flush any previous list item block before starting a new one\n        // This is needed for proper separation of list items\n        if (currentBlock) {\n          flushBlock()\n        }\n\n        // If listType is null, it means there's no list definition in the schema\n        // Just create a normal block without list properties\n        if (listType === null) {\n          // Use blockquote style if inside a blockquote, otherwise use normal style\n          const style =\n            currentBlockquoteStyle ??\n            consolidatedOptions.block.normal({\n              context: {schema: consolidatedOptions.schema},\n            })\n\n          if (!style) {\n            console.warn('No default style found, using \"normal\"')\n            startBlock('normal')\n          } else {\n            startBlock(style)\n          }\n          inListItem = true\n          break\n        }\n\n        ensureListBlock(listType)\n        inListItem = true\n        break\n      }\n      case 'list_item_close':\n        inListItem = false\n        flushBlock()\n        break\n\n      // Code fences / blocks\n      case 'fence': {\n        flushBlock()\n\n        const language = token.info.trim() || undefined\n        // Remove trailing newline from code content\n        const code = token.content.replace(/\\n$/, '')\n\n        const codeObject = consolidatedOptions.types.code({\n          context: {\n            schema: consolidatedOptions.schema,\n            keyGenerator: consolidatedOptions.keyGenerator,\n          },\n          value: {language, code},\n          isInline: false,\n        })\n\n        if (!codeObject) {\n          // Code block not in schema, fall back to text block\n          const style = consolidatedOptions.block.normal({\n            context: {schema: consolidatedOptions.schema},\n          })\n\n          if (!style) {\n            console.warn('No default style found, using \"normal\"')\n            startBlock('normal')\n          } else {\n            startBlock(style)\n          }\n\n          addSpan(code)\n          flushBlock()\n          break\n        }\n\n        portableText.push(codeObject)\n\n        break\n      }\n\n      // Horizontal rule\n      case 'hr': {\n        flushBlock()\n\n        const hrObject = consolidatedOptions.types.horizontalRule({\n          context: {\n            schema: consolidatedOptions.schema,\n            keyGenerator: consolidatedOptions.keyGenerator,\n          },\n          value: {},\n          isInline: false,\n        })\n\n        if (!hrObject) {\n          // If there's no break definition in the schema, parse as text\n          const style = consolidatedOptions.block.normal({\n            context: {schema: consolidatedOptions.schema},\n          })\n\n          if (!style) {\n            console.warn('No default style found, using \"normal\"')\n            startBlock('normal')\n          } else {\n            startBlock(style)\n          }\n\n          addSpan('---')\n          flushBlock()\n          break\n        }\n\n        portableText.push(hrObject)\n\n        break\n      }\n\n      // HTML block\n      case 'html_block': {\n        flushBlock()\n\n        const htmlContent = token.content.trim()\n\n        if (!htmlContent) {\n          break\n        }\n\n        const htmlObject = consolidatedOptions.types.html({\n          context: {\n            schema: consolidatedOptions.schema,\n            keyGenerator: consolidatedOptions.keyGenerator,\n          },\n          value: {html: htmlContent},\n          isInline: false,\n        })\n\n        if (!htmlObject) {\n          // If there's no HTML block definition in the schema, parse as text\n          const style = consolidatedOptions.block.normal({\n            context: {schema: consolidatedOptions.schema},\n          })\n\n          if (!style) {\n            console.warn('No default style found, using \"normal\"')\n            startBlock('normal')\n          } else {\n            startBlock(style)\n          }\n\n          addSpan(htmlContent)\n          flushBlock()\n          break\n        }\n\n        portableText.push(htmlObject)\n\n        break\n      }\n\n      case 'code_block': {\n        flushBlock()\n\n        // Remove trailing newline from code content\n        const code = token.content.replace(/\\n$/, '')\n\n        const codeObject = consolidatedOptions.types.code({\n          context: {\n            schema: consolidatedOptions.schema,\n            keyGenerator: consolidatedOptions.keyGenerator,\n          },\n          value: {language: undefined, code},\n          isInline: false,\n        })\n\n        if (!codeObject) {\n          // Code block not in schema, fall back to text block\n          const style = consolidatedOptions.block.normal({\n            context: {schema: consolidatedOptions.schema},\n          })\n\n          if (!style) {\n            console.warn('No default style found, using \"normal\"')\n            startBlock('normal')\n          } else {\n            startBlock(style)\n          }\n\n          addSpan(code)\n          flushBlock()\n        } else {\n          portableText.push(codeObject)\n        }\n\n        break\n      }\n\n      // Tables\n      case 'table_open':\n        flushBlock()\n        currentTable = {rows: [], headerRows: 0}\n        break\n\n      case 'table_close': {\n        if (!currentTable) {\n          break\n        }\n\n        // Only create table object if table type is defined\n        if (consolidatedOptions.types.table) {\n          const tableObject = consolidatedOptions.types.table({\n            context: {\n              schema: consolidatedOptions.schema,\n              keyGenerator: consolidatedOptions.keyGenerator,\n            },\n            value: {\n              rows: currentTable.rows,\n              headerRows:\n                currentTable.headerRows > 0\n                  ? currentTable.headerRows\n                  : undefined,\n            },\n            isInline: false,\n          })\n\n          if (tableObject) {\n            portableText.push(tableObject)\n          } else {\n            // If table object couldn't be created, flatten the table\n            flattenTable(currentTable, portableText)\n          }\n        } else {\n          // If there's no table definition in the schema, flatten the table\n          flattenTable(currentTable, portableText)\n        }\n\n        currentTable = null\n        break\n      }\n\n      case 'thead_open':\n        inTableHead = true\n        break\n\n      case 'thead_close':\n        inTableHead = false\n        break\n\n      case 'tbody_open':\n      case 'tbody_close':\n        // Just markers, no action needed\n        break\n\n      case 'tr_open':\n        currentTableRow = []\n        break\n\n      case 'tr_close':\n        if (currentTable && currentTableRow) {\n          currentTable.rows.push({\n            _key: consolidatedOptions.keyGenerator(),\n            _type: 'row',\n            cells: currentTableRow,\n          })\n          if (inTableHead) {\n            currentTable.headerRows++\n          }\n        }\n        currentTableRow = null\n        break\n\n      case 'th_open':\n      case 'td_open': {\n        // Start a new block for the table cell\n        const style = consolidatedOptions.block.normal({\n          context: {schema: consolidatedOptions.schema},\n        })\n\n        if (!style) {\n          console.warn('No default style found, using \"normal\"')\n          startBlock('normal')\n        } else {\n          startBlock(style)\n        }\n        break\n      }\n\n      case 'th_close':\n      case 'td_close': {\n        // Flush the current block into the cell\n        flushBlock()\n\n        // Get all blocks that were added since this cell started\n        // We need to extract them from portableText array\n        const cellBlocks: Array<PortableTextBlock> = []\n\n        // Check if we have blocks to extract (added after table_open)\n        if (portableText.length > 0) {\n          const lastBlock = portableText.at(-1)\n          if (lastBlock && lastBlock._type === 'block') {\n            cellBlocks.push(portableText.pop()!)\n          }\n        }\n\n        // If no blocks were created (empty cell), create an empty block\n        if (cellBlocks.length === 0) {\n          cellBlocks.push({\n            _type: 'block' as const,\n            style:\n              consolidatedOptions.block.normal({\n                context: {schema: consolidatedOptions.schema},\n              }) || 'normal',\n            children: [\n              {\n                _type: consolidatedOptions.schema.span.name,\n                _key: consolidatedOptions.keyGenerator(),\n                text: '',\n                marks: [],\n              },\n            ],\n            _key: consolidatedOptions.keyGenerator(),\n            markDefs: [],\n          })\n        }\n\n        // Check if the cell contains a single block with a single image child\n        // If so, extract the image as a block-level image\n        const firstBlock = cellBlocks[0]\n        if (\n          cellBlocks.length === 1 &&\n          firstBlock &&\n          firstBlock._type === 'block' &&\n          'children' in firstBlock &&\n          Array.isArray(firstBlock.children) &&\n          firstBlock.children.length === 1\n        ) {\n          const onlyChild = firstBlock.children[0]\n          // Check if it's an image object (not a span)\n          if (\n            typeof onlyChild === 'object' &&\n            onlyChild !== null &&\n            '_type' in onlyChild &&\n            onlyChild._type !== consolidatedOptions.schema.span.name &&\n            onlyChild._type === 'image'\n          ) {\n            // Replace the block with just the image\n            cellBlocks[0] = onlyChild as PortableTextBlock\n          }\n        }\n\n        if (currentTableRow !== null) {\n          currentTableRow.push({\n            _type: 'cell',\n            _key: consolidatedOptions.keyGenerator(),\n            value: cellBlocks,\n          })\n        }\n        break\n      }\n\n      // Inline container\n      case 'inline': {\n        // Check if we're in a table cell\n        const inTableCell = currentTableRow !== null\n\n        // Check if this is a standalone image (paragraph with only an image)\n        if (\n          token.children?.length === 1 &&\n          token.children[0]?.type === 'image'\n        ) {\n          const imageToken = token.children[0]\n          if (!imageToken) {\n            break\n          }\n\n          const src =\n            imageToken.attrs?.find(([name]) => name === 'src')?.at(1) || ''\n          const alt = unescapeImageAndLinkText(imageToken.content || '')\n          const title =\n            imageToken.attrs?.find(([name]) => name === 'title')?.at(1) ||\n            undefined\n\n          const blockImageObject = consolidatedOptions.types.image({\n            context: {\n              schema: consolidatedOptions.schema,\n              keyGenerator: consolidatedOptions.keyGenerator,\n            },\n            value: {src, alt, title},\n            isInline: false,\n          })\n\n          if (blockImageObject) {\n            if (inTableCell) {\n              // In table cells, we can't push to portableText directly\n              // The block image will be handled in th_close/td_close extraction logic\n              // For now, add it as a child of the current block\n              if (currentBlock && 'children' in currentBlock) {\n                ;(currentBlock as PortableTextTextBlock).children.push(\n                  blockImageObject as PortableTextObject,\n                )\n              }\n            } else {\n              // If the current block has content, flush it before adding the block image\n              // Otherwise, discard the empty block that was created by paragraph_open\n              const hasContent =\n                currentBlock &&\n                'children' in currentBlock &&\n                (currentBlock as PortableTextTextBlock).children.length > 0\n\n              if (hasContent) {\n                flushBlock()\n              } else {\n                currentBlock = null\n                currentMarkDefs = []\n              }\n              portableText.push(blockImageObject)\n            }\n            break\n          }\n\n          // Block image not supported, try inline image as fallback\n          const inlineImageObject = consolidatedOptions.types.image({\n            context: {\n              schema: consolidatedOptions.schema,\n              keyGenerator: consolidatedOptions.keyGenerator,\n            },\n            value: {src, alt, title},\n            isInline: true,\n          })\n\n          if (inlineImageObject) {\n            // Ensure we have a block to add the inline image to\n            if (!currentBlock) {\n              if (inListItem) {\n                const listType = currentListStack.at(-1)\n\n                if (listType) {\n                  ensureListBlock(listType)\n                }\n              } else {\n                const style = consolidatedOptions.block.normal({\n                  context: {schema: consolidatedOptions.schema},\n                })\n\n                if (style) {\n                  startBlock(style)\n                }\n              }\n            }\n\n            if (currentBlock && 'children' in currentBlock) {\n              ;(currentBlock as PortableTextTextBlock).children.push(\n                inlineImageObject as PortableTextObject,\n              )\n            }\n            break\n          }\n\n          // Neither block nor inline image supported, fall back to text\n          addSpan(`![${alt}](${src})`)\n          break\n        }\n\n        // Walk its children for text/marks/links\n        for (const childToken of token.children ?? []) {\n          switch (childToken.type) {\n            case 'text':\n              addSpan(childToken.content)\n              break\n            case 'softbreak':\n            case 'hardbreak':\n              addSpan('\\n')\n              break\n            case 'code_inline': {\n              const decorator = consolidatedOptions.marks.code({\n                context: {schema: consolidatedOptions.schema},\n              })\n\n              if (!decorator) {\n                // No code decorator defined, just add the content without marks\n                addSpan(childToken.content)\n                break\n              }\n\n              markDefRefs.push(decorator)\n              addSpan(childToken.content)\n\n              // code_inline is self-contained, so we need to pop the decorator\n              const index = markDefRefs.lastIndexOf(decorator)\n\n              if (index !== -1) {\n                markDefRefs.splice(index, 1)\n              }\n\n              break\n            }\n            case 'strong_open': {\n              const decorator = consolidatedOptions.marks.strong({\n                context: {schema: consolidatedOptions.schema},\n              })\n\n              if (!decorator) {\n                break\n              }\n\n              markDefRefs.push(decorator)\n              break\n            }\n            case 'strong_close': {\n              const decorator = consolidatedOptions.marks.strong({\n                context: {schema: consolidatedOptions.schema},\n              })\n\n              if (!decorator) {\n                break\n              }\n\n              const index = markDefRefs.lastIndexOf(decorator)\n\n              if (index !== -1) {\n                markDefRefs.splice(index, 1)\n              }\n\n              break\n            }\n            case 'em_open': {\n              const decorator = consolidatedOptions.marks.em({\n                context: {schema: consolidatedOptions.schema},\n              })\n\n              if (!decorator) {\n                break\n              }\n\n              markDefRefs.push(decorator)\n\n              break\n            }\n            case 'em_close': {\n              const decorator = consolidatedOptions.marks.em({\n                context: {schema: consolidatedOptions.schema},\n              })\n\n              if (!decorator) {\n                break\n              }\n\n              const index = markDefRefs.lastIndexOf(decorator)\n\n              if (index !== -1) {\n                markDefRefs.splice(index, 1)\n              }\n\n              break\n            }\n            case 's_open': {\n              const decorator = consolidatedOptions.marks.strikeThrough({\n                context: {schema: consolidatedOptions.schema},\n              })\n\n              if (!decorator) {\n                break\n              }\n\n              markDefRefs.push(decorator)\n\n              break\n            }\n            case 's_close': {\n              const decorator = consolidatedOptions.marks.strikeThrough({\n                context: {schema: consolidatedOptions.schema},\n              })\n\n              if (!decorator) {\n                break\n              }\n\n              const index = markDefRefs.lastIndexOf(decorator)\n\n              if (index !== -1) {\n                markDefRefs.splice(index, 1)\n              }\n\n              break\n            }\n            case 'link_open': {\n              const href = childToken.attrs\n                ?.find(([name]) => name === 'href')\n                ?.at(1)\n\n              if (!href) {\n                break\n              }\n\n              const title = childToken.attrs\n                ?.find(([name]) => name === 'title')\n                ?.at(1)\n\n              const linkObject = consolidatedOptions.marks.link({\n                context: {\n                  schema: consolidatedOptions.schema,\n                  keyGenerator: consolidatedOptions.keyGenerator,\n                },\n                value: {href, title},\n              })\n\n              if (!linkObject) {\n                break\n              }\n\n              currentMarkDefs.push(linkObject)\n              markDefRefs.push(linkObject._key)\n              break\n            }\n            case 'link_close': {\n              // remove the last link key\n              const markDefKeys = new Set(currentMarkDefs.map((d) => d._key))\n              let lastLinkIndex: number | undefined\n\n              for (const markDefRef of markDefRefs.reverse()) {\n                if (markDefKeys.has(markDefRef)) {\n                  lastLinkIndex = markDefRefs.indexOf(markDefRef)\n                  break\n                }\n              }\n\n              if (lastLinkIndex !== undefined) {\n                const realIndex = markDefRefs.length - 1 - lastLinkIndex\n                markDefRefs.splice(realIndex, 1)\n              }\n              break\n            }\n            case 'image': {\n              const src =\n                childToken.attrs?.find(([name]) => name === 'src')?.at(1) || ''\n              const alt = unescapeImageAndLinkText(childToken.content || '')\n\n              // Try to create an inline image first\n              const inlineImageObject = consolidatedOptions.types.image({\n                context: {\n                  schema: consolidatedOptions.schema,\n                  keyGenerator: consolidatedOptions.keyGenerator,\n                },\n                value: {src, alt, title: undefined},\n                isInline: true,\n              })\n\n              if (inlineImageObject) {\n                // Inline image is supported - add it to current block\n                if (!currentBlock) {\n                  const style = consolidatedOptions.block.normal({\n                    context: {schema: consolidatedOptions.schema},\n                  })\n\n                  if (!style) {\n                    console.warn('No default style found, using \"normal\"')\n                    startBlock('normal')\n                  } else {\n                    startBlock(style)\n                  }\n                }\n\n                // At this point currentBlock should exist\n                if (!currentBlock) {\n                  throw new Error('Expected current block after startBlock')\n                }\n\n                // Add the image as an inline object (TypeScript assertion needed for type narrowing)\n                ;(currentBlock as PortableTextTextBlock).children.push(\n                  inlineImageObject as PortableTextObject,\n                )\n                break\n              }\n\n              // Inline image not supported - try block image as fallback\n              const blockImageObject = consolidatedOptions.types.image({\n                context: {\n                  schema: consolidatedOptions.schema,\n                  keyGenerator: consolidatedOptions.keyGenerator,\n                },\n                value: {src, alt, title: undefined},\n                isInline: false,\n              })\n\n              if (!blockImageObject) {\n                // Neither inline nor block image supported\n                addSpan(`![${alt}](${src})`)\n                break\n              }\n\n              // Block image supported - flush current block and add as block-level\n              // Skip if we're in a table cell (images in cells are handled differently)\n              if (inTableCell) {\n                // In table cells, add the image to current block (will be extracted later)\n                if (currentBlock && 'children' in currentBlock) {\n                  ;(currentBlock as PortableTextTextBlock).children.push(\n                    blockImageObject as PortableTextObject,\n                  )\n                }\n                break\n              }\n\n              // Not in table - flush current block, add image as block, start new block\n              flushBlock()\n              portableText.push(blockImageObject)\n\n              // Start a new block for any remaining content\n              const style = consolidatedOptions.block.normal({\n                context: {schema: consolidatedOptions.schema},\n              })\n\n              if (style) {\n                startBlock(style)\n              }\n\n              break\n            }\n            case 'html_inline': {\n              // Handle inline HTML based on configuration\n              if (consolidatedOptions.html.inline === 'text') {\n                addSpan(childToken.content)\n              }\n              // 'skip' - do nothing, ignore the HTML\n              break\n            }\n            default:\n              // Ignore other inline token types by default\n              break\n          }\n        }\n        break\n      }\n\n      default:\n        break\n    }\n  }\n\n  flushBlock()\n\n  return portableText\n}\n"],"names":["levelIndexMap","filteredValue","style"],"mappings":"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"}},
    {"offset": {"line": 3941, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@portabletext/patches/dist/index.js","sources":["file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/patches/src/arrayInsert.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/patches/src/array.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/patches/src/number.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/patches/src/object.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/patches/src/primitive.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/patches/src/string.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/patches/src/applyPatch.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/patches/src/patches.ts"],"sourcesContent":["export const BEFORE = 'before'\nexport const AFTER = 'after'\n\nexport default function insert(\n  array: any[],\n  position: string,\n  index: number,\n  ...args: any[]\n) {\n  if (position !== BEFORE && position !== AFTER) {\n    throw new Error(\n      `Invalid position \"${position}\", must be either ${BEFORE} or ${AFTER}`,\n    )\n  }\n\n  const items = flatten(...args)\n\n  if (array.length === 0) {\n    return items\n  }\n\n  const len = array.length\n  const idx = Math.abs((len + index) % len) % len\n\n  const normalizedIdx = position === 'after' ? idx + 1 : idx\n\n  const copy = array.slice()\n  copy.splice(normalizedIdx, 0, ...flatten(items))\n  return copy\n}\n\nfunction flatten(...values: any[]) {\n  return values.reduce((prev, item) => prev.concat(item), [])\n}\n","import applyPatch from './applyPatch'\nimport insert from './arrayInsert'\nimport type {JSONValue, KeyedSegment, Patch, PathSegment} from './types'\n\nfunction isKeyedSegment(segment: unknown): segment is KeyedSegment {\n  return typeof segment === 'object' && segment !== null && '_key' in segment\n}\n\nfunction findTargetIndex(array: any[], pathSegment: PathSegment | undefined) {\n  if (typeof pathSegment === 'number') {\n    return pathSegment\n  }\n  if (isKeyedSegment(pathSegment)) {\n    const index = array.findIndex((item) => item._key === pathSegment._key)\n    return index === -1 ? false : index\n  }\n  return false\n}\n\nexport function applyPatchToArray(\n  value: Array<JSONValue>,\n  patch: Patch,\n): Array<JSONValue> | undefined {\n  const nextValue = value.slice() // make a copy for internal mutation\n\n  if (patch.path.length === 0) {\n    // its directed to me\n    if (patch.type === 'setIfMissing') {\n      if (!Array.isArray(patch.value)) {\n        throw new Error('Cannot set value of an array to a non-array')\n      }\n\n      return value === undefined ? patch.value : value\n    }\n\n    if (patch.type === 'set') {\n      if (!Array.isArray(patch.value)) {\n        throw new Error('Cannot set value of an array to a non-array')\n      }\n\n      return patch.value\n    }\n\n    if (patch.type === 'unset') {\n      return undefined\n    }\n\n    throw new Error(`Invalid array operation: ${patch.type}`)\n  }\n\n  const [head, ...tail] = patch.path\n\n  const index = findTargetIndex(value, head)\n\n  // If the given selector could not be found, return as-is\n  if (index === false) {\n    return nextValue\n  }\n\n  if (tail.length === 0) {\n    if (patch.type === 'insert') {\n      const {position, items} = patch\n      return insert(value, position, index, items)\n    } else if (patch.type === 'unset') {\n      if (typeof index !== 'number') {\n        throw new Error(\n          `Expected array index to be a number, instead got \"${index}\"`,\n        )\n      }\n      nextValue.splice(index, 1)\n      return nextValue\n    }\n  }\n\n  // The patch is not directed to me\n  nextValue[index] = applyPatch(nextValue[index], {\n    ...patch,\n    path: tail,\n  }) as JSONValue\n\n  return nextValue\n}\n","import type {Patch} from './types'\n\nexport function applyPatchToNumber(value: number, patch: Patch) {\n  if (patch.path.length > 0) {\n    throw new Error(\n      `Cannot apply deep operations on primitive values. Received patch with type \"${\n        patch.type\n      }\" and path \"${patch.path\n        .map((path: any) => JSON.stringify(path))\n        .join('.')} that targeted the value \"${JSON.stringify(value)}\"`,\n    )\n  }\n\n  if (patch.type === 'set') {\n    return patch.value\n  }\n\n  if (patch.type === 'setIfMissing') {\n    return value === undefined ? patch.value : value\n  }\n\n  if (patch.type === 'unset') {\n    return undefined\n  }\n\n  if (patch.type === 'inc') {\n    if (typeof patch.value !== 'number') {\n      throw new Error('Cannot increment with a non-number')\n    }\n\n    return value + patch.value\n  }\n\n  if (patch.type === 'dec') {\n    if (typeof patch.value !== 'number') {\n      throw new Error('Cannot decrement with a non-number')\n    }\n\n    return value - patch.value\n  }\n\n  throw new Error(\n    `Received patch of unsupported type: \"${JSON.stringify(\n      patch.type,\n    )}\" for number. This is most likely a bug.`,\n  )\n}\n","import applyPatch from './applyPatch'\nimport type {JSONValue, Patch} from './types'\n\nexport function applyPatchToObject(\n  value: {[key: string]: JSONValue},\n  patch: Patch,\n): {[key: string]: JSONValue} | undefined {\n  const nextValue = {...value}\n\n  if (patch.path.length === 0) {\n    // its directed to me\n    if (patch.type === 'set') {\n      if (\n        typeof patch.value === 'object' &&\n        patch.value !== null &&\n        !Array.isArray(patch.value)\n      ) {\n        return patch.value\n      }\n\n      throw new Error('Cannot set value of an object to a non-object')\n    }\n\n    if (patch.type === 'setIfMissing') {\n      if (\n        typeof patch.value === 'object' &&\n        patch.value !== null &&\n        !Array.isArray(patch.value)\n      ) {\n        return value\n      }\n\n      throw new Error('Cannot setIfMissing value of an object to a non-object')\n    }\n\n    if (patch.type === 'unset') {\n      return undefined\n    }\n\n    throw new Error(`Invalid object operation: ${patch.type}`)\n  }\n\n  // The patch is not directed to me\n  const [head, ...tail] = patch.path\n\n  if (typeof head !== 'string') {\n    throw new Error(`Expected field name to be a string, instead got: ${head}`)\n  }\n\n  if (tail.length === 0 && patch.type === 'unset') {\n    const {[head]: _, ...rest} = nextValue\n    return rest\n  }\n\n  if (!(head in nextValue) && tail.length > 0) {\n    // The field does not exist on the object so we can just return the object\n    // as is\n    return nextValue\n  }\n\n  nextValue[head] = applyPatch(nextValue[head], {\n    ...patch,\n    path: tail,\n  }) as JSONValue\n\n  return nextValue\n}\n","import type {JSONValue, Patch} from './types'\n\nexport function applyPatchToUnknown(\n  value: unknown,\n  patch: Patch,\n): JSONValue | undefined {\n  if (patch.path.length > 0) {\n    throw new Error(\n      `Cannot apply deep operations on primitive values. Received patch with type \"${\n        patch.type\n      }\" and path \"${patch.path\n        .map((path: any) => JSON.stringify(path))\n        .join('.')} that targeted the value \"${JSON.stringify(value)}\"`,\n    )\n  }\n\n  if (patch.type === 'set') {\n    return patch.value\n  }\n\n  if (patch.type === 'setIfMissing') {\n    return value === undefined ? patch.value : (value as JSONValue)\n  }\n\n  if (patch.type === 'unset') {\n    return undefined\n  }\n\n  throw new Error(\n    `Received patch of unsupported type: \"${JSON.stringify(\n      patch.type,\n    )}\" for primitives. This is most likely a bug.`,\n  )\n}\n","import {applyPatches, parsePatch} from '@sanity/diff-match-patch'\nimport type {Patch} from './types'\n\nexport function applyPatchToString(value: string, patch: Patch) {\n  if (patch.path.length > 0) {\n    throw new Error(\n      `Cannot apply deep operations on string values. Received patch with type \"${\n        patch.type\n      }\" and path \"${patch.path.join('.')} that targeted the value \"${JSON.stringify(value)}\"`,\n    )\n  }\n\n  if (patch.type === 'diffMatchPatch') {\n    const [result] = applyPatches(parsePatch(patch.value), value, {\n      allowExceedingIndices: true,\n    })\n    return result\n  }\n\n  if (patch.type === 'setIfMissing') {\n    return value === undefined ? patch.value : value\n  }\n\n  if (patch.type === 'set') {\n    return patch.value\n  }\n\n  if (patch.type === 'unset') {\n    return undefined\n  }\n\n  throw new Error(\n    `Received patch of unsupported type: \"${JSON.stringify(\n      patch.type,\n    )}\" for string. This is most likely a bug.`,\n  )\n}\n","import {applyPatchToArray} from './array'\nimport {applyPatchToNumber} from './number'\nimport {applyPatchToObject} from './object'\nimport {applyPatchToUnknown} from './primitive'\nimport {applyPatchToString} from './string'\nimport type {JSONValue, Patch} from './types'\n\n/** @beta */\nexport function applyAll<TValue>(value: TValue, patches: Array<Patch>): TValue {\n  return patches.reduce(applyPatch, value) as TValue\n}\n\nexport default function applyPatch(value: unknown, patch: Patch) {\n  if (Array.isArray(value)) {\n    return applyPatchToArray(value, patch)\n  }\n\n  if (typeof value === 'string') {\n    return applyPatchToString(value, patch)\n  }\n\n  if (isObject(value)) {\n    return applyPatchToObject(value, patch)\n  }\n\n  if (typeof value === 'number') {\n    return applyPatchToNumber(value, patch)\n  }\n\n  return applyPatchToUnknown(value, patch)\n}\n\nfunction isObject(value: unknown): value is {[key: string]: JSONValue} {\n  return typeof value === 'object' && value !== null && !Array.isArray(value)\n}\n","import {makePatches, stringifyPatches} from '@sanity/diff-match-patch'\nimport type {\n  DiffMatchPatch,\n  InsertPatch,\n  InsertPosition,\n  Path,\n  PathSegment,\n  SetIfMissingPatch,\n  SetPatch,\n  UnsetPatch,\n} from './types'\n\n/** @public */\nexport function setIfMissing(value: any, path: Path = []): SetIfMissingPatch {\n  return {\n    type: 'setIfMissing',\n    path,\n    value,\n  }\n}\n\n/** @public */\nexport function diffMatchPatch(\n  currentValue: string,\n  nextValue: string,\n  path: Path = [],\n): DiffMatchPatch {\n  const patches = makePatches(currentValue, nextValue)\n  const patch = stringifyPatches(patches)\n  return {type: 'diffMatchPatch', path, value: patch}\n}\n\n/** @public */\nexport function insert(\n  items: any[],\n  position: InsertPosition,\n  path: Path = [],\n): InsertPatch {\n  return {\n    type: 'insert',\n    path,\n    position,\n    items,\n  }\n}\n\n/** @public */\nexport function set(value: any, path: Path = []): SetPatch {\n  return {type: 'set', path, value}\n}\n\n/** @public */\nexport function unset(path: Path = []): UnsetPatch {\n  return {type: 'unset', path}\n}\n\n/** @internal */\nexport function prefixPath<T extends {path: Path}>(\n  patch: T,\n  segment: PathSegment,\n): T {\n  return {\n    ...patch,\n    path: [segment, ...patch.path],\n  }\n}\n"],"names":["insert"],"mappings":"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"}},
    {"offset": {"line": 4132, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@portabletext/keyboard-shortcuts/dist/index.js","sources":["file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/keyboard-shortcuts/src/is-apple.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/keyboard-shortcuts/src/is-keyboard-shortcut.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/keyboard-shortcuts/src/keyboard-shortcuts.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/keyboard-shortcuts/src/common-shortcuts.ts"],"sourcesContent":["export const IS_APPLE =\n  typeof window !== 'undefined' &&\n  /Mac|iPod|iPhone|iPad/.test(window.navigator.userAgent)\n","import type {KeyboardEventDefinition} from './keyboard-event-definition'\n\n/**\n * Checks if a keyboard event matches a keyboard shortcut definition.\n */\nexport function isKeyboardShortcut<\n  TKeyboardEvent extends Pick<\n    KeyboardEvent,\n    'key' | 'code' | 'shiftKey' | 'altKey' | 'ctrlKey' | 'metaKey'\n  > = Pick<\n    KeyboardEvent,\n    'key' | 'code' | 'shiftKey' | 'altKey' | 'ctrlKey' | 'metaKey'\n  >,\n>(definition: KeyboardEventDefinition, event: TKeyboardEvent) {\n  if (!isCorrectModifiers(definition, event)) {\n    return false\n  }\n\n  if (\n    definition.code !== undefined &&\n    definition.code.toLowerCase() === event.code.toLowerCase()\n  ) {\n    return true\n  }\n\n  return (\n    definition.key !== undefined &&\n    definition.key.toLowerCase() === event.key.toLowerCase()\n  )\n}\n\nfunction isCorrectModifiers<\n  TKeyboardEvent extends Pick<\n    KeyboardEvent,\n    'key' | 'code' | 'shiftKey' | 'altKey' | 'ctrlKey' | 'metaKey'\n  > = Pick<\n    KeyboardEvent,\n    'key' | 'code' | 'shiftKey' | 'altKey' | 'ctrlKey' | 'metaKey'\n  >,\n>(definition: KeyboardEventDefinition, event: TKeyboardEvent) {\n  return (\n    (definition.ctrl === event.ctrlKey || definition.ctrl === undefined) &&\n    (definition.meta === event.metaKey || definition.meta === undefined) &&\n    (definition.shift === event.shiftKey || definition.shift === undefined) &&\n    (definition.alt === event.altKey || definition.alt === undefined)\n  )\n}\n","import {IS_APPLE} from './is-apple'\nimport {isKeyboardShortcut} from './is-keyboard-shortcut'\nimport type {KeyboardEventDefinition} from './keyboard-event-definition'\n\n/**\n * @public\n * Definition of a keyboard shortcut with platform-specific keyboard event\n * definitions.\n *\n * `default` keyboard event definitions are required while the `apple`\n * keyboard event definitions are optional.\n *\n * @example\n * ```typescript\n * const boldShortcut: KeyboardShortcutDefinition = {\n *   default: [{\n *     key: 'B',\n *     alt: false,\n *     ctrl: true,\n *     meta: false,\n *     shift: false,\n *   }],\n *   apple: [{\n *     key: 'B',\n *     alt: false,\n *     ctrl: false,\n *     meta: true,\n *     shift: false,\n *   }],\n * }\n * ```\n */\nexport type KeyboardShortcutDefinition = {\n  default: ReadonlyArray<KeyboardEventDefinition>\n  apple?: ReadonlyArray<KeyboardEventDefinition>\n}\n\n/**\n * @public\n * A resolved keyboard shortcut for the current platform that has been\n * processed by `createKeyboardShortcut(...)` to select the appropriate\n * platform-specific key combination. The `guard` function determines if the\n * shortcut applies to the current `KeyboardEvent`, while `keys` contains the\n * display-friendly key combination for the current platform.\n */\nexport type KeyboardShortcut<\n  TKeyboardEvent extends Pick<\n    KeyboardEvent,\n    'key' | 'code' | 'altKey' | 'ctrlKey' | 'metaKey' | 'shiftKey'\n  > = Pick<\n    KeyboardEvent,\n    'key' | 'code' | 'altKey' | 'ctrlKey' | 'metaKey' | 'shiftKey'\n  >,\n> = {\n  guard: (event: TKeyboardEvent) => boolean\n  keys: ReadonlyArray<string>\n}\n\n/**\n * @public\n * Creates a `KeyboardShortcut` from a `KeyboardShortcutDefinition`.\n *\n * `default` keyboard event definitions are required while the `apple`\n * keyboard event definitions are optional.\n *\n * @example\n * ```typescript\n * const shortcut = createKeyboardShortcut({\n *   default: [{\n *     key: 'B',\n *     alt: false,\n *     ctrl: true,\n *     meta: false,\n *     shift: false,\n *   }],\n *   apple: [{\n *     key: 'B',\n *     alt: false,\n *     ctrl: false,\n *     meta: true,\n *     shift: false,\n *   }],\n * })\n * ```\n */\nexport function createKeyboardShortcut<\n  TKeyboardEvent extends Pick<\n    KeyboardEvent,\n    'key' | 'code' | 'altKey' | 'ctrlKey' | 'metaKey' | 'shiftKey'\n  > = Pick<\n    KeyboardEvent,\n    'key' | 'code' | 'altKey' | 'ctrlKey' | 'metaKey' | 'shiftKey'\n  >,\n>(definition: KeyboardShortcutDefinition): KeyboardShortcut<TKeyboardEvent> {\n  if (IS_APPLE) {\n    const appleDefinition = definition.apple ?? definition.default\n    const firstDefinition = appleDefinition.at(0)\n\n    return {\n      guard: (event) =>\n        appleDefinition.some((definition) =>\n          isKeyboardShortcut(definition, event),\n        ),\n      keys: [\n        ...(firstDefinition?.meta ? [''] : []),\n        ...(firstDefinition?.ctrl ? ['Ctrl'] : []),\n        ...(firstDefinition?.alt ? ['Option'] : []),\n        ...(firstDefinition?.shift ? ['Shift'] : []),\n        ...(firstDefinition?.key !== undefined\n          ? [firstDefinition.key]\n          : firstDefinition?.code !== undefined\n            ? [firstDefinition.code]\n            : []),\n      ],\n    }\n  }\n\n  const firstDefinition = definition.default.at(0)\n\n  return {\n    guard: (event) =>\n      definition.default.some((definition) =>\n        isKeyboardShortcut(definition, event),\n      ),\n    keys: [\n      ...(firstDefinition?.meta ? ['Meta'] : []),\n      ...(firstDefinition?.ctrl ? ['Ctrl'] : []),\n      ...(firstDefinition?.alt ? ['Alt'] : []),\n      ...(firstDefinition?.shift ? ['Shift'] : []),\n      ...(firstDefinition?.key !== undefined\n        ? [firstDefinition.key]\n        : firstDefinition?.code !== undefined\n          ? [firstDefinition.code]\n          : []),\n    ],\n  }\n}\n","import {createKeyboardShortcut} from './keyboard-shortcuts'\n\n/**\n * @public\n */\nexport const bold = createKeyboardShortcut({\n  default: [\n    {\n      key: 'B',\n      alt: false,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n  ],\n  apple: [\n    {\n      key: 'B',\n      alt: false,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n  ],\n})\n\n/**\n * @public\n */\nexport const italic = createKeyboardShortcut({\n  default: [\n    {\n      key: 'I',\n      alt: false,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n  ],\n  apple: [\n    {\n      key: 'I',\n      alt: false,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n  ],\n})\n\n/**\n * @public\n */\nexport const code = createKeyboardShortcut({\n  default: [\n    {\n      key: \"'\",\n      alt: false,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n  ],\n  apple: [\n    {\n      key: \"'\",\n      alt: false,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n  ],\n})\n\n/**\n * @public\n */\nexport const underline = createKeyboardShortcut({\n  default: [\n    {\n      key: 'U',\n      alt: false,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n  ],\n  apple: [\n    {\n      key: 'U',\n      alt: false,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n  ],\n})\n\n/**\n * @public\n */\nexport const strikeThrough = createKeyboardShortcut({\n  default: [\n    {\n      key: 'X',\n      alt: false,\n      ctrl: true,\n      meta: false,\n      shift: true,\n    },\n  ],\n  apple: [\n    {\n      key: 'X',\n      alt: false,\n      ctrl: false,\n      meta: true,\n      shift: true,\n    },\n  ],\n})\n\n/**\n * @public\n */\nexport const link = createKeyboardShortcut({\n  default: [\n    {\n      key: 'K',\n      alt: false,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n  ],\n  apple: [\n    {\n      key: 'K',\n      alt: false,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n  ],\n})\n\n/**\n * @public\n */\nexport const normal = createKeyboardShortcut({\n  default: [\n    {\n      key: '0',\n      code: 'Digit0',\n      alt: true,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n    {\n      key: '0',\n      code: 'Numpad0',\n      alt: true,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n  ],\n  apple: [\n    {\n      key: '0',\n      code: 'Digit0',\n      alt: true,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n    {\n      key: '0',\n      code: 'Numpad0',\n      alt: true,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n  ],\n})\n\n/**\n * @public\n */\nexport const h1 = createKeyboardShortcut({\n  default: [\n    {\n      key: '1',\n      code: 'Digit1',\n      alt: true,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n    {\n      key: '1',\n      code: 'Numpad1',\n      alt: true,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n  ],\n  apple: [\n    {\n      key: '1',\n      code: 'Digit1',\n      alt: true,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n    {\n      key: '1',\n      code: 'Numpad1',\n      alt: true,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n  ],\n})\n\n/**\n * @public\n */\nexport const h2 = createKeyboardShortcut({\n  default: [\n    {\n      key: '2',\n      code: 'Digit2',\n      alt: true,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n    {\n      key: '2',\n      code: 'Numpad2',\n      alt: true,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n  ],\n  apple: [\n    {\n      key: '2',\n      code: 'Digit2',\n      alt: true,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n    {\n      key: '2',\n      code: 'Numpad2',\n      alt: true,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n  ],\n})\n\n/**\n * @public\n */\nexport const h3 = createKeyboardShortcut({\n  default: [\n    {\n      key: '3',\n      code: 'Digit3',\n      alt: true,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n    {\n      key: '3',\n      code: 'Numpad3',\n      alt: true,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n  ],\n  apple: [\n    {\n      key: '3',\n      code: 'Digit3',\n      alt: true,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n    {\n      key: '3',\n      code: 'Numpad3',\n      alt: true,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n  ],\n})\n\n/**\n * @public\n */\nexport const h4 = createKeyboardShortcut({\n  default: [\n    {\n      key: '4',\n      code: 'Digit4',\n      alt: true,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n    {\n      key: '4',\n      code: 'Numpad4',\n      alt: true,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n  ],\n  apple: [\n    {\n      key: '4',\n      code: 'Digit4',\n      alt: true,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n    {\n      key: '4',\n      code: 'Numpad4',\n      alt: true,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n  ],\n})\n\n/**\n * @public\n */\nexport const h5 = createKeyboardShortcut({\n  default: [\n    {\n      key: '5',\n      code: 'Digit5',\n      alt: true,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n    {\n      key: '5',\n      code: 'Numpad5',\n      alt: true,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n  ],\n  apple: [\n    {\n      key: '5',\n      code: 'Digit5',\n      alt: true,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n    {\n      key: '5',\n      code: 'Numpad5',\n      alt: true,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n  ],\n})\n\n/**\n * @public\n */\nexport const h6 = createKeyboardShortcut({\n  default: [\n    {\n      key: '6',\n      code: 'Digit6',\n      alt: true,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n    {\n      key: '6',\n      code: 'Numpad6',\n      alt: true,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n  ],\n  apple: [\n    {\n      key: '6',\n      code: 'Digit6',\n      alt: true,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n    {\n      key: '6',\n      code: 'Numpad6',\n      alt: true,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n  ],\n})\n\n/**\n * @public\n */\nexport const blockquote = createKeyboardShortcut({\n  default: [\n    {\n      key: 'Q',\n      alt: false,\n      ctrl: true,\n      meta: false,\n      shift: true,\n    },\n  ],\n})\n\n/**\n * @public\n */\nexport const undo = createKeyboardShortcut({\n  default: [\n    {\n      key: 'Z',\n      alt: false,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n  ],\n  apple: [\n    {\n      key: 'Z',\n      alt: false,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n  ],\n})\n\n/**\n * @public\n */\nexport const redo = createKeyboardShortcut({\n  default: [\n    {\n      key: 'Y',\n      alt: false,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n    {\n      key: 'Z',\n      alt: false,\n      ctrl: true,\n      meta: false,\n      shift: true,\n    },\n  ],\n  apple: [\n    {\n      key: 'Z',\n      alt: false,\n      ctrl: false,\n      meta: true,\n      shift: true,\n    },\n  ],\n})\n"],"names":["firstDefinition","definition"],"mappings":"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"}},
    {"offset": {"line": 4660, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@portabletext/plugin-one-line/dist/index.js","sources":["file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/plugin-one-line/src/plugin.one-line.tsx"],"sourcesContent":["import {useEditor} from '@portabletext/editor'\nimport {defineBehavior, raise} from '@portabletext/editor/behaviors'\nimport * as selectors from '@portabletext/editor/selectors'\nimport * as utils from '@portabletext/editor/utils'\nimport {useEffect} from 'react'\n\nconst oneLineBehaviors = [\n  /**\n   * Hitting Enter on an expanded selection should just delete that selection\n   * without causing a line break.\n   */\n  defineBehavior({\n    on: 'insert.break',\n    guard: ({snapshot}) =>\n      snapshot.context.selection && selectors.isSelectionExpanded(snapshot)\n        ? {selection: snapshot.context.selection}\n        : false,\n    actions: [(_, {selection}) => [raise({type: 'delete', at: selection})]],\n  }),\n  /**\n   * All other cases of `insert.break` should be aborted.\n   */\n  defineBehavior({\n    on: 'insert.break',\n    actions: [],\n  }),\n  /**\n   * `insert.block` `before` or `after` is not allowed in a one-line editor.\n   */\n  defineBehavior({\n    on: 'insert.block',\n    guard: ({event}) =>\n      event.placement === 'before' || event.placement === 'after',\n    actions: [],\n  }),\n  /**\n   * An ordinary `insert.block` is acceptable if it's a text block. In that\n   * case it will get merged into the existing text block.\n   */\n  defineBehavior({\n    on: 'insert.block',\n    guard: ({snapshot, event}) => {\n      const focusTextBlock = selectors.getFocusTextBlock(snapshot)\n\n      if (\n        !focusTextBlock ||\n        !utils.isTextBlock(snapshot.context, event.block)\n      ) {\n        return false\n      }\n\n      return event.placement !== 'auto' || event.select !== 'end'\n    },\n    actions: [\n      ({event}) => [\n        raise({\n          type: 'insert.block',\n          block: event.block,\n          placement: 'auto',\n          select: 'end',\n        }),\n      ],\n    ],\n  }),\n  /**\n   * Fallback Behavior to avoid `insert.block` in case the Behaviors above all\n   * end up with a falsy guard.\n   */\n  defineBehavior({\n    on: 'insert.block',\n    guard: ({snapshot, event}) => {\n      const focusTextBlock = selectors.getFocusTextBlock(snapshot)\n\n      if (!focusTextBlock) {\n        return true\n      }\n\n      return !utils.isTextBlock(snapshot.context, event.block)\n    },\n    actions: [],\n  }),\n  /**\n   * If multiple blocks are inserted, then the non-text blocks are filtered out\n   * and the text blocks are merged into one block\n   */\n  defineBehavior({\n    on: 'insert.blocks',\n    guard: ({snapshot, event}) => {\n      const textBlocks = event.blocks.filter((block) =>\n        utils.isTextBlock(snapshot.context, block),\n      )\n\n      if (textBlocks.length === 0) {\n        return false\n      }\n\n      return textBlocks.reduce((targetBlock, incomingBlock) => {\n        return utils.mergeTextBlocks({\n          context: snapshot.context,\n          targetBlock,\n          incomingBlock,\n        })\n      })\n    },\n    actions: [\n      // `insert.block` is raised so the Behavior above can handle the\n      // insertion\n      (_, block) => [raise({type: 'insert.block', block, placement: 'auto'})],\n    ],\n  }),\n  /**\n   * Fallback Behavior to avoid `insert.blocks` in case the Behavior above\n   * ends up with a falsy guard.\n   */\n  defineBehavior({\n    on: 'insert.blocks',\n    actions: [],\n  }),\n]\n\n/**\n * @public\n * Restrict the editor to one line. The plugin takes care of blocking\n * `insert.break` events and smart handling of other `insert.*` events.\n *\n * Place it with as high priority as possible to make sure other plugins don't\n * overwrite `insert.*` events before this plugin gets a chance to do so.\n */\nexport function OneLinePlugin() {\n  const editor = useEditor()\n\n  useEffect(() => {\n    const unregisterBehaviors = oneLineBehaviors.map((behavior) =>\n      editor.registerBehavior({behavior}),\n    )\n\n    return () => {\n      for (const unregisterBehavior of unregisterBehaviors) {\n        unregisterBehavior()\n      }\n    }\n  }, [editor])\n\n  return null\n}\n"],"names":["oneLineBehaviors","defineBehavior","on","guard","snapshot","context","selection","selectors","isSelectionExpanded","actions","_","raise","type","at","event","placement","getFocusTextBlock","utils","isTextBlock","block","select","textBlocks","blocks","filter","length","reduce","targetBlock","incomingBlock","mergeTextBlocks","OneLinePlugin","$","_c","editor","useEditor","t0","t1","unregisterBehaviors","map","behavior","registerBehavior","unregisterBehavior","useEffect"],"mappings":"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"}},
    {"offset": {"line": 4786, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@portabletext/plugin-character-pair-decorator/dist/index.js","sources":["file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/plugin-character-pair-decorator/src/regex.character-pair.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/plugin-character-pair-decorator/src/behavior.character-pair-decorator.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/plugin-character-pair-decorator/src/plugin.character-pair-decorator.ts"],"sourcesContent":["export function createCharacterPairRegex(char: string, amount: number) {\n  // Negative lookbehind: Ensures that the matched sequence is not preceded by the same character\n  const prePrefix = `(?<!\\\\${char})`\n\n  // Repeats the character `amount` times\n  const prefix = `\\\\${char}`.repeat(Math.max(amount, 1))\n\n  // Negative lookahead: Ensures that the opening pair (**, *, etc.) is not followed by a space\n  const postPrefix = `(?!\\\\s)`\n\n  // Captures the content inside the pair\n  const content = `([^${char}\\\\n]+?)`\n\n  // Negative lookbehind: Ensures that the content is not followed by a space\n  const preSuffix = `(?<!\\\\s)`\n\n  // Repeats the character `amount` times\n  const suffix = `\\\\${char}`.repeat(Math.max(amount, 1))\n\n  // Negative lookahead: Ensures that the matched sequence is not followed by the same character\n  const postSuffix = `(?!\\\\${char})`\n\n  return `${prePrefix}${prefix}${postPrefix}${content}${preSuffix}${suffix}${postSuffix}`\n}\n","import type {BlockOffset, EditorContext} from '@portabletext/editor'\nimport {\n  defineBehavior,\n  effect,\n  forward,\n  raise,\n} from '@portabletext/editor/behaviors'\nimport * as selectors from '@portabletext/editor/selectors'\nimport * as utils from '@portabletext/editor/utils'\nimport {createCharacterPairRegex} from './regex.character-pair'\n\nexport function createCharacterPairDecoratorBehavior(config: {\n  decorator: ({\n    context,\n    schema,\n  }: {\n    context: Pick<EditorContext, 'schema'>\n    /**\n     * @deprecated Use `context.schema` instead\n     */\n    schema: EditorContext['schema']\n  }) => string | undefined\n  pair: {char: string; amount: number}\n  onDecorate: (offset: BlockOffset) => void\n}) {\n  if (config.pair.amount < 1) {\n    console.warn(\n      `The amount of characters in the pair should be greater than 0`,\n    )\n  }\n\n  const pairRegex = createCharacterPairRegex(\n    config.pair.char,\n    config.pair.amount,\n  )\n  const regEx = new RegExp(`(${pairRegex})$`)\n\n  return defineBehavior({\n    on: 'insert.text',\n    guard: ({snapshot, event}) => {\n      if (config.pair.amount < 1) {\n        return false\n      }\n\n      const decorator = config.decorator({\n        context: {schema: snapshot.context.schema},\n        schema: snapshot.context.schema,\n      })\n\n      if (decorator === undefined) {\n        return false\n      }\n\n      const focusTextBlock = selectors.getFocusTextBlock(snapshot)\n      const selectionStartPoint = selectors.getSelectionStartPoint(snapshot)\n      const selectionStartOffset = selectionStartPoint\n        ? utils.spanSelectionPointToBlockOffset({\n            context: snapshot.context,\n            selectionPoint: selectionStartPoint,\n          })\n        : undefined\n\n      if (!focusTextBlock || !selectionStartOffset) {\n        return false\n      }\n\n      const textBefore = selectors.getBlockTextBefore(snapshot)\n      const newText = `${textBefore}${event.text}`\n      const textToDecorate = newText.match(regEx)?.at(0)\n\n      if (textToDecorate === undefined) {\n        return false\n      }\n\n      const prefixOffsets = {\n        anchor: {\n          path: focusTextBlock.path,\n          // Example: \"foo **bar**\".length - \"**bar**\".length = 4\n          offset: newText.length - textToDecorate.length,\n        },\n        focus: {\n          path: focusTextBlock.path,\n          // Example: \"foo **bar**\".length - \"**bar**\".length + \"*\".length * 2 = 6\n          offset:\n            newText.length -\n            textToDecorate.length +\n            config.pair.char.length * config.pair.amount,\n        },\n      }\n\n      const suffixOffsets = {\n        anchor: {\n          path: focusTextBlock.path,\n          // Example: \"foo **bar*|\" (10) + \"*\".length - 2 = 9\n          offset:\n            selectionStartOffset.offset +\n            event.text.length -\n            config.pair.char.length * config.pair.amount,\n        },\n        focus: {\n          path: focusTextBlock.path,\n          // Example: \"foo **bar*|\" (10) + \"*\".length = 11\n          offset: selectionStartOffset.offset + event.text.length,\n        },\n      }\n\n      // If the prefix is more than one character, then we need to check if\n      // there is an inline object inside it\n      if (prefixOffsets.focus.offset - prefixOffsets.anchor.offset > 1) {\n        const prefixSelection = utils.blockOffsetsToSelection({\n          context: snapshot.context,\n          offsets: prefixOffsets,\n        })\n        const inlineObjectBeforePrefixFocus = selectors.getPreviousInlineObject(\n          {\n            ...snapshot,\n            context: {\n              ...snapshot.context,\n              selection: prefixSelection\n                ? {\n                    anchor: prefixSelection.focus,\n                    focus: prefixSelection.focus,\n                  }\n                : null,\n            },\n          },\n        )\n        const inlineObjectBeforePrefixFocusOffset =\n          inlineObjectBeforePrefixFocus\n            ? utils.childSelectionPointToBlockOffset({\n                context: snapshot.context,\n                selectionPoint: {\n                  path: inlineObjectBeforePrefixFocus.path,\n                  offset: 0,\n                },\n              })\n            : undefined\n\n        if (\n          inlineObjectBeforePrefixFocusOffset &&\n          inlineObjectBeforePrefixFocusOffset.offset >\n            prefixOffsets.anchor.offset &&\n          inlineObjectBeforePrefixFocusOffset.offset <\n            prefixOffsets.focus.offset\n        ) {\n          return false\n        }\n      }\n\n      // If the suffix is more than one character, then we need to check if\n      // there is an inline object inside it\n      if (suffixOffsets.focus.offset - suffixOffsets.anchor.offset > 1) {\n        const previousInlineObject = selectors.getPreviousInlineObject(snapshot)\n        const previousInlineObjectOffset = previousInlineObject\n          ? utils.childSelectionPointToBlockOffset({\n              context: snapshot.context,\n              selectionPoint: {\n                path: previousInlineObject.path,\n                offset: 0,\n              },\n            })\n          : undefined\n\n        if (\n          previousInlineObjectOffset &&\n          previousInlineObjectOffset.offset > suffixOffsets.anchor.offset &&\n          previousInlineObjectOffset.offset < suffixOffsets.focus.offset\n        ) {\n          return false\n        }\n      }\n\n      return {\n        prefixOffsets,\n        suffixOffsets,\n        decorator,\n      }\n    },\n    actions: [\n      // Insert the text as usual in its own undo step\n      ({event}) => [forward(event)],\n      (_, {prefixOffsets, suffixOffsets, decorator}) => [\n        // Decorate the text between the prefix and suffix\n        raise({\n          type: 'decorator.add',\n          decorator,\n          at: {\n            anchor: prefixOffsets.focus,\n            focus: suffixOffsets.anchor,\n          },\n        }),\n        // Delete the suffix\n        raise({\n          type: 'delete.text',\n          at: suffixOffsets,\n        }),\n        // Delete the prefix\n        raise({\n          type: 'delete.text',\n          at: prefixOffsets,\n        }),\n        // Toggle the decorator off so the next inserted text isn't emphasized\n        raise({\n          type: 'decorator.remove',\n          decorator,\n        }),\n        effect(() => {\n          config.onDecorate({\n            ...suffixOffsets.anchor,\n            offset:\n              suffixOffsets.anchor.offset -\n              (prefixOffsets.focus.offset - prefixOffsets.anchor.offset),\n          })\n        }),\n      ],\n    ],\n  })\n}\n","import type {BlockOffset, Editor, EditorContext} from '@portabletext/editor'\nimport {useEditor} from '@portabletext/editor'\nimport {\n  defineBehavior,\n  effect,\n  forward,\n  raise,\n} from '@portabletext/editor/behaviors'\nimport * as utils from '@portabletext/editor/utils'\nimport {useActorRef} from '@xstate/react'\nimport {isDeepEqual} from 'remeda'\nimport {\n  assign,\n  fromCallback,\n  setup,\n  type AnyEventObject,\n  type CallbackLogicFunction,\n} from 'xstate'\nimport {createCharacterPairDecoratorBehavior} from './behavior.character-pair-decorator'\n\n/**\n * @public\n */\nexport function CharacterPairDecoratorPlugin(props: {\n  decorator: ({\n    context,\n    schema,\n  }: {\n    context: Pick<EditorContext, 'schema'>\n    /**\n     * @deprecated Use `context.schema` instead\n     */\n    schema: EditorContext['schema']\n  }) => string | undefined\n  pair: {char: string; amount: number}\n}) {\n  const editor = useEditor()\n\n  useActorRef(decoratorPairMachine, {\n    input: {\n      editor,\n      decorator: props.decorator,\n      pair: props.pair,\n    },\n  })\n\n  return null\n}\n\ntype DecoratorPairEvent =\n  | {\n      type: 'decorator.add'\n      blockOffset: BlockOffset\n    }\n  | {\n      type: 'selection'\n      blockOffsets?: {\n        anchor: BlockOffset\n        focus: BlockOffset\n      }\n    }\n  | {\n      type: 'delete.backward'\n    }\n\nconst decorateListener: CallbackLogicFunction<\n  AnyEventObject,\n  DecoratorPairEvent,\n  {\n    decorator: ({\n      context,\n      schema,\n    }: {\n      context: Pick<EditorContext, 'schema'>\n      /**\n       * @deprecated Use `context.schema` instead\n       */\n      schema: EditorContext['schema']\n    }) => string | undefined\n    editor: Editor\n    pair: {char: string; amount: number}\n  }\n> = ({sendBack, input}) => {\n  const unregister = input.editor.registerBehavior({\n    behavior: createCharacterPairDecoratorBehavior({\n      decorator: input.decorator,\n      pair: input.pair,\n      onDecorate: (offset) => {\n        sendBack({type: 'decorator.add', blockOffset: offset})\n      },\n    }),\n  })\n\n  return unregister\n}\n\nconst selectionListenerCallback: CallbackLogicFunction<\n  AnyEventObject,\n  DecoratorPairEvent,\n  {editor: Editor}\n> = ({sendBack, input}) => {\n  const unregister = input.editor.registerBehavior({\n    behavior: defineBehavior({\n      on: 'select',\n      guard: ({snapshot, event}) => {\n        if (!event.at) {\n          return {blockOffsets: undefined}\n        }\n\n        const anchor = utils.spanSelectionPointToBlockOffset({\n          context: snapshot.context,\n          selectionPoint: event.at.anchor,\n        })\n        const focus = utils.spanSelectionPointToBlockOffset({\n          context: snapshot.context,\n          selectionPoint: event.at.focus,\n        })\n\n        if (!anchor || !focus) {\n          return {blockOffsets: undefined}\n        }\n\n        return {\n          blockOffsets: {\n            anchor,\n            focus,\n          },\n        }\n      },\n      actions: [\n        ({event}, {blockOffsets}) => [\n          {\n            type: 'effect',\n            effect: () => {\n              sendBack({type: 'selection', blockOffsets})\n            },\n          },\n          forward(event),\n        ],\n      ],\n    }),\n  })\n\n  return unregister\n}\n\nconst deleteBackwardListenerCallback: CallbackLogicFunction<\n  AnyEventObject,\n  DecoratorPairEvent,\n  {editor: Editor}\n> = ({sendBack, input}) => {\n  const unregister = input.editor.registerBehavior({\n    behavior: defineBehavior({\n      on: 'delete.backward',\n      actions: [\n        () => [\n          raise({\n            type: 'history.undo',\n          }),\n          effect(() => {\n            sendBack({type: 'delete.backward'})\n          }),\n        ],\n      ],\n    }),\n  })\n\n  return unregister\n}\n\nconst decoratorPairMachine = setup({\n  types: {\n    context: {} as {\n      decorator: ({\n        context,\n        schema,\n      }: {\n        context: Pick<EditorContext, 'schema'>\n        /**\n         * @deprecated Use `context.schema` instead\n         */\n        schema: EditorContext['schema']\n      }) => string | undefined\n      editor: Editor\n      offsetAfterDecorator?: BlockOffset\n      pair: {char: string; amount: number}\n    },\n    input: {} as {\n      decorator: ({\n        context,\n        schema,\n      }: {\n        context: Pick<EditorContext, 'schema'>\n        /**\n         * @deprecated Use `context.schema` instead\n         */\n        schema: EditorContext['schema']\n      }) => string | undefined\n      editor: Editor\n      pair: {char: string; amount: number}\n    },\n    events: {} as DecoratorPairEvent,\n  },\n  actors: {\n    'decorate listener': fromCallback(decorateListener),\n    'delete.backward listener': fromCallback(deleteBackwardListenerCallback),\n    'selection listener': fromCallback(selectionListenerCallback),\n  },\n}).createMachine({\n  id: 'decorator pair',\n  context: ({input}) => ({\n    decorator: input.decorator,\n    editor: input.editor,\n    pair: input.pair,\n  }),\n  initial: 'idle',\n  states: {\n    'idle': {\n      invoke: [\n        {\n          src: 'decorate listener',\n          input: ({context}) => ({\n            decorator: context.decorator,\n            editor: context.editor,\n            pair: context.pair,\n          }),\n        },\n      ],\n      on: {\n        'decorator.add': {\n          target: 'decorator added',\n          actions: assign({\n            offsetAfterDecorator: ({event}) => event.blockOffset,\n          }),\n        },\n      },\n    },\n    'decorator added': {\n      exit: [\n        assign({\n          offsetAfterDecorator: undefined,\n        }),\n      ],\n      invoke: [\n        {\n          src: 'selection listener',\n          input: ({context}) => ({editor: context.editor}),\n        },\n        {\n          src: 'delete.backward listener',\n          input: ({context}) => ({editor: context.editor}),\n        },\n      ],\n      on: {\n        'selection': {\n          target: 'idle',\n          guard: ({context, event}) => {\n            const selectionChanged = !isDeepEqual(\n              {\n                anchor: context.offsetAfterDecorator,\n                focus: context.offsetAfterDecorator,\n              },\n              event.blockOffsets,\n            )\n\n            return selectionChanged\n          },\n        },\n        'delete.backward': {\n          target: 'idle',\n        },\n      },\n    },\n  },\n})\n"],"names":["createCharacterPairRegex","char","amount","prePrefix","prefix","repeat","Math","max","postPrefix","content","preSuffix","suffix","postSuffix","createCharacterPairDecoratorBehavior","config","pair","console","warn","pairRegex","regEx","RegExp","defineBehavior","on","guard","snapshot","event","decorator","context","schema","undefined","focusTextBlock","selectors","getFocusTextBlock","selectionStartPoint","getSelectionStartPoint","selectionStartOffset","utils","spanSelectionPointToBlockOffset","selectionPoint","newText","getBlockTextBefore","text","textToDecorate","match","at","prefixOffsets","anchor","path","offset","length","focus","suffixOffsets","prefixSelection","blockOffsetsToSelection","offsets","inlineObjectBeforePrefixFocus","getPreviousInlineObject","selection","inlineObjectBeforePrefixFocusOffset","childSelectionPointToBlockOffset","previousInlineObject","previousInlineObjectOffset","actions","forward","_","raise","type","effect","onDecorate","CharacterPairDecoratorPlugin","props","$","_c","editor","useEditor","t0","input","useActorRef","decoratorPairMachine","decorateListener","sendBack","registerBehavior","behavior","blockOffset","selectionListenerCallback","blockOffsets","deleteBackwardListenerCallback","setup","types","events","actors","fromCallback","createMachine","id","initial","states","invoke","src","target","assign","offsetAfterDecorator","exit","isDeepEqual"],"mappings":"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"}},
    {"offset": {"line": 5093, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@portabletext/plugin-input-rule/dist/index.js","sources":["file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/plugin-input-rule/src/input-rule.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/plugin-input-rule/src/input-rule-match-location.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/plugin-input-rule/src/plugin.input-rule.tsx","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/plugin-input-rule/src/text-transform-rule.ts"],"sourcesContent":["import type {BlockPath, PortableTextBlock} from '@portabletext/editor'\nimport type {\n  BehaviorActionSet,\n  BehaviorGuard,\n} from '@portabletext/editor/behaviors'\nimport type {InputRuleMatchLocation} from './input-rule-match-location'\n\n/**\n * Match found in the text after the insertion\n * @alpha\n */\nexport type InputRuleMatch = InputRuleMatchLocation & {\n  groupMatches: Array<InputRuleMatchLocation>\n}\n\n/**\n * @alpha\n */\nexport type InputRuleEvent = {\n  type: 'custom.input rule'\n  /**\n   * Matches found by the input rule\n   */\n  matches: Array<InputRuleMatch>\n  /**\n   * The text before the insertion\n   */\n  textBefore: string\n  /**\n   * The text is destined to be inserted\n   */\n  textInserted: string\n  /**\n   * The block where the insertion takes place\n   */\n  focusBlock: {\n    path: BlockPath\n    node: PortableTextBlock\n  }\n}\n\n/**\n * @alpha\n */\nexport type InputRuleGuard<TGuardResponse = true> = BehaviorGuard<\n  InputRuleEvent,\n  TGuardResponse\n>\n\n/**\n * @alpha\n */\nexport type InputRule<TGuardResponse = true> = {\n  on: RegExp\n  guard?: InputRuleGuard<TGuardResponse>\n  actions: Array<BehaviorActionSet<InputRuleEvent, TGuardResponse>>\n}\n\n/**\n * @alpha\n */\nexport function defineInputRule<TGuardResponse = true>(\n  config: InputRule<TGuardResponse>,\n): InputRule<TGuardResponse> {\n  return config\n}\n","import type {\n  BlockOffset,\n  BlockPath,\n  EditorSelection,\n  EditorSnapshot,\n} from '@portabletext/editor'\nimport {\n  getNextInlineObjects,\n  getPreviousInlineObjects,\n} from '@portabletext/editor/selectors'\nimport {blockOffsetToSpanSelectionPoint} from '@portabletext/editor/utils'\n\nexport type InputRuleMatchLocation = {\n  /**\n   * The matched text\n   */\n  text: string\n  /**\n   * Estimated selection of where in the original text the match is located.\n   * The selection is estimated since the match is found in the text after\n   * insertion.\n   */\n  selection: NonNullable<EditorSelection>\n  /**\n   * Block offsets of the match in the text after the insertion\n   */\n  targetOffsets: {\n    anchor: BlockOffset\n    focus: BlockOffset\n    backward: boolean\n  }\n}\n\nexport function getInputRuleMatchLocation({\n  match,\n  adjustIndexBy,\n  snapshot,\n  focusBlock,\n  originalTextBefore,\n}: {\n  match: [string, number, number]\n  adjustIndexBy: number\n  snapshot: EditorSnapshot\n  focusBlock: {\n    path: BlockPath\n  }\n  originalTextBefore: string\n}): InputRuleMatchLocation | undefined {\n  const [text, start, end] = match\n  const adjustedIndex = start + adjustIndexBy\n\n  const targetOffsets = {\n    anchor: {\n      path: focusBlock.path,\n      offset: adjustedIndex,\n    },\n    focus: {\n      path: focusBlock.path,\n      offset: adjustedIndex + end - start,\n    },\n    backward: false,\n  }\n  const normalizedOffsets = {\n    anchor: {\n      path: focusBlock.path,\n      offset: Math.min(targetOffsets.anchor.offset, originalTextBefore.length),\n    },\n    focus: {\n      path: focusBlock.path,\n      offset: Math.min(targetOffsets.focus.offset, originalTextBefore.length),\n    },\n    backward: false,\n  }\n\n  const anchorBackwards = blockOffsetToSpanSelectionPoint({\n    context: snapshot.context,\n    blockOffset: normalizedOffsets.anchor,\n    direction: 'backward',\n  })\n  const focusForwards = blockOffsetToSpanSelectionPoint({\n    context: snapshot.context,\n    blockOffset: normalizedOffsets.focus,\n    direction: 'forward',\n  })\n\n  if (!anchorBackwards || !focusForwards) {\n    return undefined\n  }\n\n  const selection = {\n    anchor: anchorBackwards,\n    focus: focusForwards,\n  }\n\n  const inlineObjectsAfterMatch = getNextInlineObjects({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: {\n        anchor: selection.anchor,\n        focus: selection.anchor,\n      },\n    },\n  })\n  const inlineObjectsBefore = getPreviousInlineObjects(snapshot)\n\n  if (\n    inlineObjectsAfterMatch.some((inlineObjectAfter) =>\n      inlineObjectsBefore.some(\n        (inlineObjectBefore) =>\n          inlineObjectAfter.node._key === inlineObjectBefore.node._key,\n      ),\n    )\n  ) {\n    return undefined\n  }\n\n  return {\n    text,\n    selection,\n    targetOffsets,\n  }\n}\n","import {\n  useEditor,\n  type BlockOffset,\n  type Editor,\n  type EditorSelection,\n} from '@portabletext/editor'\nimport {\n  defineBehavior,\n  effect,\n  forward,\n  raise,\n  type BehaviorAction,\n} from '@portabletext/editor/behaviors'\nimport {\n  getBlockOffsets,\n  getBlockTextBefore,\n  getFocusBlock,\n} from '@portabletext/editor/selectors'\nimport {\n  isEqualSelections,\n  isSelectionCollapsed,\n} from '@portabletext/editor/utils'\nimport {useActorRef} from '@xstate/react'\nimport {\n  fromCallback,\n  setup,\n  type AnyEventObject,\n  type CallbackLogicFunction,\n} from 'xstate'\nimport type {InputRule, InputRuleMatch} from './input-rule'\nimport {getInputRuleMatchLocation} from './input-rule-match-location'\n\n/**\n * @alpha\n */\nexport function defineInputRuleBehavior(config: {\n  rules: Array<InputRule<any>>\n  onApply?: ({\n    endOffsets,\n    endSelection,\n  }: {\n    endOffsets: {start: BlockOffset; end: BlockOffset} | undefined\n    endSelection: EditorSelection\n  }) => void\n}) {\n  return defineBehavior({\n    on: 'insert.text',\n    guard: ({snapshot, event, dom}) => {\n      if (\n        !snapshot.context.selection ||\n        !isSelectionCollapsed(snapshot.context.selection)\n      ) {\n        return false\n      }\n\n      const focusBlock = getFocusBlock(snapshot)\n\n      if (!focusBlock) {\n        return false\n      }\n\n      const originalTextBefore = getBlockTextBefore(snapshot)\n      let textBefore = originalTextBefore\n      const originalNewText = textBefore + event.text\n      let newText = originalNewText\n\n      const foundMatches: Array<InputRuleMatch['groupMatches'][number]> = []\n      const foundActions: Array<BehaviorAction> = []\n\n      for (const rule of config.rules) {\n        const matcher = new RegExp(rule.on.source, 'gd')\n\n        while (true) {\n          // Find matches in the text after the insertion\n          const ruleMatches = [...newText.matchAll(matcher)].flatMap(\n            (regExpMatch) => {\n              if (regExpMatch.indices === undefined) {\n                return []\n              }\n\n              const match = regExpMatch.indices.at(0)\n\n              if (!match) {\n                return []\n              }\n\n              const matchLocation = getInputRuleMatchLocation({\n                match: [regExpMatch.at(0) ?? '', ...match],\n                adjustIndexBy: originalNewText.length - newText.length,\n                snapshot,\n                focusBlock,\n                originalTextBefore,\n              })\n\n              if (!matchLocation) {\n                return []\n              }\n\n              const existsInTextBefore =\n                matchLocation.targetOffsets.focus.offset <=\n                originalTextBefore.length\n\n              // Ignore if this match occurs in the text before the insertion\n              if (existsInTextBefore) {\n                return []\n              }\n\n              const alreadyFound = foundMatches.some(\n                (foundMatch) =>\n                  foundMatch.targetOffsets.anchor.offset ===\n                  matchLocation.targetOffsets.anchor.offset,\n              )\n\n              // Ignore if this match has already been found\n              if (alreadyFound) {\n                return []\n              }\n\n              const groupMatches =\n                regExpMatch.indices.length > 1\n                  ? regExpMatch.indices\n                      .slice(1)\n                      .filter((indices) => indices !== undefined)\n                  : []\n\n              const ruleMatch = {\n                text: matchLocation.text,\n                selection: matchLocation.selection,\n                targetOffsets: matchLocation.targetOffsets,\n                groupMatches: groupMatches.flatMap((match, index) => {\n                  const text = regExpMatch.at(index + 1) ?? ''\n                  const groupMatchLocation = getInputRuleMatchLocation({\n                    match: [text, ...match],\n                    adjustIndexBy: originalNewText.length - newText.length,\n                    snapshot,\n                    focusBlock,\n                    originalTextBefore,\n                  })\n\n                  if (!groupMatchLocation) {\n                    return []\n                  }\n\n                  return groupMatchLocation\n                }),\n              }\n\n              return [ruleMatch]\n            },\n          )\n\n          if (ruleMatches.length > 0) {\n            const guardResult =\n              rule.guard?.({\n                snapshot,\n                event: {\n                  type: 'custom.input rule',\n                  matches: ruleMatches,\n                  focusBlock,\n                  textBefore: originalTextBefore,\n                  textInserted: event.text,\n                },\n                dom,\n              }) ?? true\n\n            if (!guardResult) {\n              break\n            }\n\n            const actionSets = rule.actions.map((action) =>\n              action(\n                {\n                  snapshot,\n                  event: {\n                    type: 'custom.input rule',\n                    matches: ruleMatches,\n                    focusBlock,\n                    textBefore: originalTextBefore,\n                    textInserted: event.text,\n                  },\n                  dom,\n                },\n                guardResult,\n              ),\n            )\n\n            for (const actionSet of actionSets) {\n              for (const action of actionSet) {\n                foundActions.push(action)\n              }\n            }\n\n            const matches = ruleMatches.flatMap((match) =>\n              match.groupMatches.length === 0 ? [match] : match.groupMatches,\n            )\n\n            for (const match of matches) {\n              // Remember each match and adjust `textBefore` and `newText` so\n              // no subsequent matches can overlap with this one\n              foundMatches.push(match)\n              textBefore = newText.slice(\n                0,\n                match.targetOffsets.focus.offset ?? 0,\n              )\n              newText = originalNewText.slice(\n                match.targetOffsets.focus.offset ?? 0,\n              )\n            }\n          } else {\n            // If no match was found, break out of the loop to try the next\n            // rule\n            break\n          }\n        }\n      }\n\n      if (foundActions.length === 0) {\n        return false\n      }\n\n      return {actions: foundActions}\n    },\n    actions: [\n      ({event}) => [forward(event)],\n      (_, {actions}) => actions,\n      ({snapshot}) => [\n        effect(() => {\n          const blockOffsets = getBlockOffsets(snapshot)\n\n          config.onApply?.({\n            endOffsets: blockOffsets,\n            endSelection: snapshot.context.selection,\n          })\n        }),\n      ],\n    ],\n  })\n}\n\ntype InputRulePluginProps = {\n  rules: Array<InputRule<any>>\n}\n\n/**\n * Turn an array of `InputRule`s into a Behavior that can be used to apply the\n * rules to the editor.\n *\n * The plugin handles undo/redo out of the box including smart undo with\n * Backspace.\n *\n * @example\n * ```tsx\n * <InputRulePlugin rules={smartQuotesRules} />\n * ```\n *\n * @alpha\n */\nexport function InputRulePlugin(props: InputRulePluginProps) {\n  const editor = useEditor()\n\n  useActorRef(inputRuleMachine, {\n    input: {editor, rules: props.rules},\n  })\n\n  return null\n}\n\ntype InputRuleMachineEvent =\n  | {\n      type: 'input rule raised'\n      endOffsets: {start: BlockOffset; end: BlockOffset} | undefined\n      endSelection: EditorSelection\n    }\n  | {type: 'history.undo raised'}\n  | {\n      type: 'selection changed'\n      blockOffsets: {start: BlockOffset; end: BlockOffset} | undefined\n      selection: EditorSelection\n    }\n\nconst inputRuleListenerCallback: CallbackLogicFunction<\n  AnyEventObject,\n  InputRuleMachineEvent,\n  {\n    editor: Editor\n    rules: Array<InputRule>\n  }\n> = ({input, sendBack}) => {\n  const unregister = input.editor.registerBehavior({\n    behavior: defineInputRuleBehavior({\n      rules: input.rules,\n      onApply: ({endOffsets, endSelection}) => {\n        sendBack({type: 'input rule raised', endOffsets, endSelection})\n      },\n    }),\n  })\n\n  return () => {\n    unregister()\n  }\n}\n\nconst deleteBackwardListenerCallback: CallbackLogicFunction<\n  AnyEventObject,\n  InputRuleMachineEvent,\n  {editor: Editor}\n> = ({input, sendBack}) => {\n  return input.editor.registerBehavior({\n    behavior: defineBehavior({\n      on: 'delete.backward',\n      actions: [\n        () => [\n          raise({type: 'history.undo'}),\n          effect(() => {\n            sendBack({type: 'history.undo raised'})\n          }),\n        ],\n      ],\n    }),\n  })\n}\n\nconst selectionListenerCallback: CallbackLogicFunction<\n  AnyEventObject,\n  InputRuleMachineEvent,\n  {editor: Editor}\n> = ({sendBack, input}) => {\n  // Listen for the emitted 'selection' event which fires after ANY cursor\n  // movement (typing, clicking, pasting, etc.) - not just explicit 'select'\n  // behavior events.\n  const subscription = input.editor.on('selection', (event) => {\n    const blockOffsets = getBlockOffsets({\n      ...input.editor.getSnapshot(),\n      context: {\n        ...input.editor.getSnapshot().context,\n        selection: event.selection,\n      },\n    })\n\n    sendBack({\n      type: 'selection changed',\n      blockOffsets,\n      selection: event.selection,\n    })\n  })\n\n  return () => subscription.unsubscribe()\n}\n\nconst inputRuleSetup = setup({\n  types: {\n    context: {} as {\n      editor: Editor\n      rules: Array<InputRule>\n      endOffsets: {start: BlockOffset; end: BlockOffset} | undefined\n      endSelection: EditorSelection\n    },\n    input: {} as {\n      editor: Editor\n      rules: Array<InputRule>\n    },\n    events: {} as InputRuleMachineEvent,\n  },\n  actors: {\n    'delete.backward listener': fromCallback(deleteBackwardListenerCallback),\n    'input rule listener': fromCallback(inputRuleListenerCallback),\n    'selection listener': fromCallback(selectionListenerCallback),\n  },\n  guards: {\n    'selection changed': ({context, event}) => {\n      if (event.type !== 'selection changed') {\n        return false\n      }\n\n      // When block offsets are available for both the end state and the\n      // current selection, compare them. Block offsets normalize away\n      // span-level differences (e.g. cursor at the same position but in a\n      // different span after normalization).\n      if (event.blockOffsets && context.endOffsets) {\n        const startChanged =\n          context.endOffsets.start.path[0]._key !==\n            event.blockOffsets.start.path[0]._key ||\n          context.endOffsets.start.offset !== event.blockOffsets.start.offset\n        const endChanged =\n          context.endOffsets.end.path[0]._key !==\n            event.blockOffsets.end.path[0]._key ||\n          context.endOffsets.end.offset !== event.blockOffsets.end.offset\n\n        return startChanged || endChanged\n      }\n\n      // Block offsets can't be computed when the cursor is on an inline\n      // object (e.g. after a stock ticker rule inserts one). Fall back to\n      // comparing the raw selections.\n      return !isEqualSelections(context.endSelection, event.selection)\n    },\n  },\n})\n\nconst assignEndState = inputRuleSetup.assign({\n  endOffsets: ({context, event}) =>\n    event.type === 'input rule raised' ? event.endOffsets : context.endOffsets,\n  endSelection: ({context, event}) =>\n    event.type === 'input rule raised'\n      ? event.endSelection\n      : context.endSelection,\n})\n\nconst inputRuleMachine = inputRuleSetup.createMachine({\n  id: 'input rule',\n  context: ({input}) => ({\n    editor: input.editor,\n    rules: input.rules,\n    endOffsets: undefined,\n    endSelection: null,\n  }),\n  initial: 'idle',\n  invoke: {\n    src: 'input rule listener',\n    input: ({context}) => ({\n      editor: context.editor,\n      rules: context.rules,\n    }),\n  },\n  on: {\n    'input rule raised': {\n      target: '.input rule applied',\n      actions: assignEndState,\n    },\n  },\n  states: {\n    'idle': {},\n    'input rule applied': {\n      invoke: [\n        {\n          src: 'delete.backward listener',\n          input: ({context}) => ({editor: context.editor}),\n        },\n        {\n          src: 'selection listener',\n          input: ({context}) => ({editor: context.editor}),\n        },\n      ],\n      on: {\n        'selection changed': {\n          target: 'idle',\n          guard: 'selection changed',\n        },\n        'history.undo raised': {\n          target: 'idle',\n        },\n      },\n    },\n  },\n})\n","import {raise, type BehaviorAction} from '@portabletext/editor/behaviors'\nimport {getMarkState} from '@portabletext/editor/selectors'\nimport type {InputRule, InputRuleGuard} from './input-rule'\nimport type {InputRuleMatchLocation} from './input-rule-match-location'\n\n/**\n * @alpha\n */\nexport type TextTransformRule<TGuardResponse = true> = {\n  on: RegExp\n  guard?: InputRuleGuard<TGuardResponse>\n  transform: (\n    {location}: {location: InputRuleMatchLocation},\n    guardResponse: TGuardResponse,\n  ) => string\n}\n\n/**\n * Define an `InputRule` specifically designed to transform matched text into\n * some other text.\n *\n * @example\n * ```tsx\n * const transformRule = defineTextTransformRule({\n *   on: /--/,\n *   transform: () => '',\n * })\n * ```\n *\n * @alpha\n */\nexport function defineTextTransformRule<TGuardResponse = true>(\n  config: TextTransformRule<TGuardResponse>,\n): InputRule<TGuardResponse> {\n  return {\n    on: config.on,\n    guard: config.guard ?? (() => true as TGuardResponse),\n    actions: [\n      ({snapshot, event}, guardResponse) => {\n        const locations = event.matches.flatMap((match) =>\n          match.groupMatches.length === 0 ? [match] : match.groupMatches,\n        )\n        const newText = event.textBefore + event.textInserted\n\n        let textLengthDelta = 0\n        const actions: Array<BehaviorAction> = []\n\n        for (const location of locations.reverse()) {\n          const text = config.transform({location}, guardResponse)\n\n          textLengthDelta =\n            textLengthDelta -\n            (text.length -\n              (location.targetOffsets.focus.offset -\n                location.targetOffsets.anchor.offset))\n\n          actions.push(raise({type: 'select', at: location.targetOffsets}))\n          actions.push(raise({type: 'delete', at: location.targetOffsets}))\n          actions.push(\n            raise({\n              type: 'insert.child',\n              child: {\n                _type: snapshot.context.schema.span.name,\n                text,\n                marks:\n                  getMarkState({\n                    ...snapshot,\n                    context: {\n                      ...snapshot.context,\n                      selection: {\n                        anchor: location.selection.anchor,\n                        focus: {\n                          path: location.selection.focus.path,\n                          offset: Math.min(\n                            location.selection.focus.offset,\n                            event.textBefore.length,\n                          ),\n                        },\n                      },\n                    },\n                  })?.marks ?? [],\n              },\n            }),\n          )\n        }\n\n        const endCaretPosition = {\n          path: event.focusBlock.path,\n          offset: newText.length - textLengthDelta,\n        }\n\n        return [\n          ...actions,\n          raise({\n            type: 'select',\n            at: {\n              anchor: endCaretPosition,\n              focus: endCaretPosition,\n            },\n          }),\n        ]\n      },\n    ],\n  }\n}\n"],"names":["defineInputRule","config","getInputRuleMatchLocation","match","adjustIndexBy","snapshot","focusBlock","originalTextBefore","text","start","end","adjustedIndex","targetOffsets","anchor","path","offset","focus","backward","normalizedOffsets","Math","min","length","anchorBackwards","blockOffsetToSpanSelectionPoint","context","blockOffset","direction","focusForwards","selection","inlineObjectsAfterMatch","getNextInlineObjects","inlineObjectsBefore","getPreviousInlineObjects","some","inlineObjectAfter","inlineObjectBefore","node","_key","defineInputRuleBehavior","defineBehavior","on","guard","event","dom","isSelectionCollapsed","getFocusBlock","getBlockTextBefore","textBefore","originalNewText","newText","foundMatches","foundActions","rule","rules","matcher","RegExp","source","ruleMatches","matchAll","flatMap","regExpMatch","indices","undefined","at","matchLocation","foundMatch","groupMatches","slice","filter","index","guardResult","type","matches","textInserted","actionSets","actions","map","action","actionSet","push","forward","_","effect","blockOffsets","getBlockOffsets","onApply","endOffsets","endSelection","InputRulePlugin","props","$","_c","editor","useEditor","t0","input","useActorRef","inputRuleMachine","inputRuleListenerCallback","sendBack","unregister","registerBehavior","behavior","deleteBackwardListenerCallback","raise","selectionListenerCallback","subscription","getSnapshot","unsubscribe","inputRuleSetup","setup","types","events","actors","fromCallback","guards","selection changed","startChanged","endChanged","isEqualSelections","assignEndState","assign","createMachine","id","initial","invoke","src","target","states","defineTextTransformRule","guardResponse","locations","textLengthDelta","location","reverse","transform","child","_type","schema","span","name","marks","getMarkState","endCaretPosition"],"mappings":"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"}},
    {"offset": {"line": 5480, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@portabletext/plugin-markdown-shortcuts/dist/index.js","sources":["file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/plugin-markdown-shortcuts/src/behavior.markdown-shortcuts.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/plugin-markdown-shortcuts/src/rule.blockquote.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/plugin-markdown-shortcuts/src/rule.heading.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/plugin-markdown-shortcuts/src/rule.horizontal-rule.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/plugin-markdown-shortcuts/src/rule.markdown-link.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/plugin-markdown-shortcuts/src/rule.ordered-list.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/plugin-markdown-shortcuts/src/rule.unordered-list.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/plugin-markdown-shortcuts/src/plugin.markdown-shortcuts.tsx"],"sourcesContent":["import type {EditorContext} from '@portabletext/editor'\nimport {defineBehavior, raise} from '@portabletext/editor/behaviors'\nimport * as selectors from '@portabletext/editor/selectors'\n\nexport type ObjectWithOptionalKey = {\n  _type: string\n  _key?: string\n  [other: string]: unknown\n}\n\nexport type MarkdownBehaviorsConfig = {\n  horizontalRuleObject?: ({\n    context,\n  }: {\n    context: Pick<EditorContext, 'schema' | 'keyGenerator'>\n  }) => ObjectWithOptionalKey | undefined\n  defaultStyle?: ({\n    context,\n    schema,\n  }: {\n    context: Pick<EditorContext, 'schema'>\n    /**\n     * @deprecated Use `context.schema` instead\n     */\n    schema: EditorContext['schema']\n  }) => string | undefined\n}\n\nexport function createMarkdownBehaviors(config: MarkdownBehaviorsConfig) {\n  const automaticHrOnPaste = defineBehavior({\n    on: 'clipboard.paste',\n    guard: ({snapshot, event}) => {\n      const text = event.originEvent.dataTransfer.getData('text/plain')\n      const hrRegExp = /^(---)$|^(-)$|^(___)$|^(\\*\\*\\*)$/\n      const hrCharacters = text.match(hrRegExp)?.[0]\n      const hrObject = config.horizontalRuleObject?.({\n        context: {\n          schema: snapshot.context.schema,\n          keyGenerator: snapshot.context.keyGenerator,\n        },\n      })\n      const focusBlock = selectors.getFocusBlock(snapshot)\n      const focusTextBlock = selectors.getFocusTextBlock(snapshot)\n\n      if (!hrCharacters || !hrObject || !focusBlock) {\n        return false\n      }\n\n      return {hrCharacters, hrObject, focusBlock, focusTextBlock}\n    },\n    actions: [\n      (_, {hrCharacters}) => [\n        raise({\n          type: 'insert.text',\n          text: hrCharacters,\n        }),\n      ],\n      ({snapshot}, {hrObject, focusBlock, focusTextBlock}) =>\n        focusTextBlock\n          ? [\n              raise({\n                type: 'insert.block',\n                block: {\n                  _type: snapshot.context.schema.block.name,\n                  children: focusTextBlock.node.children,\n                },\n                placement: 'after',\n              }),\n              raise({\n                type: 'insert.block',\n                block: hrObject,\n                placement: 'after',\n              }),\n              raise({\n                type: 'delete.block',\n                at: focusBlock.path,\n              }),\n            ]\n          : [\n              raise({\n                type: 'insert.block',\n                block: hrObject,\n                placement: 'after',\n              }),\n            ],\n    ],\n  })\n\n  const clearStyleOnBackspace = defineBehavior({\n    on: 'delete.backward',\n    guard: ({snapshot}) => {\n      const selectionCollapsed = selectors.isSelectionCollapsed(snapshot)\n      const focusTextBlock = selectors.getFocusTextBlock(snapshot)\n      const focusSpan = selectors.getFocusSpan(snapshot)\n\n      if (!selectionCollapsed || !focusTextBlock || !focusSpan) {\n        return false\n      }\n\n      const atTheBeginningOfBLock =\n        focusTextBlock.node.children[0]._key === focusSpan.node._key &&\n        snapshot.context.selection?.focus.offset === 0\n\n      const defaultStyle = config.defaultStyle?.({\n        context: {schema: snapshot.context.schema},\n        schema: snapshot.context.schema,\n      })\n\n      if (\n        atTheBeginningOfBLock &&\n        defaultStyle &&\n        focusTextBlock.node.style !== defaultStyle\n      ) {\n        return {defaultStyle, focusTextBlock}\n      }\n\n      return false\n    },\n    actions: [\n      (_, {defaultStyle, focusTextBlock}) => [\n        raise({\n          type: 'block.set',\n          props: {style: defaultStyle},\n          at: focusTextBlock.path,\n        }),\n      ],\n    ],\n  })\n\n  const markdownBehaviors = [automaticHrOnPaste, clearStyleOnBackspace]\n\n  return markdownBehaviors\n}\n","import type {EditorContext} from '@portabletext/editor'\nimport {raise} from '@portabletext/editor/behaviors'\nimport {getPreviousInlineObject} from '@portabletext/editor/selectors'\nimport {defineInputRule} from '@portabletext/plugin-input-rule'\n\nexport function createBlockquoteRule(config: {\n  blockquoteStyle: ({\n    context,\n    schema,\n  }: {\n    context: Pick<EditorContext, 'schema'>\n    /**\n     * @deprecated Use `context.schema` instead\n     */\n    schema: EditorContext['schema']\n  }) => string | undefined\n}) {\n  return defineInputRule({\n    on: /^> /,\n    guard: ({snapshot, event}) => {\n      const style = config.blockquoteStyle({\n        context: {schema: snapshot.context.schema},\n        schema: snapshot.context.schema,\n      })\n\n      if (!style) {\n        return false\n      }\n\n      const previousInlineObject = getPreviousInlineObject(snapshot)\n\n      if (previousInlineObject) {\n        return false\n      }\n\n      const match = event.matches.at(0)\n\n      if (!match) {\n        return false\n      }\n\n      return {style, match}\n    },\n    actions: [\n      ({event}, {style, match}) => [\n        raise({\n          type: 'block.unset',\n          props: ['listItem', 'level'],\n          at: event.focusBlock.path,\n        }),\n        raise({\n          type: 'block.set',\n          props: {style},\n          at: event.focusBlock.path,\n        }),\n        raise({\n          type: 'delete',\n          at: match.targetOffsets,\n        }),\n      ],\n    ],\n  })\n}\n","import type {EditorContext} from '@portabletext/editor'\nimport {raise} from '@portabletext/editor/behaviors'\nimport {getPreviousInlineObject} from '@portabletext/editor/selectors'\nimport {defineInputRule} from '@portabletext/plugin-input-rule'\n\nexport function createHeadingRule(config: {\n  headingStyle: ({\n    context,\n    schema,\n    props,\n    level,\n  }: {\n    context: Pick<EditorContext, 'schema'>\n    /**\n     * @deprecated Use `context.schema` instead\n     */\n    schema: EditorContext['schema']\n    props: {level: number}\n    /**\n     * @deprecated Use `props.level` instead\n     */\n    level: number\n  }) => string | undefined\n}) {\n  return defineInputRule({\n    on: /^#+ /,\n    guard: ({snapshot, event}) => {\n      const previousInlineObject = getPreviousInlineObject(snapshot)\n\n      if (previousInlineObject) {\n        return false\n      }\n\n      const match = event.matches.at(0)\n\n      if (!match) {\n        return false\n      }\n\n      const level = match.text.length - 1\n\n      const style = config.headingStyle({\n        context: {schema: snapshot.context.schema},\n        schema: snapshot.context.schema,\n        props: {level},\n        level,\n      })\n\n      if (!style) {\n        return false\n      }\n\n      return {match, style}\n    },\n    actions: [\n      ({event}, {match, style}) => [\n        raise({\n          type: 'block.unset',\n          props: ['listItem', 'level'],\n          at: event.focusBlock.path,\n        }),\n        raise({\n          type: 'block.set',\n          props: {style},\n          at: event.focusBlock.path,\n        }),\n        raise({\n          type: 'delete',\n          at: match.targetOffsets,\n        }),\n      ],\n    ],\n  })\n}\n","import type {EditorContext} from '@portabletext/editor'\nimport {raise} from '@portabletext/editor/behaviors'\nimport {getPreviousInlineObject} from '@portabletext/editor/selectors'\nimport {defineInputRule} from '@portabletext/plugin-input-rule'\nimport type {ObjectWithOptionalKey} from './behavior.markdown-shortcuts'\n\nexport function createHorizontalRuleRule(config: {\n  horizontalRuleObject: ({\n    context,\n  }: {\n    context: Pick<EditorContext, 'schema' | 'keyGenerator'>\n  }) => ObjectWithOptionalKey | undefined\n}) {\n  return defineInputRule({\n    on: /^(---)|^(-)|^(___)|^(\\*\\*\\*)/,\n    guard: ({snapshot, event}) => {\n      const hrObject = config.horizontalRuleObject({\n        context: {\n          schema: snapshot.context.schema,\n          keyGenerator: snapshot.context.keyGenerator,\n        },\n      })\n\n      if (!hrObject) {\n        // If no horizontal rule object is provided, then we can safely skip\n        // this rule.\n        return false\n      }\n\n      const previousInlineObject = getPreviousInlineObject(snapshot)\n\n      if (previousInlineObject) {\n        // Input Rules only look at the plain text of the text block. This\n        // means that the RegExp is matched even if there is a leading inline\n        // object.\n        return false\n      }\n\n      // In theory, an Input Rule could return multiple matches. But in this\n      // case we only expect one match.\n      const match = event.matches.at(0)\n\n      if (!match) {\n        return false\n      }\n\n      return {hrObject, match}\n    },\n    actions: [\n      (_, {hrObject, match}) => [\n        raise({\n          type: 'insert.block',\n          block: hrObject,\n          placement: 'before',\n          select: 'none',\n        }),\n        raise({\n          type: 'delete',\n          at: match.targetOffsets,\n        }),\n      ],\n    ],\n  })\n}\n","import type {EditorContext} from '@portabletext/editor'\nimport {raise, type BehaviorAction} from '@portabletext/editor/behaviors'\nimport {defineInputRule} from '@portabletext/plugin-input-rule'\nimport type {ObjectWithOptionalKey} from './behavior.markdown-shortcuts'\n\nexport function createMarkdownLinkRule(config: {\n  linkObject: ({\n    context,\n    props,\n  }: {\n    context: Pick<EditorContext, 'schema' | 'keyGenerator'>\n    props: {href: string}\n  }) => ObjectWithOptionalKey | undefined\n}) {\n  return defineInputRule({\n    on: /\\[([^[\\]]+)]\\((.+)\\)/,\n    actions: [\n      ({snapshot, event}) => {\n        const newText = event.textBefore + event.textInserted\n        let textLengthDelta = 0\n        const actions: Array<BehaviorAction> = []\n\n        for (const match of event.matches.reverse()) {\n          const textMatch = match.groupMatches.at(0)\n          const hrefMatch = match.groupMatches.at(1)\n\n          if (textMatch === undefined || hrefMatch === undefined) {\n            continue\n          }\n\n          textLengthDelta =\n            textLengthDelta -\n            (match.targetOffsets.focus.offset -\n              match.targetOffsets.anchor.offset -\n              textMatch.text.length)\n\n          const linkObject = config.linkObject({\n            context: {\n              schema: snapshot.context.schema,\n              keyGenerator: snapshot.context.keyGenerator,\n            },\n            props: {href: hrefMatch.text},\n          })\n\n          if (!linkObject) {\n            continue\n          }\n\n          const {_type, _key, ...value} = linkObject\n\n          const leftSideOffsets = {\n            anchor: match.targetOffsets.anchor,\n            focus: textMatch.targetOffsets.anchor,\n          }\n          const rightSideOffsets = {\n            anchor: textMatch.targetOffsets.focus,\n            focus: match.targetOffsets.focus,\n          }\n\n          actions.push(\n            raise({\n              type: 'select',\n              at: textMatch.targetOffsets,\n            }),\n          )\n          actions.push(\n            raise({\n              type: 'annotation.add',\n              annotation: {\n                name: _type,\n                _key,\n                value,\n              },\n            }),\n          )\n          actions.push(\n            raise({\n              type: 'delete',\n              at: rightSideOffsets,\n            }),\n          )\n          actions.push(\n            raise({\n              type: 'delete',\n              at: leftSideOffsets,\n            }),\n          )\n        }\n\n        const endCaretPosition = {\n          path: event.focusBlock.path,\n          offset: newText.length - textLengthDelta * -1,\n        }\n\n        return [\n          ...actions,\n          raise({\n            type: 'select',\n            at: {\n              anchor: endCaretPosition,\n              focus: endCaretPosition,\n            },\n          }),\n        ]\n      },\n    ],\n  })\n}\n","import type {EditorContext} from '@portabletext/editor'\nimport {raise} from '@portabletext/editor/behaviors'\nimport {getPreviousInlineObject} from '@portabletext/editor/selectors'\nimport {defineInputRule} from '@portabletext/plugin-input-rule'\n\nexport function createOrderedListRule(config: {\n  orderedList: ({\n    context,\n    schema,\n  }: {\n    context: Pick<EditorContext, 'schema'>\n    /**\n     * @deprecated Use `context.schema` instead\n     */\n    schema: EditorContext['schema']\n  }) => string | undefined\n}) {\n  return defineInputRule({\n    on: /^1\\. /,\n    guard: ({snapshot, event}) => {\n      const orderedList = config.orderedList({\n        context: {schema: snapshot.context.schema},\n        schema: snapshot.context.schema,\n      })\n\n      if (!orderedList) {\n        return false\n      }\n\n      const previousInlineObject = getPreviousInlineObject(snapshot)\n\n      if (previousInlineObject) {\n        return false\n      }\n\n      const match = event.matches.at(0)\n\n      if (!match) {\n        return false\n      }\n\n      return {match, orderedList}\n    },\n    actions: [\n      ({event}, {match, orderedList}) => [\n        raise({\n          type: 'block.unset',\n          props: ['style'],\n          at: event.focusBlock.path,\n        }),\n        raise({\n          type: 'block.set',\n          props: {\n            listItem: orderedList,\n            level: event.focusBlock.node.level ?? 1,\n          },\n          at: event.focusBlock.path,\n        }),\n        raise({\n          type: 'delete',\n          at: match.targetOffsets,\n        }),\n      ],\n    ],\n  })\n}\n","import type {EditorContext} from '@portabletext/editor'\nimport {raise} from '@portabletext/editor/behaviors'\nimport {getPreviousInlineObject} from '@portabletext/editor/selectors'\nimport {defineInputRule} from '@portabletext/plugin-input-rule'\n\nexport function createUnorderedListRule(config: {\n  unorderedList: ({\n    context,\n    schema,\n  }: {\n    context: Pick<EditorContext, 'schema'>\n    /**\n     * @deprecated Use `context.schema` instead\n     */\n    schema: EditorContext['schema']\n  }) => string | undefined\n}) {\n  return defineInputRule({\n    on: /^(-|\\*) /,\n    guard: ({snapshot, event}) => {\n      const unorderedList = config.unorderedList({\n        context: {schema: snapshot.context.schema},\n        schema: snapshot.context.schema,\n      })\n\n      if (!unorderedList) {\n        return false\n      }\n\n      const previousInlineObject = getPreviousInlineObject(snapshot)\n\n      if (previousInlineObject) {\n        return false\n      }\n\n      const match = event.matches.at(0)\n\n      if (!match) {\n        return false\n      }\n\n      return {match, unorderedList}\n    },\n    actions: [\n      ({event}, {match, unorderedList}) => [\n        raise({\n          type: 'block.unset',\n          props: ['style'],\n          at: event.focusBlock.path,\n        }),\n        raise({\n          type: 'block.set',\n          props: {\n            listItem: unorderedList,\n            level: event.focusBlock.node.level ?? 1,\n          },\n          at: event.focusBlock.path,\n        }),\n        raise({\n          type: 'delete',\n          at: match.targetOffsets,\n        }),\n      ],\n    ],\n  })\n}\n","import type {EditorContext} from '@portabletext/editor'\nimport {useEditor} from '@portabletext/editor'\nimport {CharacterPairDecoratorPlugin} from '@portabletext/plugin-character-pair-decorator'\nimport {InputRulePlugin} from '@portabletext/plugin-input-rule'\nimport {useEffect, useMemo} from 'react'\nimport {\n  createMarkdownBehaviors,\n  type MarkdownBehaviorsConfig,\n  type ObjectWithOptionalKey,\n} from './behavior.markdown-shortcuts'\nimport {createBlockquoteRule} from './rule.blockquote'\nimport {createHeadingRule} from './rule.heading'\nimport {createHorizontalRuleRule} from './rule.horizontal-rule'\nimport {createMarkdownLinkRule} from './rule.markdown-link'\nimport {createOrderedListRule} from './rule.ordered-list'\nimport {createUnorderedListRule} from './rule.unordered-list'\n\n/**\n * @public\n */\nexport type MarkdownShortcutsPluginProps = MarkdownBehaviorsConfig & {\n  blockquoteStyle?: ({\n    context,\n    schema,\n  }: {\n    context: Pick<EditorContext, 'schema'>\n    /**\n     * @deprecated Use `context.schema` instead\n     */\n    schema: EditorContext['schema']\n  }) => string | undefined\n  defaultStyle?: ({\n    context,\n    schema,\n  }: {\n    context: Pick<EditorContext, 'schema'>\n    /**\n     * @deprecated Use `context.schema` instead\n     */\n    schema: EditorContext['schema']\n  }) => string | undefined\n  headingStyle?: ({\n    context,\n    schema,\n    props,\n    level,\n  }: {\n    context: Pick<EditorContext, 'schema'>\n    /**\n     * @deprecated Use `context.schema` instead\n     */\n    schema: EditorContext['schema']\n    props: {level: number}\n    /**\n     * @deprecated Use `props.level` instead\n     */\n    level: number\n  }) => string | undefined\n  linkObject?: ({\n    context,\n    props,\n  }: {\n    context: Pick<EditorContext, 'schema' | 'keyGenerator'>\n    props: {href: string}\n  }) => ObjectWithOptionalKey | undefined\n  unorderedList?: ({\n    context,\n    schema,\n  }: {\n    context: Pick<EditorContext, 'schema'>\n    /**\n     * @deprecated Use `context.schema` instead\n     */\n    schema: EditorContext['schema']\n  }) => string | undefined\n  orderedList?: ({\n    context,\n    schema,\n  }: {\n    context: Pick<EditorContext, 'schema'>\n    /**\n     * @deprecated Use `context.schema` instead\n     */\n    schema: EditorContext['schema']\n  }) => string | undefined\n  boldDecorator?: ({\n    context,\n    schema,\n  }: {\n    context: Pick<EditorContext, 'schema'>\n    /**\n     * @deprecated Use `context.schema` instead\n     */\n    schema: EditorContext['schema']\n  }) => string | undefined\n  codeDecorator?: ({\n    context,\n    schema,\n  }: {\n    context: Pick<EditorContext, 'schema'>\n    /**\n     * @deprecated Use `context.schema` instead\n     */\n    schema: EditorContext['schema']\n  }) => string | undefined\n  italicDecorator?: ({\n    context,\n    schema,\n  }: {\n    context: Pick<EditorContext, 'schema'>\n    /**\n     * @deprecated Use `context.schema` instead\n     */\n    schema: EditorContext['schema']\n  }) => string | undefined\n  strikeThroughDecorator?: ({\n    context,\n    schema,\n  }: {\n    context: Pick<EditorContext, 'schema'>\n    /**\n     * @deprecated Use `context.schema` instead\n     */\n    schema: EditorContext['schema']\n  }) => string | undefined\n}\n\n/**\n * @public\n */\nexport function MarkdownShortcutsPlugin({\n  blockquoteStyle,\n  boldDecorator,\n  codeDecorator,\n  defaultStyle,\n  headingStyle,\n  horizontalRuleObject,\n  linkObject,\n  italicDecorator,\n  orderedList,\n  strikeThroughDecorator,\n  unorderedList,\n}: MarkdownShortcutsPluginProps) {\n  const editor = useEditor()\n\n  useEffect(() => {\n    const behaviors = createMarkdownBehaviors({\n      defaultStyle,\n    })\n\n    const unregisterBehaviors = behaviors.map((behavior) =>\n      editor.registerBehavior({behavior}),\n    )\n\n    return () => {\n      for (const unregisterBehavior of unregisterBehaviors) {\n        unregisterBehavior()\n      }\n    }\n  }, [defaultStyle, editor])\n\n  const inputRules = useMemo(() => {\n    const rules = []\n    if (blockquoteStyle) {\n      rules.push(createBlockquoteRule({blockquoteStyle}))\n    }\n    if (headingStyle) {\n      rules.push(createHeadingRule({headingStyle}))\n    }\n    if (horizontalRuleObject) {\n      rules.push(createHorizontalRuleRule({horizontalRuleObject}))\n    }\n    if (linkObject) {\n      rules.push(createMarkdownLinkRule({linkObject}))\n    }\n    if (orderedList) {\n      rules.push(createOrderedListRule({orderedList}))\n    }\n    if (unorderedList) {\n      rules.push(createUnorderedListRule({unorderedList}))\n    }\n    return rules.length > 0 ? rules : null\n  }, [\n    blockquoteStyle,\n    headingStyle,\n    horizontalRuleObject,\n    linkObject,\n    orderedList,\n    unorderedList,\n  ])\n\n  return (\n    <>\n      {boldDecorator ? (\n        <>\n          <CharacterPairDecoratorPlugin\n            decorator={boldDecorator}\n            pair={{char: '*', amount: 2}}\n          />\n          <CharacterPairDecoratorPlugin\n            decorator={boldDecorator}\n            pair={{char: '_', amount: 2}}\n          />\n        </>\n      ) : null}\n      {codeDecorator ? (\n        <CharacterPairDecoratorPlugin\n          decorator={codeDecorator}\n          pair={{char: '`', amount: 1}}\n        />\n      ) : null}\n      {italicDecorator ? (\n        <>\n          <CharacterPairDecoratorPlugin\n            decorator={italicDecorator}\n            pair={{char: '*', amount: 1}}\n          />\n          <CharacterPairDecoratorPlugin\n            decorator={italicDecorator}\n            pair={{char: '_', amount: 1}}\n          />\n        </>\n      ) : null}\n      {strikeThroughDecorator ? (\n        <CharacterPairDecoratorPlugin\n          decorator={strikeThroughDecorator}\n          pair={{char: '~', amount: 2}}\n        />\n      ) : null}\n      {inputRules ? <InputRulePlugin rules={inputRules} /> : null}\n    </>\n  )\n}\n"],"names":["createMarkdownBehaviors","config","automaticHrOnPaste","defineBehavior","on","guard","snapshot","event","text","originEvent","dataTransfer","getData","hrRegExp","hrCharacters","match","hrObject","horizontalRuleObject","context","schema","keyGenerator","focusBlock","selectors","getFocusBlock","focusTextBlock","getFocusTextBlock","actions","_","raise","type","block","_type","name","children","node","placement","at","path","clearStyleOnBackspace","selectionCollapsed","isSelectionCollapsed","focusSpan","getFocusSpan","atTheBeginningOfBLock","_key","selection","focus","offset","defaultStyle","style","props","createBlockquoteRule","defineInputRule","blockquoteStyle","getPreviousInlineObject","matches","targetOffsets","createHeadingRule","level","length","headingStyle","createHorizontalRuleRule","select","createMarkdownLinkRule","newText","textBefore","textInserted","textLengthDelta","reverse","textMatch","groupMatches","hrefMatch","undefined","anchor","linkObject","href","value","leftSideOffsets","rightSideOffsets","push","annotation","endCaretPosition","createOrderedListRule","orderedList","listItem","createUnorderedListRule","unorderedList","MarkdownShortcutsPlugin","t0","$","_c","boldDecorator","codeDecorator","italicDecorator","strikeThroughDecorator","editor","useEditor","t1","t2","unregisterBehaviors","map","behavior","registerBehavior","unregisterBehavior","useEffect","rules","t3","inputRules","char","amount","t4","t5","t6","t7","t8"],"mappings":"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"}},
    {"offset": {"line": 5987, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@portabletext/plugin-paste-link/dist/index.js","sources":["file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/plugin-paste-link/src/looks-like-url.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/plugin-paste-link/src/plugin.paste-link.tsx"],"sourcesContent":["export function looksLikeUrl(text: string) {\n  try {\n    const url = new URL(text)\n    return sensibleProtocols.includes(url.protocol)\n  } catch {\n    return false\n  }\n}\n\nconst sensibleProtocols = ['http:', 'https:', 'mailto:', 'tel:']\n","import type {EditorContext} from '@portabletext/editor'\nimport {useEditor} from '@portabletext/editor'\nimport {\n  defineBehavior,\n  raise,\n  type BehaviorGuard,\n  type NativeBehaviorEvent,\n} from '@portabletext/editor/behaviors'\nimport * as selectors from '@portabletext/editor/selectors'\nimport {useEffect} from 'react'\nimport {looksLikeUrl} from './looks-like-url'\n\n/**\n * Guard function that controls when the paste link behavior runs.\n * Return `false` to skip the behavior and fall through to default paste handling.\n * @public\n */\nexport type PasteLinkGuard = BehaviorGuard<\n  Extract<NativeBehaviorEvent, {type: 'clipboard.paste'}>,\n  true\n>\n\n/**\n * Context provided to link matchers.\n * @public\n */\nexport type LinkMatcherContext = Pick<EditorContext, 'schema' | 'keyGenerator'>\n\n/**\n * Value provided to link matchers.\n * @public\n */\nexport type LinkMatcherValue = {href: string}\n\n/**\n * Object returned by link matchers.\n * @public\n */\nexport type LinkMatcherResult = {\n  _type: string\n  _key?: string\n  [other: string]: unknown\n}\n\n/**\n * Function that converts a pasted URL into a link annotation.\n * Return `undefined` to skip handling.\n * @public\n */\nexport type LinkMatcher = (params: {\n  context: LinkMatcherContext\n  value: LinkMatcherValue\n}) => LinkMatcherResult | undefined\n\n/**\n * @public\n */\nexport type PasteLinkPluginProps = {\n  guard?: PasteLinkGuard\n  link?: LinkMatcher\n}\n\nconst defaultLinkMatcher: LinkMatcher = ({context, value}) => {\n  const schemaType = context.schema.annotations.find(\n    (annotation) => annotation.name === 'link',\n  )\n  const hrefField = schemaType?.fields.find(\n    (field) => field.name === 'href' && field.type === 'string',\n  )\n\n  if (!schemaType || !hrefField) {\n    return undefined\n  }\n\n  return {\n    _type: schemaType.name,\n    [hrefField.name]: value.href,\n  }\n}\n\n/**\n * Plugin that handles pasting URLs in the editor.\n *\n * When text is selected and a URL is pasted, adds a link annotation to the selection.\n * When the caret is collapsed (no selection) and a URL is pasted, inserts the URL as text with a link annotation.\n *\n * @public\n */\nexport function PasteLinkPlugin({\n  guard,\n  link = defaultLinkMatcher,\n}: PasteLinkPluginProps) {\n  const editor = useEditor()\n\n  useEffect(() => {\n    const behaviors = createPasteLinkBehaviors({guard, link})\n    const unregisterBehaviors = behaviors.map((behavior) =>\n      editor.registerBehavior({behavior}),\n    )\n\n    return () => {\n      for (const unregisterBehavior of unregisterBehaviors) {\n        unregisterBehavior()\n      }\n    }\n  }, [editor, guard, link])\n\n  return null\n}\n\nfunction createPasteLinkBehaviors(\n  config: Required<Pick<PasteLinkPluginProps, 'link'>> &\n    Pick<PasteLinkPluginProps, 'guard'>,\n) {\n  /**\n   * When text is selected and a URL is pasted, add a link annotation to the\n   * selection. If the selection already has a link annotation, the core\n   * `preventOverlappingAnnotations` behavior will remove it first.\n   */\n  const pasteLinkOnSelection = defineBehavior({\n    on: 'clipboard.paste',\n    guard: (guardParams) => {\n      if (config.guard && config.guard(guardParams) === false) {\n        return false\n      }\n\n      const {snapshot, event} = guardParams\n      const selectionCollapsed = selectors.isSelectionCollapsed(snapshot)\n\n      if (selectionCollapsed) {\n        return false\n      }\n\n      const text = event.originEvent.dataTransfer.getData('text/plain')\n      const href = looksLikeUrl(text) ? text : undefined\n\n      if (!href) {\n        return false\n      }\n\n      const result = config.link({\n        context: {\n          schema: snapshot.context.schema,\n          keyGenerator: snapshot.context.keyGenerator,\n        },\n        value: {href},\n      })\n\n      if (!result) {\n        return false\n      }\n\n      const {_type, _key, ...value} = result\n\n      return {annotation: {name: _type, _key, value}}\n    },\n    actions: [\n      (_, {annotation}) => [\n        raise({\n          type: 'annotation.add',\n          annotation,\n        }),\n      ],\n    ],\n  })\n\n  /**\n   * When the caret is collapsed (no selection) and a URL is pasted, insert the\n   * URL as text with a link annotation. Existing decorators (bold, italic,\n   * etc.) are preserved.\n   */\n  const pasteLinkAtCaret = defineBehavior({\n    on: 'clipboard.paste',\n    guard: (guardParams) => {\n      if (config.guard && config.guard(guardParams) === false) {\n        return false\n      }\n\n      const {snapshot, event} = guardParams\n      const focusTextBlock = selectors.getFocusTextBlock(snapshot)\n      const selectionCollapsed = selectors.isSelectionCollapsed(snapshot)\n\n      if (!focusTextBlock || !selectionCollapsed) {\n        return false\n      }\n\n      const text = event.originEvent.dataTransfer.getData('text/plain')\n      const href = looksLikeUrl(text) ? text : undefined\n\n      if (!href) {\n        return false\n      }\n\n      const result = config.link({\n        context: {\n          schema: snapshot.context.schema,\n          keyGenerator: snapshot.context.keyGenerator,\n        },\n        value: {href},\n      })\n\n      if (!result) {\n        return false\n      }\n\n      const {_type, _key, ...value} = result\n\n      const markState = selectors.getMarkState(snapshot)\n      const decoratorNames = snapshot.context.schema.decorators.map(\n        (decorator) => decorator.name,\n      )\n      const activeDecorators = (markState?.marks ?? []).filter((mark) =>\n        decoratorNames.includes(mark),\n      )\n\n      const markDefKey = _key ?? snapshot.context.keyGenerator()\n      const markDef = {\n        _type,\n        _key: markDefKey,\n        ...value,\n      }\n\n      return {\n        focusTextBlock,\n        markDef,\n        markDefKey,\n        href,\n        activeDecorators,\n      }\n    },\n    actions: [\n      (\n        {snapshot},\n        {focusTextBlock, markDef, markDefKey, href, activeDecorators},\n      ) => [\n        raise({\n          type: 'block.set',\n          at: focusTextBlock.path,\n          props: {\n            markDefs: [...(focusTextBlock.node.markDefs ?? []), markDef],\n          },\n        }),\n        raise({\n          type: 'insert.child',\n          child: {\n            _type: snapshot.context.schema.span.name,\n            text: href,\n            marks: [...activeDecorators, markDefKey],\n          },\n        }),\n      ],\n    ],\n  })\n\n  return [pasteLinkOnSelection, pasteLinkAtCaret]\n}\n"],"names":["looksLikeUrl","text","url","URL","sensibleProtocols","includes","protocol","defaultLinkMatcher","context","value","schemaType","schema","annotations","find","annotation","name","hrefField","fields","field","type","_type","href","PasteLinkPlugin","t0","$","_c","guard","link","t1","undefined","editor","useEditor","t2","t3","unregisterBehaviors","createPasteLinkBehaviors","map","behavior","registerBehavior","unregisterBehavior","useEffect","config","pasteLinkOnSelection","defineBehavior","on","guardParams","snapshot","event","selectors","isSelectionCollapsed","originEvent","dataTransfer","getData","result","keyGenerator","_key","actions","_","raise","pasteLinkAtCaret","focusTextBlock","getFocusTextBlock","selectionCollapsed","markState","getMarkState","decoratorNames","decorators","decorator","activeDecorators","marks","filter","mark","markDefKey","markDef","at","path","props","markDefs","node","child","span"],"mappings":"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"}},
    {"offset": {"line": 6144, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@portabletext/plugin-typography/dist/index.js","sources":["file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/plugin-typography/src/create-decorator-guard.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/plugin-typography/src/input-rules.typography.ts","file:///Users/kyleextrem/Desktop/digest-studio---newcastle-local-marketing/node_modules/%40portabletext/plugin-typography/src/plugin.typography.tsx"],"sourcesContent":["import type {EditorContext, EditorSchema} from '@portabletext/editor'\nimport {\n  getSelectedSpans,\n  isActiveDecorator,\n} from '@portabletext/editor/selectors'\nimport type {InputRuleGuard} from '@portabletext/plugin-input-rule'\n\n/**\n * @public\n * Create an `InputRuleGuard` that can prevent the rule from running inside\n * certain decorators.\n *\n * @example\n * ```tsx\n * const guard = createDecoratorGuard({\n *  decorators: ({context}) => context.schema.decorators.flatMap((decorator) => decorator.name === 'code' ? [] : [decorator.name]),\n * })\n *\n * <TypographyPlugin guard={guard} />\n * ```\n */\nexport function createDecoratorGuard(config: {\n  decorators: ({\n    context,\n  }: {\n    context: Pick<EditorContext, 'schema'>\n  }) => Array<EditorSchema['decorators'][number]['name']>\n}): InputRuleGuard {\n  return ({snapshot, event}) => {\n    const allowedDecorators = config.decorators({\n      context: {\n        schema: snapshot.context.schema,\n      },\n    })\n    const decorators = snapshot.context.schema.decorators.flatMap(\n      (decorator) =>\n        allowedDecorators.includes(decorator.name) ? [] : [decorator.name],\n    )\n\n    if (decorators.length === 0) {\n      return true\n    }\n\n    const matchedSpans = event.matches.flatMap((match) =>\n      getSelectedSpans({\n        ...snapshot,\n        context: {\n          ...snapshot.context,\n          selection: match.selection,\n        },\n      }),\n    )\n\n    let preventInputRule = false\n\n    for (const decorator of decorators) {\n      if (isActiveDecorator(decorator)(snapshot)) {\n        preventInputRule = true\n        break\n      }\n\n      if (matchedSpans.some((span) => span.node.marks?.includes(decorator))) {\n        preventInputRule = true\n        break\n      }\n    }\n\n    return !preventInputRule\n  }\n}\n","import {\n  defineTextTransformRule,\n  type InputRule,\n} from '@portabletext/plugin-input-rule'\n\n/**\n * @public\n */\nexport const emDashRule = defineTextTransformRule({\n  on: /--/,\n  transform: () => '',\n})\n\n/**\n * @public\n */\nexport const ellipsisRule = defineTextTransformRule({\n  on: /\\.\\.\\./,\n  transform: () => '',\n})\n\n/**\n * @public\n */\nexport const openingDoubleQuoteRule = defineTextTransformRule({\n  on: /(?:^|(?<=[\\s{[(<'\"\\u2018\\u201C]))\"/g,\n  transform: () => '',\n})\n\n/**\n * @public\n */\nexport const closingDoubleQuoteRule = defineTextTransformRule({\n  on: /\"/g,\n  transform: () => '',\n})\n\n/**\n * @public\n */\nexport const openingSingleQuoteRule = defineTextTransformRule({\n  on: /(?:^|(?<=[\\s{[(<'\"\\u2018\\u201C]))'/g,\n  transform: () => '',\n})\n\n/**\n * @public\n */\nexport const closingSingleQuoteRule = defineTextTransformRule({\n  on: /'/g,\n  transform: () => '',\n})\n\n/**\n * @public\n */\nexport const smartQuotesRules: Array<InputRule> = [\n  openingDoubleQuoteRule,\n  closingDoubleQuoteRule,\n  openingSingleQuoteRule,\n  closingSingleQuoteRule,\n]\n\n/**\n * @public\n */\nexport const leftArrowRule = defineTextTransformRule({\n  on: /<-/,\n  transform: () => '',\n})\n\n/**\n * @public\n */\nexport const rightArrowRule = defineTextTransformRule({\n  on: /->/,\n  transform: () => '',\n})\n\n/**\n * @public\n */\nexport const copyrightRule = defineTextTransformRule({\n  on: /\\(c\\)/,\n  transform: () => '',\n})\n\n/**\n * @public\n */\nexport const servicemarkRule = defineTextTransformRule({\n  on: /\\(sm\\)/,\n  transform: () => '',\n})\n\n/**\n * @public\n */\nexport const trademarkRule = defineTextTransformRule({\n  on: /\\(tm\\)/,\n  transform: () => '',\n})\n\n/**\n * @beta\n */\nexport const registeredTrademarkRule = defineTextTransformRule({\n  on: /\\(r\\)/,\n  transform: () => '',\n})\n\n/**\n * @public\n */\nexport const oneHalfRule = defineTextTransformRule({\n  on: /(?:^|\\s)(1\\/2)\\s/,\n  transform: () => '',\n})\n\n/**\n * @public\n */\nexport const plusMinusRule = defineTextTransformRule({\n  on: /\\+\\/-/,\n  transform: () => '',\n})\n\n/**\n * @public\n */\nexport const notEqualRule = defineTextTransformRule({\n  on: /!=/,\n  transform: () => '',\n})\n\n/**\n * @public\n */\nexport const laquoRule = defineTextTransformRule({\n  on: /<</,\n  transform: () => '',\n})\n\n/**\n * @public\n */\nexport const raquoRule = defineTextTransformRule({\n  on: />>/,\n  transform: () => '',\n})\n\n/**\n * @public\n */\nexport const multiplicationRule = defineTextTransformRule({\n  on: /\\d+\\s?([*x])\\s?\\d+/,\n  transform: () => '',\n})\n\n/**\n * @public\n */\nexport const superscriptTwoRule = defineTextTransformRule({\n  on: /\\^2/,\n  transform: () => '',\n})\n\n/**\n * @public\n */\nexport const superscriptThreeRule = defineTextTransformRule({\n  on: /\\^3/,\n  transform: () => '',\n})\n\n/**\n * @public\n */\nexport const oneQuarterRule = defineTextTransformRule({\n  on: /(?:^|\\s)(1\\/4)\\s/,\n  transform: () => '',\n})\n\n/**\n * @public\n */\nexport const threeQuartersRule = defineTextTransformRule({\n  on: /(?:^|\\s)(3\\/4)\\s/,\n  transform: () => '',\n})\n","import {\n  InputRulePlugin,\n  type InputRuleGuard,\n} from '@portabletext/plugin-input-rule'\nimport {useMemo} from 'react'\nimport {\n  closingDoubleQuoteRule,\n  closingSingleQuoteRule,\n  copyrightRule,\n  ellipsisRule,\n  emDashRule,\n  laquoRule,\n  leftArrowRule,\n  multiplicationRule,\n  notEqualRule,\n  oneHalfRule,\n  oneQuarterRule,\n  openingDoubleQuoteRule,\n  openingSingleQuoteRule,\n  plusMinusRule,\n  raquoRule,\n  registeredTrademarkRule,\n  rightArrowRule,\n  servicemarkRule,\n  superscriptThreeRule,\n  superscriptTwoRule,\n  threeQuartersRule,\n  trademarkRule,\n} from './input-rules.typography'\n\nconst defaultRuleConfig = [\n  {name: 'emDash', rule: emDashRule, state: 'on'},\n  {name: 'ellipsis', rule: ellipsisRule, state: 'on'},\n  {name: 'openingDoubleQuote', rule: openingDoubleQuoteRule, state: 'on'},\n  {name: 'closingDoubleQuote', rule: closingDoubleQuoteRule, state: 'on'},\n  {name: 'openingSingleQuote', rule: openingSingleQuoteRule, state: 'on'},\n  {name: 'closingSingleQuote', rule: closingSingleQuoteRule, state: 'on'},\n  {name: 'leftArrow', rule: leftArrowRule, state: 'on'},\n  {name: 'rightArrow', rule: rightArrowRule, state: 'on'},\n  {name: 'copyright', rule: copyrightRule, state: 'on'},\n  {name: 'trademark', rule: trademarkRule, state: 'on'},\n  {name: 'servicemark', rule: servicemarkRule, state: 'on'},\n  {name: 'registeredTrademark', rule: registeredTrademarkRule, state: 'on'},\n  {name: 'oneHalf', rule: oneHalfRule, state: 'off'},\n  {name: 'plusMinus', rule: plusMinusRule, state: 'off'},\n  {name: 'laquo', rule: laquoRule, state: 'off'},\n  {name: 'notEqual', rule: notEqualRule, state: 'off'},\n  {name: 'raquo', rule: raquoRule, state: 'off'},\n  {name: 'multiplication', rule: multiplicationRule, state: 'off'},\n  {name: 'superscriptTwo', rule: superscriptTwoRule, state: 'off'},\n  {name: 'superscriptThree', rule: superscriptThreeRule, state: 'off'},\n  {name: 'oneQuarter', rule: oneQuarterRule, state: 'off'},\n  {name: 'threeQuarters', rule: threeQuartersRule, state: 'off'},\n] as const\n\ntype RuleName = (typeof defaultRuleConfig)[number]['name']\n\n/**\n * @public\n */\nexport type TypographyPluginProps<\n  TEnabledRuleName extends RuleName = never,\n  TDisabledRuleName extends Exclude<RuleName, TEnabledRuleName> = never,\n> = {\n  guard?: InputRuleGuard\n  /**\n   * Preset configuration for rules.\n   * - `'default'`: Common typography rules enabled (em dash, ellipsis, quotes, arrows, copyright symbols)\n   * - `'all'`: All rules enabled\n   * - `'none'`: No rules enabled (use with `enable` prop)\n   *\n   * @defaultValue 'default'\n   */\n  preset?: 'default' | 'all' | 'none'\n  /**\n   * Enable specific rules (additive to preset).\n   * Use this to enable additional rules beyond the preset.\n   *\n   * @example\n   * ```tsx\n   * // Enable multiplication and plusMinus in addition to default rules\n   * <TypographyPlugin enable={['multiplication', 'plusMinus']} />\n   * ```\n   */\n  enable?: ReadonlyArray<TEnabledRuleName>\n  /**\n   * Disable specific rules (subtractive from preset).\n   * Use this to disable rules that would otherwise be enabled by the preset.\n   * Cannot contain rules that are in the `enable` array (TypeScript will enforce this).\n   *\n   * @example\n   * ```tsx\n   * // Disable em dash from the default rules\n   * <TypographyPlugin disable={['emDash']} />\n   * ```\n   */\n  disable?: ReadonlyArray<TDisabledRuleName>\n}\n\n/**\n * @public\n */\nexport function TypographyPlugin<\n  TEnabledRuleName extends RuleName = never,\n  TDisabledRuleName extends Exclude<RuleName, TEnabledRuleName> = never,\n>(props: TypographyPluginProps<TEnabledRuleName, TDisabledRuleName>) {\n  const {preset = 'default', enable = [], disable = [], guard} = props\n\n  const configuredInputRules = useMemo(() => {\n    // Determine which rules should be enabled based on preset\n    const enabledRules = new Set<RuleName>()\n\n    if (preset === 'all') {\n      // Enable all rules\n      for (const rule of defaultRuleConfig) {\n        enabledRules.add(rule.name)\n      }\n    } else if (preset === 'default') {\n      // Enable only default rules (state: 'on')\n      for (const rule of defaultRuleConfig) {\n        if (rule.state === 'on') {\n          enabledRules.add(rule.name)\n        }\n      }\n    }\n    // preset === 'none' starts with empty set\n\n    // Apply enable list (additive)\n    for (const ruleName of enable) {\n      enabledRules.add(ruleName)\n    }\n\n    // Apply disable list (subtractive)\n    for (const ruleName of disable) {\n      enabledRules.delete(ruleName)\n    }\n\n    // Build final rule list\n    return defaultRuleConfig.flatMap((rule) =>\n      enabledRules.has(rule.name)\n        ? [{...rule.rule, guard: guard ?? (() => true)}]\n        : [],\n    )\n  }, [preset, enable, disable, guard])\n\n  return <InputRulePlugin rules={configuredInputRules} />\n}\n"],"names":["createDecoratorGuard","config","snapshot","event","allowedDecorators","decorators","context","schema","flatMap","decorator","includes","name","length","matchedSpans","matches","match","getSelectedSpans","selection","preventInputRule","isActiveDecorator","some","span","node","marks","emDashRule","defineTextTransformRule","on","transform","ellipsisRule","openingDoubleQuoteRule","closingDoubleQuoteRule","openingSingleQuoteRule","closingSingleQuoteRule","smartQuotesRules","leftArrowRule","rightArrowRule","copyrightRule","servicemarkRule","trademarkRule","registeredTrademarkRule","oneHalfRule","plusMinusRule","notEqualRule","laquoRule","raquoRule","multiplicationRule","superscriptTwoRule","superscriptThreeRule","oneQuarterRule","threeQuartersRule","defaultRuleConfig","rule","state","TypographyPlugin","props","$","_c","preset","t0","enable","t1","disable","t2","guard","undefined","t3","t4","enabledRules","Set","add","rule_0","ruleName","ruleName_0","delete","t5","rule_1","has","_temp","configuredInputRules","t6"],"mappings":"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"}}]
}